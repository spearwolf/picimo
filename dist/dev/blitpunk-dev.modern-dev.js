webpackJsonpBLITPUNK([2],{

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["BLITPUNK"] = factory();
	else
		root["BLITPUNK"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 73);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint no-multi-spaces: ["error", { exceptions: { "VariableDeclarator": true } }] */

const DOM_ELEM_CANVAS = exports.DOM_ELEM_CANVAS = 'blitpunk-canvas';
const DOM_ELEM_SCENE = exports.DOM_ELEM_SCENE = 'blitpunk-scene';
const DOM_ELEM_SPRITE_GROUP = exports.DOM_ELEM_SPRITE_GROUP = 'blitpunk-sprite-group';
const DOM_ELEM_TEXTURE_ATLAS = exports.DOM_ELEM_TEXTURE_ATLAS = 'blitpunk-texture-atlas';

const NODE_NAME_CANVAS = exports.NODE_NAME_CANVAS = DOM_ELEM_CANVAS.toUpperCase();
const NODE_NAME_SCENE = exports.NODE_NAME_SCENE = DOM_ELEM_SCENE.toUpperCase();
const NODE_NAME_SPRITE_GROUP = exports.NODE_NAME_SPRITE_GROUP = DOM_ELEM_SPRITE_GROUP.toUpperCase();
const NODE_NAME_TEXTURE_ATLAS = exports.NODE_NAME_TEXTURE_ATLAS = DOM_ELEM_TEXTURE_ATLAS.toUpperCase();

const COMP_PRIO_PROJECTION = exports.COMP_PRIO_PROJECTION = 1000;
const COMP_PRIO_BLEND_BEFORE = exports.COMP_PRIO_BLEND_BEFORE = 500;
const COMP_PRIO_CHILDREN = exports.COMP_PRIO_CHILDREN = 100;
const COMP_PRIO_BLEND_AFTER = exports.COMP_PRIO_BLEND_AFTER = -500;

const ATTR_ALPHA = exports.ATTR_ALPHA = 'alpha';
const ATTR_ANTIALIAS = exports.ATTR_ANTIALIAS = 'antialias';
const ATTR_BLEND_MODE = exports.ATTR_BLEND_MODE = 'blend-mode';
const ATTR_CAPACITY = exports.ATTR_CAPACITY = 'capacity';
const ATTR_CLEAR_COLOR = exports.ATTR_CLEAR_COLOR = 'clear-color';
const ATTR_DEPTH = exports.ATTR_DEPTH = 'depth';
const ATTR_DESCRIPTOR = exports.ATTR_DESCRIPTOR = 'descriptor';
const ATTR_FLIP_Y = exports.ATTR_FLIP_Y = 'flip-y';
const ATTR_FRAGMENT_SHADER = exports.ATTR_FRAGMENT_SHADER = 'fragment-shader';
const ATTR_MODULE_SRC = exports.ATTR_MODULE_SRC = 'module-src';
const ATTR_NEAREST = exports.ATTR_NEAREST = 'nearest';
const ATTR_PREMULTIPLIED_ALPHA = exports.ATTR_PREMULTIPLIED_ALPHA = 'premultiplied-alpha';
const ATTR_PREMULTIPLY_ALPHA = exports.ATTR_PREMULTIPLY_ALPHA = 'premultiply-alpha';
const ATTR_PRESERVE_DRAW = exports.ATTR_PRESERVE_DRAW = 'preserve-drawing-buffer';
const ATTR_PRIMITIVE = exports.ATTR_PRIMITIVE = 'primitive';
const ATTR_PROJECTION = exports.ATTR_PROJECTION = 'projection';
const ATTR_REPEATABLE = exports.ATTR_REPEATABLE = 'repeatable';
const ATTR_SRC = exports.ATTR_SRC = 'src';
const ATTR_STENCIL = exports.ATTR_STENCIL = 'stencil';
const ATTR_TEXTURE_MAP = exports.ATTR_TEXTURE_MAP = 'texture-map';
const ATTR_VERTEX_SHADER = exports.ATTR_VERTEX_SHADER = 'vertex-shader';
const ATTR_VO_NEW = exports.ATTR_VO_NEW = 'vo-new';
const ATTR_VO_ZERO = exports.ATTR_VO_ZERO = 'vo-zero';

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasMap = canUseMap();
var hasSymbol = canUseSymbol();
var hasConsole = typeof console !== 'undefined';

var warn = hasConsole ? console[console.warn ? 'warn' : 'log'].bind(console) : function () {};

var PROP_NAMESPACE  = !hasSymbol ? '@@eventize' : (function () {
    if (!Symbol.eventize) {
        Symbol.eventize = Symbol('eventize');
    }
    return Symbol.eventize;
})();

var CATCH_ALL_EVENT = '*';
var LOG_NAMESPACE   = '[eventize.js]';

// =====================================================================
//
// eventize( object )
//
// =====================================================================

function eventize (o) {

    if (o[PROP_NAMESPACE]) return o;

    var _e = {
        lastCallbackId : 0,
        callbacks      : {},
        boundObjects   : []
    };

    _e.callbacks[CATCH_ALL_EVENT] = [];

    var _ePublic = definePublicPropertiesRO({}, {
        silenced : false,
        off      : []
    });

    defineHiddenPropertyRO(o, PROP_NAMESPACE, _ePublic);

    if (eventize.PRIO_DEFAULT === undefined) {

        definePublicPropertiesRO(eventize, {
            PRIO_MAX     : Number.POSITIVE_INFINITY,
            PRIO_A       : 1000000000,
            PRIO_B       : 10000000,
            PRIO_C       : 100000,
            PRIO_DEFAULT : 0,
            PRIO_LOW     : -100000,
            PRIO_MIN     : Number.NEGATIVE_INFINITY
        });

    }

    // -----------------------------------------------------------------
    //
    // object.on( eventName, [ prio, ] callbackFunc )
    // object.on( eventName, [ prio, ] obj )
    //
    // object.on( callbackFunc )    => object.on( '*', callbackFunc )
    // object.on( obj )             => object.on( '*', obj )
    //
    // object.on( eventName )
    // object.on()
    //
    // -----------------------------------------------------------------

    o.on = function (eventName, prio, fn) {  // --- {{{

        var argsLen = arguments.length;

        if (argsLen === 0) {
            if (_ePublic.silenced) {
                definePublicPropertyRO(_ePublic, 'silenced', false);
                _ePublic.off.length = 0;
            }
            return;
        }

        var i;

        if (argsLen === 1) {
            if (typeof eventName === 'string') {

                i = _ePublic.off.indexOf(eventName);
                if (i >= 0) {
                    _ePublic.off.splice(i, 1);
                }
                return;

            } else if (typeof eventName === 'object' || typeof eventName === 'function') {

                // alias for: on('*', listener)

                fn = eventName;
                eventName = CATCH_ALL_EVENT;
                prio = eventize.PRIO_DEFAULT;

            } else {
                if (hasConsole) {
                    warn(LOG_NAMESPACE, '.on() called with insufficient arguments!', arguments);
                }
                return;
            }
        }

        if (argsLen === 2) {
            fn = prio;
            prio = eventize.PRIO_DEFAULT;
        }

        var eventizeCallbacks = _e.callbacks;
        var eventListener = eventizeCallbacks[eventName] || (eventizeCallbacks[eventName] = []);
        var listenerId = createId();
        var listener = definePublicPropertiesRO({}, {
            id         : listenerId,
            fn         : fn,
            prio       : (typeof prio !== 'number' ? eventize.PRIO_DEFAULT : prio),
            isFunction : (typeof fn === 'function'),
        });

        eventListener.push(listener);
        eventListener.sort(sortListenerByPrio);

        return listenerId;

    };

    function createId () {
        return ++_e.lastCallbackId;
    }

    function sortListenerByPrio (a, b) {
        return a.prio !== b.prio ? b.prio - a.prio : a.id - b.id;
    }

    // --- on }}}

    // ----------------------------------------------------------------------
    //
    // object.once( eventName, [ prio, ] callbackFunc )
    // object.once( eventName, [ prio, ] obj )
    //
    // object.once( callbackFunc )      => object.once( '*', callbackFunc )
    // object.once( obj )               => object.once( '*', obj )
    //
    // ----------------------------------------------------------------------

    o.once = function (eventName, prio, fn) {  // --- {{{

        var argsLen = arguments.length;

        if (!argsLen || argsLen > 3) {
            if (hasConsole) {
                warn(LOG_NAMESPACE, '.once() called with insufficient arguments!', arguments);
            }
            return;
        }

        if (argsLen === 1) {

            fn = eventName;
            eventName = CATCH_ALL_EVENT;
            prio = eventize.PRIO_DEFAULT;

        } else if (argsLen === 2) {

            fn = prio;
            prio = eventize.PRIO_DEFAULT;

        }

        var id = o.on(eventName, prio, function () {
            var res = fn.apply(this, arguments);
            o.off(id);
            return res;
        });

        return id;

    };

    // --- once }}}

    // -----------------------------------------------------------------
    //
    // object.off( id )
    // object.off( callback )
    // object.off( obj )
    // object.off( eventName )
    // object.off()
    //
    // deactive listener by id or previously bound object or
    // function reference or event name or silence all events
    //
    // -----------------------------------------------------------------

    o.off = function (id) {  // -- {{{

        if (arguments.length === 0) {
            if (!_ePublic.silenced) {
                definePublicPropertyRO(_ePublic, 'silenced', true);
                _ePublic.off.length = 0;
            }
            return;
        }

        if (typeof id === 'string') {
            //
            // by event name
            //
            if (_ePublic.off.indexOf(id) === -1) {
                _ePublic.off.push(id);
            }
            return;
        }

        var eventizeCallbacks = _e.callbacks;
        var cb, i, j, _callbacks, keys;
        var isObject = typeof id === 'object';

        if (typeof id === 'number' || typeof id === 'function' || isObject) {
            //
            // by id or function reference
            //
            keys = Object.keys(eventizeCallbacks);
            for (j = 0; j < keys.length; j++) {
                _callbacks = eventizeCallbacks[keys[j]];
                for (i = 0; i < _callbacks.length; i++) {
                    cb = _callbacks[i];
                    if (cb.id === id || cb.fn === id) {
                        _callbacks.splice(i, 1);
                        if (!isObject) return;
                    }
                }
            }
        }

        if (isObject) {
            //
            // by bound object reference
            //
            i = _e.boundObjects.indexOf(id);
            if ( i >= 0 ) {
                _e.boundObjects.splice(i, 1);
            }
        }

    };

    // --- off }}}

    // -----------------------------------------------------------------
    //
    // object.connect( obj, mapping )
    //
    // Example:
    //
    //   object.connect(options, {
    //        onProjectionUpdated : [100, 'projectionUpdated'],
    //        onFrame             : 'frame',
    //        onFrameEnd          : 'frameEnd'
    //   })
    //
    // -----------------------------------------------------------------

    o.connect = function (obj, mapping) {  // --- {{{
        var argsLen = arguments.length;
        if (argsLen === 2) {
            return _connectWithMapping(this, obj, mapping);
        } else {
            if (hasConsole) {
                warn(LOG_NAMESPACE, '.connect() called with insufficient arguments (need 2 args, but got ' + argsLen + ')', arguments);
            }
        }
    };

    function _bindObject (obj) {

        // TODO connect(obj) should ..
        // - support priority
        // - support filters? (via only, except options)
        // - support senderContextArgument?: 'prepend'|'append'|false

        if (!obj) return;
        var i = _e.boundObjects.indexOf(obj);
        if (i === -1) {
            _e.boundObjects.push(obj);
        }
        return obj;

    }

    function _connectWithMapping (obj, options, listenerMap) {

        var eventName, listenName, listenFunc, prio;

        for (listenName in listenerMap) {
            if (listenerMap.hasOwnProperty(listenName)) {
                listenFunc = options[listenName];
                if (typeof listenFunc === 'function') {
                    eventName = listenerMap[listenName];
                    if (Array.isArray(eventName)) {
                        prio = eventName[0];
                        eventName = eventName[1];
                    } else {
                        prio = eventize.PRIO_DEFAULT;
                    }
                    obj.on(eventName, prio, listenFunc);
                }
            }
        }

        return obj;

    }

    // --- connect }}}

    // -----------------------------------------------------------------
    //
    // object.emit( eventName [, arguments .. ] )
    //
    // -----------------------------------------------------------------

    o.emit = function () {  // --- {{{

        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var argsWithEventName = new Array(arguments.length);
        for (var i = 0; i < argsWithEventName.length; ++i) {
            argsWithEventName[i] = arguments[i];
        }

        var eventName = argsWithEventName[0];
        var argsWithoutEventName = argsWithEventName.slice(1);
        var senderCtx = this;

        _dispatch(eventName, function (listener) {

            if (listener.isFunction) {
                listener.fn.apply(senderCtx, argsWithoutEventName);
            } else {
                var fn = listener.fn[eventName];
                if (typeof fn === 'function') {
                    fn.apply(listener.fn, argsWithoutEventName);
                } else if (listener.fn.emit) {
                    listener.fn.emit.apply(listener.fn, argsWithEventName);
                }
            }

        }, function (fn, boundObj) {

            if (fn) {
                fn.apply(boundObj, argsWithoutEventName);
            } else if (boundObj.emit) {
                boundObj.emit.apply(boundObj, argsWithEventName);
            }

        });

    }

    function _dispatch (eventName, emitListener, emitBoundObject) {

        if (_ePublic.silenced) return;
        if (_ePublic.off.indexOf(eventName) >= 0) return;

        var listeners              = _e.callbacks[eventName];
        var catchAllListeners      = _e.callbacks[CATCH_ALL_EVENT];
        var boundObjsCount         = _e.boundObjects.length;
        var hasBoundObjectsEmitted = false;

        function _emitBoundObjects () {
            var j, bo, fn;
            if (boundObjsCount) {
                for (j = 0; j < boundObjsCount; j++) {
                    bo = _e.boundObjects[j];
                    fn = bo[eventName];
                    if (typeof fn === 'function') {
                        emitBoundObject(fn, bo);
                    } else if (bo[PROP_NAMESPACE]) {
                        emitBoundObject(null, bo);
                    }
                }
            }
        }

        var i, len, listen;

        if (listeners || catchAllListeners.length) {

            listeners = listeners ? listeners.concat(catchAllListeners) : catchAllListeners;
            len = listeners.length;

            for (i = 0; i < len; i++) {
                listen = listeners[i];
                if (!hasBoundObjectsEmitted && listen && listen.prio < eventize.PRIO_DEFAULT) {
                    _emitBoundObjects();
                    hasBoundObjectsEmitted = true;
                }
                emitListener(listen);
            }
        }

        if (!hasBoundObjectsEmitted) _emitBoundObjects();

    }

    // --- emit }}}

    // --------------------------------------------------------------------
    //
    // object.emitReduce( eventName [, value= {} ] [, arguments .. ] )
    //
    // --------------------------------------------------------------------

    o.emitReduce = function () {  // --- {{{

        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i) {
            args[i] = arguments[i];
        }

        var eventName = args.shift();
        var value;

        function setValue (val) {
            if (val !== undefined) {
                value = val;
            }
        }

        if (args.length === 0) {
            value = {};
            args.push(value);
        } else {
            setValue(args[0]);
        }

        var ctx = this;
        var argsWithEventName = [eventName].concat(args);

        _dispatch(eventName, function (listener) {

            if (listener.isFunction) {
                args[0] = value;
                setValue(listener.fn.apply(ctx, args));
            } else {
                var fn = listener.fn[eventName];
                if (typeof fn === 'function') {
                    args[0] = value;
                    setValue(fn.apply(listener.fn, args));
                } else if (listener.fn.emitReduce) {
                    argsWithEventName[1] = value;
                    setValue(listener.fn.emitReduce.apply(listener.fn, argsWithEventName));
                }
            }

        }, function (fn, boundObj) {

            if (fn) {
                args[0] = value;
                setValue(fn.apply(boundObj, args));
            }

        });

        return value;

    };

    // --- emit }}}

    // --------------------------------------------------------------------
    //
    // object.from( eventName, Observable )
    //
    // See https://github.com/tc39/proposal-observable
    //
    // Example:
    //
    //      object
    //          .from('foo', Rx.Observable)
    //          .filter(x => x % 2 === 0)
    //          .subscribe(x => console.log(x));
    //
    //
    // --------------------------------------------------------------------

    o.from = function (eventName, observable) {  // --- {{{
        var self = this;
        return new observable(function (observer) {

            var id = self.on(eventName, function (data) {
                observer.next(data);
            });

            return function () {
                self.off(id);
            };

        });
    };

    // --- from }}}

    // --------------------------------------------------------------------
    //
    // object.subscribe( Observable, onNext[, onError][, onComplete] )
    //
    // Example:
    //
    //      object.subscribe(a, 'value', 'error');   // a => Observable
    //
    // --------------------------------------------------------------------

    o.subscribe = function (source, onNext, onError, onComplete) {  // --- {{{
        var self = this;
        return source.subscribe(function (value) {
            self.emit(onNext, value);
        }, onError ? function (errorValue) {
            self.emit(onError, errorValue);
        } : undefined, onComplete ? function (completeValue) {
            self.emit(onComplete, completeValue);
        } : undefined);
    };

    // --- subscribe }}}

    return o;

} // <= eventize()


eventize.is = function (obj) {
    return !!( obj && obj[PROP_NAMESPACE] );
};


defineHiddenPropertyRO( eventize,
    'EventizeNamespace', PROP_NAMESPACE);


// ==========================================================================
//
// eventize.queue([ queueId ][, options]) : queue
//
// options are:
//    - replace: true|false  - replace previous events with same name
//                             when queue is in collection mode
//
// queue.play()              - activate play (immediately emit) mode
// queue.collect()           - activate collection (store all events) mode
// queue.toggle()            - toggle state
// queue.state               - 'play'|'collect'
//
// ==========================================================================

defineHiddenPropertyRO(eventize, 'queues', hasMap ? new Map : {});

eventize.queue = function (id/*, options */) {

    var queue, options;
    var len = arguments.length;

    if (len >= 1) {
        if (typeof id !== 'object' || len === 2) {
            queue = hasMap ? eventize.queues.get(id) : eventize.queues[id];
        }
        if (len === 2) {
            options = arguments[1];
        } else if (len === 1 && typeof id === 'object') {
            options = id;
        }
    }

    if (!queue) {
        queue = createQueue(id, options);
        if (hasMap) {
            eventize.queues.set(queue.id, queue);
        } else {
            eventize.queues[queue.id] = queue;
        }
    }

    return queue;

};


var STATE = 'state';
var PLAY = 'play';
var COLLECT = 'collect';

function createQueue (id, options) {

    var queueId = ((typeof id === 'string' || typeof id === 'symbol') && id) || createUuid();
    var queue = eventize({});
    var isReplace = !!(options && options.replace);

    var setState = function (state) {
        definePublicPropertyRO(queue, STATE, state);
    };

    var emit = (function (_emit) {
            return function (args) {
            _emit.apply(queue, args);
        };
    })(queue.emit);

    defineHiddenPropertyRO(queue, 'events', []);
    definePublicPropertyRO(queue, 'id', queueId);

    queue.collect = function () {
        if (queue[STATE] !== COLLECT) {
            setState(COLLECT);
        }
        return queue;
    };

    queue.emit = function () {
        var args = new Array(arguments.length);
        var i;
        for (i = 0; i < args.length; ++i) {
            args[i] = arguments[i];
        }
        if (queue[STATE] === PLAY) {
            emit(args);
        } else {  // COLLECT
            if (isReplace) {
                var len, eventName = args[0];
                for (i = 0, len = queue.events.length; i < len; i++) {
                    if (queue.events[i][0] === eventName) {
                        queue.events[i] = args;
                        return;
                    }
                }
            }
            queue.events.push(args);
        }
    };

    queue.play = function () {
        if (queue[STATE] !== PLAY) {
            setState(PLAY);
            queue.events.forEach(emit);
            queue.events.length = 0;
        }
        return queue;
    };

    queue.toggle = function () {
        return queue[STATE] !== PLAY ? queue.play() : queue.collect();
    };

    return queue.play();

}


// =====================================================================
//
// helper functions
//
// =====================================================================


function createUuid () {
    // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });
    return hasSymbol ? Symbol(uuid) : uuid;
}

function canUseSymbol () {
    return typeof Symbol !== 'undefined';
}

function canUseMap () {
    return typeof Map !== 'undefined';
}

function definePublicPropertyRO (obj, name, value) {
    Object.defineProperty(obj, name, {
        value        : value,
        configurable : true,
        enumerable   : true
    });
    return obj;
}

function definePublicPropertiesRO (obj, attrs) {
    var i, keys = Object.keys(attrs);
    for (i = keys.length; i--;) {
        definePublicPropertyRO(obj, keys[i], attrs[keys[i]]);
    }
    return obj;
}

function defineHiddenPropertyRO (obj, name, value) {
    Object.defineProperty(obj, name, {
        value        : value,
        configurable : true
    });
    return obj;
}


// --- end
//
module.exports = eventize;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (obj) {
  if (typeof obj !== 'object') return;
  if (obj.destroyed) return;

  if (eventize.is(obj) && typeof obj.off === 'function') {
    // TODO eventize.destroy(obj)
    obj.off();
  }

  Object.keys(obj).forEach(key => {
    delete obj[key];
  });

  Object.defineProperty(obj, 'destroyed', { value: true });
};

const eventize = __webpack_require__(1);

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

// https://github.com/kelektiv/node-uuid
/** @private */
const uuid = __webpack_require__(76);

exports.default = uuid;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Generic container for shader variables. eg. uniform, vertex attributes, textures ..
 * @desc
 * Each time you change the value, a serial number will be increased.
 * Use `.touch()` if you want to increase the serial number without changing the value.
 */
class ShaderVariable {
  /**
   * @param {string} name
   * @param {string} type
   * @param {number|Object} value
   */
  constructor(name, type, value) {
    this.name = name;
    this.type = type;
    this._value = value;

    /**
     * The serial number increases each time you change the value.
     * @type {number}
     */
    this.serial = 0;
  }

  get value() {
    return this._value;
  }

  set value(val) {
    if (this._value !== val) {
      this._value = val;
      ++this.serial;
    }
  }

  /**
   * Increase serial number.
   */
  touch() {
    ++this.serial;
  }
}

exports.default = ShaderVariable;
ShaderVariable.TYPE = Object.freeze({
  UNIFORM: 'uniform',
  ATTRIB: 'attrib',
  TEXTURE_2D: 'tex2d'
});

/***/ }),
/* 6 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _resource_ref = __webpack_require__(8);

var _resource_ref2 = _interopRequireDefault(_resource_ref);

var _typed_array_helpers = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Vertex Object Array
 *
 * @class VOArray
 *
 * @param {VODescriptor} descriptor - *Vertex object* descriptor
 * @param {number} capacity - Maximum number of *vertex objects*
 * @param {?ArrayBuffer|DataView|Float32Array} data
 * @param {string} [usage=VOArray.USAGE.DYNAMIC] usage hint
 * @param {boolean} [autotouch] autotouch
 *
 * @desc
 * An array of *vertex objects*.
 * Has a maximum capacity and a reference to the *vertex object descriptor*.
 *
 */

class VOArray {
  constructor(descriptor, capacity, data, usage = VOArray.USAGE.DYNAMIC, autotouch = undefined) {
    /** @type {ResourceRef} */
    this.resourceRef = new _resource_ref2.default(this, { usage });

    /** @type {VODescriptor} */
    this.descriptor = descriptor;
    /** @type {number} */
    this.capacity = capacity;

    if (data instanceof ArrayBuffer) {
      this.float32Array = new Float32Array(data);
    } else if (data instanceof DataView) {
      this.float32Array = new Float32Array(data.buffer, data.byteOffset, data.byteLength / 4);
    } else if (data instanceof Float32Array) {
      this.float32Array = data;
    } else {
      this.float32Array = new Float32Array(new ArrayBuffer(capacity * descriptor.bytesPerVO));
    }

    // needed by WebGlRenderer#syncBuffer
    this.resourceRef.hints.typedArray = this.float32Array;

    const { buffer, bufferByteOffset, bufferByteLength } = this;
    descriptor.typeList.filter(type => type !== 'float32').forEach(type => {
      this[`${type}Array`] = new _typed_array_helpers.TYPED_ARRAY_CONSTRUCTOR[type](buffer, bufferByteOffset, bufferByteLength / _typed_array_helpers.BYTES_PER_ELEMENT[type]);
    });

    /** @type {boolean} */
    this.enableAutotouch = typeof autotouch === 'boolean' ? autotouch : usage === VOArray.USAGE.DYNAMIC;

    Object.freeze(this);
  }

  /**
   * increase serial value from resource reference
   */
  touch() {
    this.resourceRef.serial.touch();
  }

  /** @type {ArrayBuffer} */
  get buffer() {
    return this.float32Array.buffer;
  }

  /** @type {number} */
  get bufferByteOffset() {
    return this.float32Array.byteOffset;
  }

  /** @type {number} */
  get bufferByteLength() {
    return this.float32Array.byteLength;
  }

  /**
   * Copy **all** *vertex object* data from an external vertex array to the internal array
   * @param {VOArray} fromVOArray - The source vertex array
   * @param {number} [toOffset=0] - *Vertex object* offset for the internal vertex array
   */
  copy(fromVOArray, toOffset) {
    let offset = 0;

    if (toOffset === undefined) {
      offset = toOffset * (this.descriptor.bytesPerVO >> 2);
    }

    this.float32Array.set(fromVOArray.float32Array, offset);
  }

  /**
   * Create a VOArray *sub* array
   * @desc
   * This will **not** *copy* the internal vertex data - this will create a new view into the internal buffer.
   * Both (the new VOArray and the current one) will share the
   * same memory buffer.
   *
   * @param {number} begin - Index of first vertex object
   * @param {number} [size=1]
   * @return {VOArray}
   */
  subarray(begin, size = 1) {
    return new VOArray(this.descriptor, size, new DataView(this.buffer, this.bufferByteOffset + begin * this.descriptor.bytesPerVO, size * this.descriptor.bytesPerVO));
  }
}

exports.default = VOArray;
VOArray.USAGE = Object.freeze({
  STATIC: 'static',
  DYNAMIC: 'dynamic'
});

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _generate_uuid = __webpack_require__(4);

var _generate_uuid2 = _interopRequireDefault(_generate_uuid);

var _serial = __webpack_require__(80);

var _serial2 = _interopRequireDefault(_serial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents a resource reference which points to a *renderable resource*.
 * Every resource has an id, serial and possible resource allocation *hints*.
 * The resource reference will be used by the resource library to find or
 * create *renderable resources* (like WebGlBuffer, WebGlTexture, ..).
 */
class ResourceRef {
  constructor(resource, hints = {}) {
    this.resource = resource;
    this.hints = hints;
    this.id = hints.id || (0, _generate_uuid2.default)();
    this.serial = new _serial2.default(typeof hints.serial === 'number' ? hints.serial : 1);
  }

  /**
   * @param {ResourceRef} sourceRef
   * @returns {boolean}
   */
  isSynced(sourceRef) {
    const { value } = this.serial;
    return value > 0 && value === sourceRef.serial.value;
  }

  /**
   * @param {ResourceRef} sourceRef
   * @returns {boolean}
   */
  needSync(sourceRef) {
    return !this.isSynced(sourceRef);
  }

  /**
   * @param {ResourceRef} sourceRef
   * @param {function} cb
   */
  sync(sourceRef, cb) {
    if (this.needSync(sourceRef)) {
      cb(this.resource);
      this.serial.value = sourceRef.serial.value;
    }
  }
}
exports.default = ResourceRef;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

/** @private */
const BYTES_PER_ELEMENT = Object.freeze({
  float32: 4,
  int16: 2,
  int32: 4,
  int8: 1,
  uint16: 2,
  uint32: 4,
  uint8: 1
});

/** @private */
const TYPED_ARRAY_CONSTRUCTOR = Object.freeze({
  float32: Float32Array,
  int16: Int16Array,
  int32: Int32Array,
  int8: Int8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  uint8: Uint8Array
});

/** @private */
const TYPED_ARRAY_GETTER = Object.freeze({
  float32: obj => obj.float32Array,
  int32: obj => obj.int32Array,
  int16: obj => obj.int16Array,
  int8: obj => obj.int8Array,
  uint32: obj => obj.uint32Array,
  uint16: obj => obj.uint16Array,
  uint8: obj => obj.uint8Array
});

/** @private */
const GL_ITEM_TYPES = Object.freeze({
  float32: 'FLOAT',
  int16: 'SHORT',
  int32: 'INT',
  int8: 'BYTE',
  uint16: 'UNSIGNED_SHORT',
  uint32: 'UNSIGNED_INT',
  uint8: 'UNSIGNED_BYTE'
});

exports.BYTES_PER_ELEMENT = BYTES_PER_ELEMENT;
exports.TYPED_ARRAY_CONSTRUCTOR = TYPED_ARRAY_CONSTRUCTOR;
exports.TYPED_ARRAY_GETTER = TYPED_ARRAY_GETTER;
exports.GL_ITEM_TYPES = GL_ITEM_TYPES;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typed_array_helpers = __webpack_require__(9);

/**
 * Vertex object *attribute* descriptor.
 */
class VOAttrDescriptor {
  /**
   * @param {string} name
   * @param {string} type
   * @param {number} size
   * @param {number} [offset] - either `offset` or `byteOffset` must be specified
   * @param {number} [byteOffset] - either `offset` or `byteOffset` must be specified
   * @param {boolean} uniform
   * @param {string[]} [attrNames]
   */
  constructor(name, type, size, offset, byteOffset, uniform, attrNames) {
    this.name = name;
    this.type = type;
    this.size = size;
    this.uniform = uniform;
    this.attrNames = attrNames;

    this.bytesPerElement = _typed_array_helpers.BYTES_PER_ELEMENT[this.type];
    this.bytesPerVertex = this.bytesPerElement * size;

    if (typeof byteOffset !== 'number') {
      this.byteOffset = offset * this.bytesPerElement;
    } else {
      this.byteOffset = byteOffset;
    }

    if (typeof offset !== 'number') {
      this.offset = byteOffset / this.bytesPerElement;
    } else {
      this.offset = offset;
    }
  }

  /**
   * Number of attributes per vertex
   * @type {number}
   */
  vertexAttrCount(descriptor) {
    return descriptor.bytesPerVertex / this.bytesPerElement;
  }

  /**
   * @private
   */
  static defineProperties(attrDesc, propertiesObject, descriptor) {
    const { name } = attrDesc;
    const getArray = _typed_array_helpers.TYPED_ARRAY_GETTER[attrDesc.type];
    const vertexCount = descriptor.vertexCount;
    const vertexAttrCount = attrDesc.vertexAttrCount(descriptor);
    const offset = attrDesc.byteOffset / attrDesc.bytesPerElement;

    let i, j;

    if (attrDesc.size === 1) {
      if (attrDesc.uniform) {
        const valueGetter = getV1u(getArray, offset);
        const valueSetter = setV1u(getArray, vertexCount, vertexAttrCount, offset);

        attrDesc.getValue = vo => valueGetter.call(vo);
        attrDesc.setValue = (vo, arg) => valueSetter.call(vo, arg);

        propertiesObject[name] = {
          get: valueGetter,
          set: valueSetter,
          enumerable: true
        };
      } else {
        const valueSetter = setVNv(getArray, 1, vertexCount, vertexAttrCount, offset);

        attrDesc.setValue = (vo, args) => valueSetter.apply(vo, args);

        propertiesObject['set' + camelize(name)] = {
          value: valueSetter,
          enumerable: true
        };

        const valueGetters = [];

        for (i = 0; i < descriptor.vertexCount; ++i) {
          const curValueGetter = getV1u(getArray, offset + i * vertexAttrCount);

          valueGetters.push(curValueGetter);

          propertiesObject[name + i] = {

            get: curValueGetter,
            set: setVNv(getArray, 1, 1, 0, offset + i * vertexAttrCount),
            enumerable: true

          };
        }

        attrDesc.getValue = function (vo, vi) {
          return valueGetters[vi].call(vo);
        };
      }
    } else if (attrDesc.size >= 2) {
      if (attrDesc.uniform) {
        const valueGetter = getVNu(getArray, offset);
        const valueSetter = setVNu(getArray, attrDesc.size, vertexCount, vertexAttrCount, offset);

        attrDesc.getValue = (vo, vi, idx) => valueGetter.call(vo, idx);
        attrDesc.setValue = (vo, args) => valueSetter.apply(vo, args);

        propertiesObject['get' + camelize(name)] = {
          value: valueGetter,
          enumerable: true
        };

        propertiesObject['set' + camelize(name)] = {
          value: valueSetter,
          enumerable: true
        };

        for (i = 0; i < attrDesc.size; ++i) {
          const setterName = attrPostfix(attrDesc, name, i);

          propertiesObject[setterName] = {

            get: getV1u(getArray, offset + i),
            set: setV1u(getArray, vertexCount, vertexAttrCount, offset + i),
            enumerable: true

          };
        }
      } else {
        const valueSetter = setVNv(getArray, attrDesc.size, vertexCount, vertexAttrCount, offset);

        attrDesc.setValue = (vo, args) => valueSetter.apply(vo, args);

        propertiesObject['set' + camelize(name)] = {
          value: valueSetter,
          enumerable: true
        };

        const valueGetters = [];

        for (i = 0; i < descriptor.vertexCount; ++i) {
          const curVertexValueGetters = [];

          for (j = 0; j < attrDesc.size; ++j) {
            const setterName = attrPostfix(attrDesc, name, j) + i;
            const curValueGetter = getV1u(getArray, offset + i * vertexAttrCount + j);

            curVertexValueGetters.push(curValueGetter);

            propertiesObject[setterName] = {

              get: curValueGetter,
              set: setVNv(getArray, 1, 1, 0, offset + i * vertexAttrCount + j),
              enumerable: true

            };
          }

          valueGetters.push(curVertexValueGetters);
        }

        attrDesc.getValue = function (vo, vi, idx) {
          return valueGetters[vi][idx].call(vo);
        };
      }
    }
  }
}

exports.default = VOAttrDescriptor; /** @private */

function attrPostfix(attrDesc, name, index) {
  if (attrDesc.attrNames) {
    let postfix = attrDesc.attrNames[index];

    if (postfix !== undefined) {
      return postfix;
    }
  }

  return name + '_' + index;
}

/** @private */
function getVNu(getArray, offset) {
  return function (attrIndex) {
    return getArray(this.voArray)[offset + attrIndex];
  };
}

/** @private */
function setVNu(getArray, vectorLength, vertexCount, vertexAttrCount, offset) {
  return function () {
    const _array = getArray(this.voArray);
    let i;
    let n;

    for (i = 0; i < vertexCount; ++i) {
      for (n = 0; n < vectorLength; ++n) {
        _array[i * vertexAttrCount + offset + n] = arguments[n];
      }
    }
  };
}

/** @private */
function getV1u(getArray, offset) {
  return function () {
    return getArray(this.voArray)[offset];
  };
}

/** @private */
function setVNv(getArray, vectorLength, vertexCount, vertexAttrCount, offset) {
  return function () {
    const _array = getArray(this.voArray);
    let i;
    let n;

    for (i = 0; i < vertexCount; ++i) {
      for (n = 0; n < vectorLength; ++n) {
        _array[i * vertexAttrCount + offset + n] = arguments[i * vectorLength + n];
      }
    }
  };
}

/** @private */
function setV1u(getArray, vertexCount, vertexAttrCount, offset) {
  return function (value) {
    const _array = getArray(this.voArray);

    for (let i = 0; i < vertexCount; ++i) {
      _array[i * vertexAttrCount + offset] = value;
    }
  };
}

/** @private */
function camelize(name) {
  return name[0].toUpperCase() + name.substr(1);
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _power_of_2_image = __webpack_require__(20);

var _power_of_2_image2 = _interopRequireDefault(_power_of_2_image);

var _resource_ref = __webpack_require__(8);

var _resource_ref2 = _interopRequireDefault(_resource_ref);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getOption = (options, key, defaultValue) => options != null ? options[key] !== undefined ? options[key] : defaultValue : defaultValue;

/**
 * Represents texture coordinates and holds a reference to a `<img>` or `<canvas>` element.
 * Textures can form hierachical structures.
 * The *root* texture contains always the image reference, all other *sub* textures contain
 * references to their parent (and the root).
 *
 * @class Texture
 *
 * @example
 * const canvas = document.createElement("canvas")
 * const texture = new Texture(canvas)
 * texture.width    // => 300 <- default size of <canvas> element
 * texture.height   // => 150
 *
 * let subTex = new Texture(texture, 30, 15, 100, 100)
 * subTex.width    // => 100
 *
 * Texture.load('test/assets/bird-chicken-penguin.png').then(tex => {
 *   tex.width    // => 640
 *   tex.height   // => 480
 * })
 */

class Texture {
  /**
   * @param {Texture|PowerOf2Image|HTMLImageElement|HTMLCanvasElement} source - image elements must be *completed* (loaded)
   * @param {number} [width]
   * @param {number} [height]
   * @param {number} [x=0]
   * @param {number} [y=0]
   * @param {Object} [hints] texture hints
   * @param {boolean} [hints.flipY=false]
   * @param {boolean} [hints.repeatable=false]
   * @param {boolean} [hints.premultiplyAlpha=true]
   */
  constructor(source, width, height, x = 0, y = 0, hints = undefined) {
    if (source instanceof Texture) {
      /**
       * @type {Texture}
       */
      this.parent = source;
      /**
       * @type {PowerOf2Image|HTMLImageElement|HTMLCanvasElement}
       */
      this.image = null;
    } else if (typeof source === 'object' && 'width' in source && 'height' in source) {
      this.image = source;
      this.parent = null;

      this._resourceRef = new _resource_ref2.default(this, {
        flipY: getOption(hints, 'flipY', false),
        repeatable: getOption(hints, 'repeatable', false),
        premultiplyAlpha: getOption(hints, 'premultiplyAlpha', true),
        nearest: getOption(hints, 'nearest', false)
      });

      if ('origWidth' in source && 'origHeight' in source) {
        width = source.origWidth;
        height = source.origHeight;
      }
    } else {
      throw new Error('new Texture() panic: unexpected source argument!');
    }

    this._width = width;
    this._height = height;

    /**
     * @type {number}
     */
    this.x = x;
    /**
     * @type {number}
     */
    this.y = y;
  }

  /**
   * @type {Texture}
   */
  get root() {
    return this.parent && this.parent.root || this;
  }

  /**
   * @type {HTMLImageElement|HTMLCanvasElement}
   */
  get imgEl() {
    const { root } = this;
    return root.image.imgEl || root.image;
  }

  /**
   * @type {ResourceRef}
   */
  get resourceRef() {
    return this._resourceRef || this.root.resourceRef;
  }

  /**
   * @type {number}
   */
  get width() {
    return typeof this._width === 'number' ? this._width : this.image ? this.image.width : this.parent ? this.root.width : 0;
  }

  set width(w) {
    this._width = w;
  }

  /**
   * @type {number}
   */
  get height() {
    return typeof this._height === 'number' ? this._height : this.image ? this.image.height : this.parent ? this.root.height : 0;
  }

  set height(h) {
    this._height = h;
  }

  /**
   * @type {number}
   */
  get minS() {
    let x = this.x;
    let texture = this;

    while ((texture = texture.parent) != null) {
      x += texture.x;
    }

    return x / this.root.image.width;
  }

  /**
   * @type {number}
   */
  get minT() {
    let y = this.y;
    let texture = this;

    while ((texture = texture.parent) != null) {
      y += texture.y;
    }

    return y / this.root.image.height;
  }

  /**
   * @type {number}
   */
  get maxS() {
    let x = this.x + this.width;
    let texture = this;

    while ((texture = texture.parent) != null) {
      x += texture.x;
    }

    return x / this.root.image.width;
  }

  /**
   * @type {number}
   */
  get maxT() {
    let y = this.y + this.height;
    let texture = this;

    while ((texture = texture.parent) != null) {
      y += texture.y;
    }

    return y / this.root.image.height;
  }

  /**
    * Loads an image from url and returns a texture.
    * @param {string} url
    * @param {object} [textureHints]
    * @returns {Promise<Texture>}
    */
  static load(url, textureHints) {
    return new _power_of_2_image2.default(url).complete.then(p2img => new Texture(p2img, undefined, undefined, 0, 0, textureHints));
  }
}
exports.default = Texture;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

/**
 * Group of shader variables.
 */
class ShaderVariableGroup {
  /**
  * @param {Array<ShaderVariable|ShaderVariableAlias>} shaderVars
   */
  constructor(shaderVars) {
    this.shaderVars = shaderVars;
  }

  pushVar(shaderContext) {
    this.shaderVars.forEach(shaderContext.pushVar.bind(shaderContext));
  }

  popVar(shaderContext) {
    this.shaderVars.forEach(shaderContext.popVar.bind(shaderContext));
  }
}
exports.default = ShaderVariableGroup;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint-env browser */
const reNumber = /^[-+]?(\d+\.|\.)?\d+(e\d+|e[-+]\d+)?$/;
const reUrl = /^url\(\s*([^)]+)\)$/;
const reVec2 = /^vec2\(\s*([-+\d.e]+)\s*,\s*([-+\d.e]+)\s*\)$/;
const reVec3 = /^vec3\(\s*([-+\d.e]+)\s*,\s*([-+\d.e]+)\s*,\s*([-+\d.e]+)\s*\)$/;
const reVec4 = /^vec4\(\s*([-+\d.e]+)\s*,\s*([-+\d.e]+)\s*,\s*([-+\d.e]+)\s*,\s*([-+\d.e]+)\s*\)$/;
const reFunc = /^\s*[a-zA-Z]+\(\s*[^)]+\)\s*$/;

// parseValue(str) expects a trimmed string!
//
// special transform rules:
//
//   (string)   => (type)
//   ---------------------
//   '...'      => string: ...
//   "..."      => string: ...
//   123        => number
//   123.456    => number
//   null       => object: null
//   undefined  => undefined
//   true       => boolean: true
//   false      => boolean: false
//   {...}      => JSON.parse(...)
//   [...]      => JSON.parse(...)
//   url(...)   => new URL(...)
//   vec2(<number>, <number>) => new Float32Array([number, number])
//   vec3(<number>, <number>, <number>) => new Float32Array([number, number, number])
//   vec4(<number>, <number>, <number>, <number>) => new Float32Array([...])
//
function parseValue(value) {
  const len = value.length;
  if (len >= 2 && value.startsWith('"') && value.endsWith('"')) {
    return value.substr(1, value.length - 2);
  } else if (len >= 2 && value.startsWith('{') && value.endsWith('}')) {
    return JSON.parse(value);
  } else if (len >= 2 && value.startsWith('[') && value.endsWith(']')) {
    return JSON.parse(value);
  } else if (len >= 2 && value.startsWith('\'') && value.endsWith('\'')) {
    return value.substr(1, value.length - 2);
  } else if (len > 0 && reNumber.exec(value)) {
    return parseFloat(value);
  }

  let m = reUrl.exec(value);
  if (m) return new URL(m[1].trim());

  m = reVec2.exec(value);
  if (m) return new Float32Array(m.slice(1, 3).map(parseFloat));

  m = reVec3.exec(value);
  if (m) return new Float32Array(m.slice(1, 4).map(parseFloat));

  m = reVec4.exec(value);
  if (m) return new Float32Array(m.slice(1, 5).map(parseFloat));

  switch (value) {
    case 'null':
      return null;
    case 'undefined':
      return undefined;
    case 'true':
      return true;
    case 'false':
      return false;
    default:
      return value;
  }
}

function indexOfNextNonWhitespace(str, curIdx) {
  const len = str.length;
  let i = curIdx;
  if (i >= len) return len;
  do {
    if (str[i] === ' ' || str[i] === '\t') {
      ++i;
    } else {
      return i;
    }
  } while (i < len);
  return len;
}

function indexOfNextSeperator(str, curIdx, seperator = ';') {
  const len = str.length;
  let i = curIdx;
  let isInside = null;
  do {
    if (isInside === null) {
      switch (str[i]) {
        case seperator:
          return i;
        case '\'':
          isInside = '\'';
          ++i;
          break;
        case '"':
          isInside = '"';
          ++i;
          break;
        case '(':
          isInside = ')';
          ++i;
          break;
        case '{':
          isInside = '}';
          ++i;
          break;
        case '\\':
          i += 2;
          break;
        default:
          ++i;
      }
    } else {
      if (str[i] === isInside) {
        isInside = null;
        ++i;
      } else if (str[i] === '\\') {
        i += 2;
      } else {
        ++i;
      }
    }
  } while (i < len);
  return len;
}

function splitIntoPropTokens(str) {
  if (typeof str !== 'string' || !str) return;

  const propTokens = [];
  const len = str.length;

  let i = indexOfNextNonWhitespace(str, 0);
  do {
    const to = indexOfNextSeperator(str, i, ';');
    if (to > i) {
      propTokens.push(str.slice(i, to));
    }
    i = indexOfNextNonWhitespace(str, to + 1);
  } while (i < len);

  return propTokens;
}

function splitIntoProps(str) {
  const tokens = splitIntoPropTokens(str);
  if (!tokens) return;
  return tokens.map(tok => {
    if (reFunc.exec(tok)) {
      return { value: tok.trim() };
    }
    const colon = tok.indexOf(':');
    if (colon === -1) {
      return { value: tok.trim() };
    }
    const key = tok.slice(0, colon).trim();
    const value = tok.substr(colon + 1).trim();
    return {
      key,
      value
    };
  }).filter(prop => !(prop.key === '' && prop.value === ''));
}

function parseCssStyledProperties(data) {
  if (typeof data !== 'string') return data;

  // => json
  const str = data.trim();
  if (str.startsWith('{') && str.endsWith('}')) {
    return JSON.parse(str);
  }

  const props = splitIntoProps(str);

  // => undefined
  if (!props || props.length === 0) return;

  if ('key' in props[0]) {
    // => properties
    const map = {};
    props.forEach(({ key, value }) => {
      map[key] = parseValue(value);
    });
    return map;
  } else {
    // => array of values OR single value
    const values = props.map(({ value }) => parseValue(value));
    return values.length === 1 ? values[0] : values;
  }
}

exports.default = parseCssStyledProperties;
exports.splitIntoPropTokens = splitIntoPropTokens;
exports.splitIntoProps = splitIntoProps;
exports.indexOfNextNonWhitespace = indexOfNextNonWhitespace;
exports.indexOfNextSeperator = indexOfNextSeperator;
exports.parseValue = parseValue;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(24);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(6),
    isKey = __webpack_require__(140),
    stringToPath = __webpack_require__(141),
    toString = __webpack_require__(23);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(28);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(68);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(166);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _generate_uuid = __webpack_require__(4);

var _generate_uuid2 = _interopRequireDefault(_generate_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ShaderSource {
  /**
   * @param {string} type - `VERTEX_SHADER` or `FRAGMENT_SHADER`
   * @param {HTMLElement|string} source
   */
  constructor(type, source) {
    /**
     * @type {string}
     */
    this.id = (0, _generate_uuid2.default)();

    this.type = type;

    /**
     * @type {string}
     */
    this.source = source instanceof HTMLElement ? source.textContent : source;
  }
}

exports.default = ShaderSource; /* global HTMLElement */

ShaderSource.VERTEX_SHADER = 'VERTEX_SHADER';
ShaderSource.FRAGMENT_SHADER = 'FRAGMENT_SHADER';

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _math_helpers = __webpack_require__(40);

/**
 * Represents a `<img>` or `<canvas>` element which sizes (width and height) are
 * always power of 2.
 */
class PowerOf2Image {
  /**
   * If image dimension is NOT power of 2 then create a new `<canvas>`
   * (with power of 2 dimension) and copy the original image content onto it.
   * Since fetching imge data from server is a *async* operation the `imgEl` property
   * can be `null` right after object construction and will be set later after
   * image is loaded (and possible converted).
   *
   * @param {string|HTMLImageElement|HTMLCanvasElement} from - url or html *image* element
   */
  constructor(from) {
    let imgEl;
    if (typeof from === 'string') {
      imgEl = new window.Image();
      imgEl.src = from;
    } else {
      imgEl = from;
    }
    if (imgEl.complete === false || imgEl.width === 0 && imgEl.height === 0) {
      /**
       * @type {HTMLImageElement|HTMLCanvasElement}
       */
      this.imgEl = null;
      /**
       * @type {Promise<PowerOf2Image>}
       */
      this.complete = new Promise(resolve => {
        const origOnLoad = imgEl.onload;
        imgEl.onload = () => {
          if (origOnLoad) origOnLoad.call(imgEl);
          setPowerOf2ImgEl(this, imgEl);
          resolve(this);
        };
      });
    } else {
      setPowerOf2ImgEl(this, imgEl);
      /**
       * @type {Promise<PowerOf2Image>}
       */
      this.complete = Promise.resolve(this);
    }
  }

  /**
   * A boolean that is `true` if the image has loaded and possible converted.
   * @type {boolean}
   */
  get isComplete() {
    return this.imgEl != null;
  }

  /**
   * Returns image width or `0` if image loading is not finished.
   * @type {number}
   */
  get width() {
    return this.imgEl && this.imgEl.width || 0;
  }

  /**
   * Returns image height or `0` if image loading is not finished.
   * @type {number}
   */
  get height() {
    return this.imgEl && this.imgEl.height || 0;
  }
}

exports.default = PowerOf2Image;
function setPowerOf2ImgEl(p2img, imgEl) {
  p2img.imgEl = (0, _math_helpers.isPowerOf2)(imgEl.width) && (0, _math_helpers.isPowerOf2)(imgEl.height) ? imgEl : convertToPowerOf2(imgEl);
  p2img.origWidth = imgEl.width;
  p2img.origHeight = imgEl.height;
}

function convertToPowerOf2(image) {
  const w = (0, _math_helpers.findNextPowerOf2)(image.width);
  const h = (0, _math_helpers.findNextPowerOf2)(image.height);

  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  canvas.getContext('2d').drawImage(image, 0, 0);

  return canvas;
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _texture = __webpack_require__(11);

var _texture2 = _interopRequireDefault(_texture);

var _texture_atlas_spec = __webpack_require__(42);

var _texture_atlas_spec2 = _interopRequireDefault(_texture_atlas_spec);

var _sample = __webpack_require__(43);

var _sample2 = _interopRequireDefault(_sample);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  * @example
  * TextureAtlas.load('nobinger.json').then(atlas => {
  *   const blau = atlas.getFrame('nobinger-blau.png')
  *   blau.width   # => 55
  *   blau.height  # => 61
  * })
  */
class TextureAtlas {
  /**
   * @param {Texture} rootTexture
   * @param {TextureAtlasSpec} [spec=null]
   */
  constructor(rootTexture, spec = null) {
    /**
     * @type {Texture}
     */
    this.rootTexture = rootTexture;
    /**
     * @type {TextureAtlasSpec}
     */
    this.spec = spec;
    /**
     * @type {Map<string,Texture>}
     */
    this.frames = new Map();
  }

  /**
   * @param {string} name
   * @param {number} width
   * @param {number} height
   * @param {number} x
   * @param {number} y
   */
  addFrame(name, width, height, x, y) {
    this.frames.set(name, new _texture2.default(this.rootTexture, width, height, x, y));
  }

  /**
   * @param {string} name
   * @returns {Texture}
   */
  getFrame(name) {
    return this.frames.get(name);
  }

  /**
   * @returns {Texture}
   */
  getRandomFrame() {
    return (0, _sample2.default)(Array.from(this.frames.values()));
  }

  /**
   * @returns {string}
   */
  getRandomFrameName() {
    return (0, _sample2.default)(this.frameNames());
  }

  /**
   * @returns {Array<string>}
   */
  frameNames() {
    return Array.from(this.frames.keys());
  }

  /**
   * Loads a TextureAtlas.
   * @param {string} url - should point to the *texture atlas json spec*
   * @param {object} [fetchOptions=undefined] - options for the `fetch()` call
   * @param {string|function|PowerOf2Image|HTMLImageElement|HTMLCanvasElement} [image=null] - per default the image will be loaded from `meta.image` url from the *texture atlas spec*
   * @param {object} [textureHints=undefined] - texture hints
   * @returns {Promise<TextureAtlas>}
   */
  static load(url, fetchOptions = null, image = null, textureHints = undefined) {
    return _texture_atlas_spec2.default.load(url, fetchOptions || {}).then(atlasSpec => atlasSpec.createTextureAtlas(image || atlasSpec.imageUrl, textureHints));
  }
}
exports.default = TextureAtlas;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_variable = __webpack_require__(5);

var _shader_variable2 = _interopRequireDefault(_shader_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Shader texture 2d variable.
 */
class ShaderTexture2dVariable extends _shader_variable2.default {
  /**
   * @param {string} name
   * @param {number|Object} value
   */
  constructor(name, value) {
    super(name, _shader_variable2.default.TYPE.TEXTURE_2D, value);
    this.texture = null;
  }

  /**
   * Sync texture to gpu and update `.value` to the gl texture unit.
   *
   * @param {WebGlRenderer} renderer
   */
  syncTextureAndValue(renderer) {
    if (this.texture != null) {
      const glTex = renderer.syncTexture(this.texture);
      this.value = glTex.bind();
    }
  }
}
exports.default = ShaderTexture2dVariable;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(120);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(121);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(26),
    isObjectLike = __webpack_require__(27);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(14),
    getRawTag = __webpack_require__(123),
    objectToString = __webpack_require__(124);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 27 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(148),
    getValue = __webpack_require__(153);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(25);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineCustomElements = __webpack_require__(74);

var _defineCustomElements2 = _interopRequireDefault(_defineCustomElements);

var _api = __webpack_require__(199);

var _api2 = _interopRequireDefault(_api);

var _constants = __webpack_require__(0);

var _log = __webpack_require__(54);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global customElements */
if (customElements.get(_constants.DOM_ELEM_CANVAS)) {
  (0, _log2.default)('<blitpunk> custom elements have already been defined');
} else {
  (0, _log2.default)('<blitpunk> custom elements are now defined');
  (0, _defineCustomElements2.default)();
}

const whenReady = customElements.whenDefined(_constants.DOM_ELEM_CANVAS).then(() => _api2.default);

exports.default = () => whenReady;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component_registry = __webpack_require__(33);

var _component_registry2 = _interopRequireDefault(_component_registry);

var _entity_manager = __webpack_require__(34);

var _entity_manager2 = _interopRequireDefault(_entity_manager);

var _resource_library = __webpack_require__(37);

var _resource_library2 = _interopRequireDefault(_resource_library);

var _texture_library = __webpack_require__(39);

var _texture_library2 = _interopRequireDefault(_texture_library);

var _web_gl_context = __webpack_require__(94);

var _web_gl_context2 = _interopRequireDefault(_web_gl_context);

var _web_gl_renderer = __webpack_require__(103);

var _web_gl_renderer2 = _interopRequireDefault(_web_gl_renderer);

var _registerDefaultComponents = __webpack_require__(104);

var _registerDefaultComponents2 = _interopRequireDefault(_registerDefaultComponents);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

var _log = __webpack_require__(54);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const eventize = __webpack_require__(1);
const tinycolor = __webpack_require__(46);

const now = () => window.performance.now() / 1000;

const defaultOption = (options, key, defaultValueFn) => {
  if (options && key in options) {
    return options[key];
  }
  return typeof defaultValueFn === 'function' ? defaultValueFn() : defaultValueFn;
};

class App {
  constructor(options) {
    eventize(this);

    const getOption = defaultOption.bind(null, options);

    this.componentRegistry = getOption('componentRegistry', () => new _component_registry2.default());
    this.entityManager = getOption('entityManager', () => new _entity_manager2.default());
    this.resourceLibrary = getOption('resourceLibrary', () => new _resource_library2.default());
    this.textureLibrary = getOption('textureLibrary', () => new _texture_library2.default());

    /**
     * @type {CanvasHTMLElement}
     */
    this.canvas = getOption('canvas', () => document.createElement('canvas'));

    /**
     * The initial attributes used to create the webgl context
     * @type {Object}
     * @see https://developer.mozilla.org/de/docs/Web/API/HTMLCanvasElement/getContext
     */
    this.contextAttributes = {
      alpha: getOption('alpha', false),
      depth: getOption('depth', false),
      stencil: getOption('stencil', false),
      antialias: getOption('antialias', false),
      premultipliedAlpha: getOption('premultipliedAlpha', false),
      preserveDrawingBuffer: getOption('preserveDrawingBuffer', false)

      /**
       * Seconds since App startup
       * @type {number}
       */
    };this.time = getOption('time', 0);

    /** @private */
    this.lastFrameTime = 0;

    /**
     * Seconds since last frame
     * @type {number}
     */
    this.timeFrameOffset = 0;

    /**
     * Frame counter since application startup
     * @type {number}
     */
    this.frameNo = getOption('frameNo', 0);

    this.clearColor = getOption('clearColor');

    this.createGlContext = getOption('createGlContext', () => () => createGlContext(this.canvas, this.contextAttributes));

    (0, _registerDefaultComponents2.default)(this.componentRegistry);

    this.entity = this.entityManager.createEntity();
    this.entity.setComponent('blitpunk', this);
    this.entity.setComponent('resourceLibrary', this.resourceLibrary);
    this.entity.setComponent('textureLibrary', this.textureLibrary);
    this.componentRegistry.createComponent(this.entity, 'children');

    this.el = null;

    this.started = false;
    this.stopped = false;
    this.destroyed = false;
  }

  get clearColor() {
    return this.renderer ? this.renderer.clearColor : this._clearColor;
  }

  set clearColor(color) {
    this._clearColor = color == null ? color : tinycolor(color);
    if (this.renderer) {
      this.renderer.setClearColor(this._clearColor);
    }
  }

  get canStart() {
    return (!this.started || this.started && this.stopped) && !this.destroyed;
  }

  start(el = this) {
    if (!this.canStart) return;

    if (this.stopped) {
      this.stopped = false;
      this.resize();
      this.requestAnimate();
      return;
    }

    this.el = el;
    this.started = true;

    /**
     * @type {WebGlContext}
     */
    this.glx = new _web_gl_context2.default(this.createGlContext());

    /**
     * @type {WebGlRenderer}
     */
    this.renderer = new _web_gl_renderer2.default(this.glx);

    if (this._clearColor) {
      this.renderer.setClearColor(this._clearColor);
    }

    /**
     * Startup time in seconds.
     * @type {number}
     */
    this.startTime = now();

    this.el.appendChild(this.canvas);
    this.resize();
    this.requestAnimate();
  }

  requestAnimate() {
    this.rafSubscription = window.requestAnimationFrame(() => this.animate());
  }

  cancelAnimate() {
    window.cancelAnimationFrame(this.rafSubscription);
  }

  get canStop() {
    return this.started && !this.stopped && !this.destroyed;
  }

  stop() {
    if (!this.canStop) return;
    this.stopped = true;
    this.cancelAnimate();
  }

  destroy() {
    if (this.destroyed) return;
    this.cancelAnimate();
    try {
      this.glx.destroy();
    } catch (err0) {
      (0, _log.error)('blitpunk->destroy(WebGlContext) panic!', err0);
    }
    try {
      this.renderer.destroy();
    } catch (err1) {
      (0, _log.error)('blitpunk->destroy(WebGlRenderer) panic!', err1);
    }
    try {
      this.textureLibrary.destroy();
    } catch (err2) {
      (0, _log.error)('blitpunk->destroy(TextureLibrary) panic!', err2);
    }
    try {
      this.resourceLibrary.destroy();
    } catch (err3) {
      (0, _log.error)('blitpunk->destroy(ResourceLibrary) panic!', err3);
    }
    try {
      this.entityManager.destroy();
    } catch (err4) {
      (0, _log.error)('blitpunk->destroy(EntityManager) panic!', err4);
    }
    // this.componentRegistry (ComponentRegistry)
    this.el.removeChild(this.canvas);
    (0, _destroy2.default)(this);
  }

  get canAnimate() {
    return this.started && !this.stopped && !this.destroyed;
  }

  /**
   * Start the main animation loop.
   */
  animate() {
    if (!this.canAnimate) return;
    this.renderFrame();
    this.requestAnimate();
  }

  /**
   * Render the frame.
   */
  renderFrame() {
    ++this.frameNo;
    this.time = now() - this.startTime;
    if (this.lastFrameTime) {
      this.timeFrameOffset = this.time - this.lastFrameTime;
    }
    this.lastFrameTime = this.time;
    this.resize();
    this.renderer.renderFrame(this.entity, this);
  }

  /**
   * Resize the canvas dom element to the same size as the `<blitpunk-canvas>.parentNode`
   */
  resize() {
    const style = window.getComputedStyle(this.el, null);
    const el = style.display === 'inline' ? this.el.parentNode : this.el;

    const { canvas } = this;
    const dpr = window.devicePixelRatio || 1;

    let wPx = el.clientWidth;
    let hPx = el.clientHeight;

    canvas.style.width = wPx + 'px';
    canvas.style.height = hPx + 'px';

    const w = Math.round(wPx * dpr);
    const h = Math.round(hPx * dpr);

    if (w !== canvas.width || h !== canvas.height) {
      canvas.width = w;
      canvas.height = h;
    }

    if (w !== this.width || h !== this.height) {
      /**
       * Canvas size in _device_ pixels.
       * @type {number}
       */
      this.width = w;
      /**
       * Canvas size in _device_ pixels.
       * @type {number}
       */
      this.height = h;

      this.glx.gl.viewport(0, 0, w, h); // TODO move this into WebGlRenderer
    }
  }
}

/** @private */
function createGlContext(canvas, ctxAttrs) {
  let gl;

  try {
    gl = canvas.getContext('webgl', ctxAttrs);
  } catch (err0) {
    (0, _log.error)(err0);
  }

  if (!gl) {
    try {
      gl = canvas.getContext('experimental-webgl', ctxAttrs);
    } catch (err1) {
      (0, _log.error)(err1);
    }
  }

  if (!gl) {
    throw new Error('cannot create webgl1 context');
  }

  return gl;
}

exports.default = App;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
class ComponentRegistry {
  constructor() {
    this.registry = new Map();
  }

  /**
   * @param {string} name - component name
   * @param {object} componentFactory - the component factory interface
   * @param {function} componentFactory.create - create a new component instance
   * @param {function} componentFactory.update - update a component
   */
  registerComponent(name, componentFactory) {
    this.registry.set(name, componentFactory);
    return this;
  }

  createComponent(entity, name, data) {
    const factory = this.registry.get(name);
    const component = factory.create(entity, data);
    entity.setComponent(name, component);
    return this;
  }

  updateComponent(entity, name, data) {
    const component = entity[name];
    const factory = this.registry.get(name);
    factory.update(component, data);
    return this;
  }

  createOrUpdateComponent(entity, name, data) {
    if (entity[name] != null) {
      this.updateComponent(entity, name, data);
    } else {
      this.createComponent(entity, name, data);
    }
    return this;
  }
}
exports.default = ComponentRegistry;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _entity = __webpack_require__(35);

var _entity2 = _interopRequireDefault(_entity);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The entity manager holds references to all entities.
 */
class EntityManager {
  constructor() {
    this.entities = new Map();
  }

  createEntity() {
    const entity = new _entity2.default();
    this.entities.set(entity.id, entity);
    return entity;
  }

  getEntity(id) {
    return this.entities.get(id);
  }

  destroyEntity(id) {
    const entity = this.entities.get(id);
    if (entity) {
      entity.destroy();
      this.entities.delete(id);
      return true;
    }
    return false;
  }

  destroyAllEntities() {
    for (const id of this.entities.keys()) {
      this.destroyEntity(id);
    }
  }

  destroy() {
    this.destroyAllEntities();
    this.entities.clear();
    (0, _destroy2.default)(this);
  }
}
exports.default = EntityManager;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _generate_uuid = __webpack_require__(4);

var _generate_uuid2 = _interopRequireDefault(_generate_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const eventize = __webpack_require__(1);

const destroyAllComponents = entity => {
  for (const name of entity.components.keys()) {
    entity.destroyComponent(name);
  }
};

/**
 * An Entity.
 */
class Entity {
  constructor() {
    this.components = new Map();

    /**
     * @type {string}
     */
    this.id = (0, _generate_uuid2.default)();

    eventize(this);
  }

  hasComponent(name) {
    return this.components.has(name);
  }

  setComponent(name, component) {
    if (this[name]) {
      throw new Error(`Component name "${name}" is already assigned!`);
    }
    this.components.set(name, component);
    this[name] = component;
    if (component.connectedEntity) {
      component.connectedEntity(this);
    }
    return this;
  }

  destroyComponent(name) {
    if (this.components.delete(name)) {
      const component = this[name];
      delete this[name];
      if (component.disconnectedEntity) {
        component.disconnectedEntity(this);
      }
    }
    return this;
  }

  destroy() {
    this.emit('destroy', this);
    destroyAllComponents(this);
  }
}
exports.default = Entity;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _v_o_descriptor = __webpack_require__(38);

var _v_o_descriptor2 = _interopRequireDefault(_v_o_descriptor);

var _shader_source = __webpack_require__(19);

var _shader_source2 = _interopRequireDefault(_shader_source);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

var _sprites = __webpack_require__(85);

var _sprites2 = _interopRequireDefault(_sprites);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ResourceLibrary {
  constructor() {
    this.descriptors = new Map();
    this.vertexShaders = new Map();
    this.fragmentShaders = new Map();

    (0, _sprites2.default)(this);
  }

  destroy() {
    this.descriptors.clear();
    this.vertexShaders.clear();
    this.fragmentShaders.clear();
    (0, _destroy2.default)(this);
  }

  /**
   * @param {string} name
   * @param {Object} description - see `VODescriptor` for more details
   */
  addDescriptor(name, description) {
    this.descriptors.set(name, new _v_o_descriptor2.default(description));
    return this;
  }

  /**
   * @param {string} name
   * @param {string|function|string[]} source - see `ShaderSource` for more details
   */
  addVertexShader(name, source) {
    this.vertexShaders.set(name, new _shader_source2.default(_shader_source2.default.VERTEX_SHADER, source));
    return this;
  }

  /**
   * @param {string} name
   * @param {string|function|string[]} source - see `ShaderSource` for more details
   */
  addFragmentShader(name, source) {
    this.fragmentShaders.set(name, new _shader_source2.default(_shader_source2.default.FRAGMENT_SHADER, source));
    return this;
  }

  /**
   * @param {string} name
   * @returns {VODescriptor}
   */
  findDescriptor(name) {
    return this.descriptors.get(name);
  }

  /**
   * @param {string} name
   * @returns {ShaderSource}
   */
  findVertexShader(name) {
    return this.vertexShaders.get(name);
  }

  /**
   * @param {string} name
   * @returns {ShaderSource}
   */
  findFragmentShader(name) {
    return this.fragmentShaders.get(name);
  }
}
exports.default = ResourceLibrary;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _v_o_helper = __webpack_require__(79);

var _v_o_array = __webpack_require__(7);

var _v_o_array2 = _interopRequireDefault(_v_o_array);

var _create_v_o_prototype = __webpack_require__(81);

var _create_v_o_prototype2 = _interopRequireDefault(_create_v_o_prototype);

var _create_typed_arrays = __webpack_require__(82);

var _create_typed_arrays2 = _interopRequireDefault(_create_typed_arrays);

var _create_attributes = __webpack_require__(83);

var _create_attributes2 = _interopRequireDefault(_create_attributes);

var _create_aliases = __webpack_require__(84);

var _create_aliases2 = _interopRequireDefault(_create_aliases);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Vertex object descriptor.
 *
 * @class VODescriptor
 *
 * @param {Object} options
 * @param {number} options.vertexCount - number of vertices
 * @param {Object[]} options.attributes - list of vertex attribute descriptions (see example)
 * @param {Object} [options.aliases] - *optional* list of attribute aliases
 * @param {Object} [options.proto]
 *
 * @example
 * const descriptor = new VODescriptor({
 *
 *     proto: {
 *         foo() {
 *             return this.voArray.float32Array[0];
 *         }
 *     },
 *
 *     // vertex buffer layout
 *     // --------------------
 *     //
 *     // v0: (x0)(y0)(z0)(rotate](s0)(t0)(tx)(ty)(scale)(opacity)
 *     // v1: (x1)(y1)(z1)(rotate](s1)(t1)(tx)(ty)(scale)(opacity)
 *     // v2: (x2)(y2)(z2)(rotate](s2)(t2)(tx)(ty)(scale)(opacity)
 *     // v3: (x3)(y3)(z3)(rotate](s3)(t3)(tx)(ty)(scale)(opacity)
 *     //
 *     vertexCount: 4,
 *
 *     attributes: [
 *
 *         { name: 'position',  type: 'float32', size: 3, attrNames: [ 'x', 'y', 'z' ] },
 *         { name: 'rotate',    type: 'float32', size: 1, uniform: true },
 *         { name: 'texCoords', type: 'float32', size: 2, attrNames: [ 's', 't' ] },
 *         { name: 'translate', type: 'float32', size: 2, attrNames: [ 'tx', 'ty' ], uniform: true },
 *         { name: 'scale',     type: 'float32', size: 1, uniform: true },
 *         { name: 'opacity',   type: 'float32', size: 1, uniform: true }
 *
 *     ],
 *
 *     aliases: {
 *
 *         pos2d: { size: 2, type: 'float32', offset: 0 },
 *         posZ:  { size: 1, type: 'float32', offset: 2, uniform: true },
 *         r:     { size: 1, type: 'float32', offset: 3 },
 *         uv:    'texCoords',
 *
 *     }
 *
 * });
 *
 */

class VODescriptor {
  constructor({ vertexCount, attributes, aliases, proto }) {
    this.vertexCount = parseInt(vertexCount, 10);

    (0, _create_attributes2.default)(this, attributes);
    (0, _create_aliases2.default)(this, aliases);
    (0, _create_v_o_prototype2.default)(this, proto);
    (0, _create_typed_arrays2.default)(this);

    // === winterklte jetzt

    Object.keys(this.attr).forEach(name => Object.freeze(this.attr[name]));
    Object.freeze(this.attr);
    Object.freeze(this);
  }

  /**
   * @param {number} [size=1]
   * @param {string} [usage]
   * @returns {VOArray}
   */
  createVOArray(size = 1, usage = undefined) {
    return new _v_o_array2.default(this, size, null, usage);
  }

  /**
   * Create a new *vertex object*
   *
   * @param {VOArray} [voArray]
   * @returns {Object} the *vertex object*
   */
  createVO(voArray) {
    return (0, _v_o_helper.createVO)(Object.create(this.voPrototype), this, voArray);
  }

  /**
   * @param {string} name
   * @param {number} size - attribute item count
   * @returns {boolean}
   */
  hasAttribute(name, size) {
    const attr = this.attr[name];
    return attr && attr.size === size;
  }

  /**
   * Max number of vertex objects when a vertex buffer is used together
   * with a indexed element array to draw primitives. the reason for
   * such a limit is that webgl restricts element array indices
   * to an uin16 data type.
   * @type {number}
   */

  get maxIndexedVOPoolSize() {
    return Math.floor(65536 / this.vertexCount);
  }
}
exports.default = VODescriptor;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _texture = __webpack_require__(11);

var _texture2 = _interopRequireDefault(_texture);

var _texture_state = __webpack_require__(41);

var _texture_state2 = _interopRequireDefault(_texture_state);

var _texture_atlas = __webpack_require__(21);

var _texture_atlas2 = _interopRequireDefault(_texture_atlas);

var _shader_texture_2d_variable = __webpack_require__(22);

var _shader_texture_2d_variable2 = _interopRequireDefault(_shader_texture_2d_variable);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TextureLibrary {
  constructor() {
    this.states = new Map();
    this.shaderVars = new Map();
  }

  destroy() {
    this.states.clear();
    this.shaderVars.clear();
    (0, _destroy2.default)(this);
  }

  loadTexture(id, url = id, textureHints = undefined) {
    const state = new _texture_state2.default(_texture2.default.load(url, textureHints));
    this.states.set(id, state);
    return state.promise;
  }

  loadTextureAtlas(id, url = id, textureHints = undefined) {
    const atlas = _texture_atlas2.default.load(url, null, null, textureHints);
    const state = new _texture_state2.default(atlas.then(atlas => {
      state.atlas = atlas;
      return atlas.rootTexture;
    }));
    this.states.set(id, state);
    return atlas;
  }

  getTextureAtlas(id) {
    return this.states.get(id).atlas;
  }

  whenLoaded(textureId, shaderVarKey, onLoaded) {
    const state = this.states.get(textureId);
    if (state === undefined || !state.isReady) return;

    let shaderVar = this.shaderVars.get(shaderVarKey);
    if (shaderVar === undefined) {
      shaderVar = new _shader_texture_2d_variable2.default(shaderVarKey);
      this.shaderVars.set(shaderVarKey, shaderVar);
    }

    shaderVar.texture = state.texture;
    onLoaded(shaderVar);
  }
}
exports.default = TextureLibrary;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
const maxOf = (a, b) => a > b ? a : b;

/**
 * @param {number} x
 * @return {number}
 */
function findNextPowerOf2(x) {
  let p = 1;
  while (x > p) p <<= 1;
  return p;
}

/**
 * @param {number} n
 * @return {boolean}
 */
const isPowerOf2 = n => n !== 0 && (n & n - 1) === 0;

exports.maxOf = maxOf;
exports.findNextPowerOf2 = findNextPowerOf2;
exports.isPowerOf2 = isPowerOf2;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
class TextureState {
  constructor(texture, atlas) {
    this.texture = null;
    this.atlas = null;
    this.promise = Promise.resolve(texture).then(tex => {
      this.texture = tex;
      return tex;
    }).catch(err => {
      console.error('TextureState error:', err);
    });
    Promise.resolve(atlas).then(atlas => {
      this.atlas = atlas;
    });
  }

  get isReady() {
    return this.texture != null;
  }
}
exports.default = TextureState;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _texture = __webpack_require__(11);

var _texture2 = _interopRequireDefault(_texture);

var _texture_atlas = __webpack_require__(21);

var _texture_atlas2 = _interopRequireDefault(_texture_atlas);

var _power_of_2_image = __webpack_require__(20);

var _power_of_2_image2 = _interopRequireDefault(_power_of_2_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TextureAtlasSpec {
  constructor(jsonDef) {
    this.jsonDef = jsonDef;
    this.frameNames = Object.keys(jsonDef.frames);
  }

  get frames() {
    return this.jsonDef.frames;
  }

  get meta() {
    return this.jsonDef.meta;
  }

  get imageUrl() {
    return this.meta.image;
  }

  createTextureAtlas(image = null, textureHints = undefined) {
    return Promise.resolve(image).then(image => {
      if (typeof image === 'function') {
        return Promise.resolve(image(this)).then(img => {
          if (typeof img === 'string') {
            return new _power_of_2_image2.default(img).complete;
          }
          return img;
        });
      } else if (typeof image === 'string') {
        return new _power_of_2_image2.default(image).complete;
      } else if (image) {
        return image;
      } else {
        throw new Error('TextureAtlasSpec.createTextureAtlas(): no image found!');
      }
    }).then(image => {
      const rootTexture = new _texture2.default(image, undefined, undefined, 0, 0, textureHints);
      const atlas = new _texture_atlas2.default(rootTexture, this);
      for (let name of Object.keys(this.frames)) {
        const { frame } = this.frames[name];
        atlas.addFrame(name, frame.w, frame.h, frame.x, frame.y);
      }
      return atlas;
    });
  }

  static load(url, options) {
    return window.fetch(url, options).then(response => response.json()).then(json => new TextureAtlasSpec(json));
  }
}
exports.default = TextureAtlasSpec;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = sample;
function sample(arr) {
  return arr[Math.random() * arr.length | 0];
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
class WebGlBuffer {
  constructor(glx, target = WebGlBuffer.ARRAY_BUFFER, usage = WebGlBuffer.STATIC_DRAW) {
    this.glx = glx;

    const { gl } = glx;
    this.target = gl[target];
    this.usage = gl[usage];

    this.glBuffer = gl.createBuffer();
  }

  bindBuffer() {
    this.glx.bindBuffer(this.target, this.glBuffer);
  }

  /**
   * Upload array buffer content to gpu via `g.bufferData(..)`.
   */
  bufferData(typedArray) {
    this.bindBuffer();
    this.glx.gl.bufferData(this.target, typedArray, this.usage);
  }
}

exports.default = WebGlBuffer;
WebGlBuffer.ARRAY_BUFFER = 'ARRAY_BUFFER';
WebGlBuffer.ELEMENT_ARRAY_BUFFER = 'ELEMENT_ARRAY_BUFFER';

WebGlBuffer.STATIC_DRAW = 'STATIC_DRAW';
WebGlBuffer.DYNAMIC_DRAW = 'DYNAMIC_DRAW';

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_variable = __webpack_require__(5);

var _shader_variable2 = _interopRequireDefault(_shader_variable);

var _shader_variable_group = __webpack_require__(12);

var _shader_variable_group2 = _interopRequireDefault(_shader_variable_group);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A ShaderContext keeps named references to all shader _variables_
 * to make them available for shader _programs_.
 * Each named reference is organized as a _stack_ where you can push
 * or pop shader variable _values_.
 */
class ShaderContext {
  constructor() {
    this.uniform = new Map();
    this.attrib = new Map();
    this.tex2d = new Map();
  }

  clear() {
    this.uniform.clear();
    this.attrib.clear();
    this.tex2d.clear();
  }

  destroy() {
    this.clear();
    (0, _destroy2.default)(this);
  }

  /**
   * @param {ShaderVariable|ShaderVariableGroup} shaderVariable
   */
  pushVar(shaderVariable) {
    if (shaderVariable instanceof _shader_variable_group2.default) {
      shaderVariable.pushVar(this);
    } else {
      const lane = shaderVarLane(this, shaderVariable.type, shaderVariable.name);
      lane.push(shaderVariable);
    }
  }

  /**
   * Remove current shader variable plus all later set variables from named shader variable stack.
   * @param {ShaderVariable|ShaderVariableGroup} shaderVariable
   */
  popVar(shaderVariable) {
    if (shaderVariable instanceof _shader_variable_group2.default) {
      shaderVariable.popVar(this);
    } else {
      const lane = shaderVarLane(this, shaderVariable.type, shaderVariable.name);
      const len = lane.length;
      for (let i = 0; i < len; ++i) {
        if (lane[i] === shaderVariable) {
          lane.length = i;
          return;
        }
      }
    }
  }

  /**
   * Return current shader variable by name and type.
   * @param {ShaderVariable} shaderVariable
   * @return {ShaderVariable} or `null`
   */
  curVar(shaderVariable) {
    const lane = shaderVarMap(this, shaderVariable.type).get(shaderVariable.name);
    return lane && lane.length ? lane[lane.length - 1] : null;
  }

  /**
   * Return current _uniform_ shader variable by name.
   * @param {string} name
   * @return {ShaderUniformVariable} or `null`
   */
  curUniform(name) {
    const lane = this.uniform.get(name);
    return lane && lane.length ? lane[lane.length - 1] : null;
  }

  /**
   * Return current _attribute_ shader variable by name.
   * @param {string} name
   * @return {ShaderAttribVariable} or `null`
   */
  curAttrib(name) {
    const lane = this.attrib.get(name);
    return lane && lane.length ? lane[lane.length - 1] : null;
  }

  /**
   * Return current _texture2d_ shader variable by name.
   * @param {string} name
   * @return {ShaderTexture2dVariable} or `null`
   */
  curTex2d(name) {
    const lane = this.tex2d.get(name);
    return lane && lane.length ? lane[lane.length - 1] : null;
  }
}

exports.default = ShaderContext;
function shaderVarMap(shaderContext, type) {
  switch (type) {
    case _shader_variable2.default.TYPE.UNIFORM:
      return shaderContext.uniform;
    case _shader_variable2.default.TYPE.ATTRIB:
      return shaderContext.attrib;
    case _shader_variable2.default.TYPE.TEXTURE_2D:
      return shaderContext.tex2d;
  }
}

function shaderVarLane(shaderContext, type, name) {
  const map = shaderVarMap(shaderContext, type);
  let lane = map.get(name);

  if (!lane) {
    lane = [];
    map.set(name, lane);
  }

  return lane;
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {return tinycolor;}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _mat = __webpack_require__(48);

var _mat2 = _interopRequireDefault(_mat);

var _shader_uniform_variable = __webpack_require__(52);

var _shader_uniform_variable2 = _interopRequireDefault(_shader_uniform_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const UNIFORM_NAME = 'viewMatrix';

/**
 * @param {object} options
 * @param {number} [options.desiredWidth] - desired width
 * @param {number} [options.desiredHeight] - desired height
 * @param {number} [options.pixelRatio] - pixel ratio
 * @param {string} [options.sizeFit] - `cover`, `contain` or `fill`
 * @param {string} [options.uniformName='viewMatrix'] - name of the uniform value
 */
class Projection {
  constructor({ desiredWidth, desiredHeight, pixelRatio, sizeFit, uniformName }) {
    this.desiredWidth = desiredWidth;
    this.desiredHeight = desiredHeight;
    this.pixelRatio = pixelRatio;
    this.sizeFit = sizeFit;
    this.uniform = new _shader_uniform_variable2.default(uniformName || UNIFORM_NAME, new _mat2.default());
    this.width = 0;
    this.height = 0;
  }

  updateOrtho(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      // this.uniform.value.ortho(width, height)
      // TODO enable perspective with distance
      this.uniform.value.perspective(width, height, 100);
      this.uniform.touch();
    }
  }

  update(currentWidth, currentHeight) {
    // TODO pixelRatio and currentPixelRatio
    if (this.sizeFit === 'fill' && this.desiredWidth > 0 && this.desiredHeight > 0) {
      this.updateOrtho(this.desiredWidth, this.desiredHeight);
    } else if ((this.sizeFit === 'cover' || this.sizeFit === 'contain') && this.desiredWidth >= 0 && this.desiredHeight >= 0) {
      const currentRatio = currentHeight / currentWidth; // <1 : landscape, >1 : portrait
      const desiredRatio = this.desiredHeight / this.desiredWidth;
      const isCover = this.sizeFit === 'cover';

      let width = this.desiredWidth;
      let height = this.desiredHeight;

      if (this.desiredWidth === 0 && this.desiredHeight || currentRatio < desiredRatio) {
        width = this.desiredHeight / currentHeight * currentWidth;
        if (isCover) {
          const factor = this.desiredWidth / width;
          width *= factor;
          height *= factor;
        }
      } else if (this.desiredWidth && this.desiredHeight === 0 || currentRatio > desiredRatio) {
        height = this.desiredWidth / currentWidth * currentHeight;
        if (isCover) {
          const factor = this.desiredHeight / height;
          width *= factor;
          height *= factor;
        }
      }

      this.updateOrtho(width, height);
    }
  }
}
exports.default = Projection;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
const { mat4 } = __webpack_require__(106);

const DEG2RAD = Math.PI / 180.0;

class Mat4 {
  constructor() {
    this.mat4 = mat4.create();
    Object.freeze(this);
  }

  identity() {
    mat4.identity(this.mat4);
  }

  ortho(width, height, zRange = Math.pow(2, 16)) {
    const hw = width >> 1;
    const hh = height >> 1;
    const hz = zRange >> 1;
    mat4.ortho(this.mat4, -hw, hw, -hh, hh, -hz, hz);
  }

  perspective(width, height, distance = 100) {
    // https://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html
    // https://stackoverflow.com/questions/6653080/in-opengl-how-can-i-determine-the-bounds-of-the-view-at-a-given-depth
    // http://glmatrix.net/docs/module-mat4.html
    const aspect = width / height;
    const near = 0;
    const far = 2000;
    const halfHeight = height / 2.0;
    const fovy = 2 * Math.atan(halfHeight / distance);
    mat4.perspective(this.mat4, fovy, aspect, near, far);
    // TODO camera feature
    mat4.translate(this.mat4, this.mat4, [0, 0, -distance]);
  }

  translate(x, y, z = 0) {
    mat4.translate(this.mat4, this.mat4, [x, y, z]);
  }

  scale(x, y, z = 1) {
    mat4.scale(this.mat4, this.mat4, [x, y, z]);
  }

  rotateX(deg) {
    mat4.rotateX(this.mat4, this.mat4, deg * DEG2RAD);
  }

  rotateY(deg) {
    mat4.rotateY(this.mat4, this.mat4, deg * DEG2RAD);
  }

  rotateZ(deg) {
    mat4.rotateZ(this.mat4, this.mat4, deg * DEG2RAD);
  }

  multiply(a, b) {
    mat4.multiply(this.mat4, a.mat4, b.mat4);
  }

  copy(src) {
    mat4.copy(this.mat4, src.mat4);
  }

  clone() {
    const dolly = new Mat4();
    dolly.copy(this);
    return dolly;
  }

  get x() {
    return this.mat4[12];
  }

  set x(val) {
    this.mat4[12] = val;
  }

  get y() {
    return this.mat4[13];
  }

  set y(val) {
    this.mat4[13] = val;
  }

  get z() {
    return this.mat4[14];
  }

  set z(val) {
    this.mat4[14] = val;
  }

  get sx() {
    return this.mat4[0];
  }

  set sx(val) {
    this.mat4[0] = val;
  }

  get sy() {
    return this.mat4[5];
  }

  set sy(val) {
    this.mat4[5] = val;
  }

  get sz() {
    return this.mat4[10];
  }

  set sz(val) {
    this.mat4[10] = val;
  }
}
exports.default = Mat4;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_variable = __webpack_require__(5);

var _shader_variable2 = _interopRequireDefault(_shader_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Shader uniform variable.
 */
class ShaderUniformVariable extends _shader_variable2.default {
  /**
   * @param {string} name
   * @param {number|Object} value
   */
  constructor(name, value) {
    super(name, _shader_variable2.default.TYPE.UNIFORM, value);
  }
}
exports.default = ShaderUniformVariable;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
const snakeCase = __webpack_require__(114);

class BlendMode {
  constructor(enable, sfactor = null, dfactor = null) {
    this.enable = enable;
    this.sfactor = sfactor;
    this.dfactor = dfactor;
  }

  set sfactor(value) {
    this._sfactor = typeof value === 'string' ? snakeCase(value).toUpperCase() : undefined;
  }

  get sfactor() {
    return this._sfactor;
  }

  set dfactor(value) {
    this._dfactor = typeof value === 'string' ? snakeCase(value).toUpperCase() : undefined;
  }

  get dfactor() {
    return this._dfactor;
  }

  isEqual(other) {
    return other && this.enable === other.enable && this._sfactor === other._sfactor && this._dfactor === other._dfactor;
  }
}
exports.default = BlendMode;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

const log = typeof console !== 'undefined' ? typeof console.debug === 'function' ? (...args) => console.debug(...args) : (...args) => console.log(...args) : () => 1;

const error = typeof console !== 'undefined' ? typeof console.error === 'function' ? (...args) => console.error(...args) : (...args) => console.log(...args) : () => 1;

exports.default = log;
exports.error = error;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (el, name, defaultValue) {
  if (!el.hasAttribute(name)) return defaultValue;
  switch (el.getAttribute(name).toLowerCase()) {
    case 'true':
    case 'yes':
    case 'on':
    case '':
    case name:
      return true;
  }
  return false;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = findParentElementByName;
const EXIT_NODES = ['BODY', 'HTML'];

function findParentElementByName(node, ...names) {
  const parent = node.parentElement;
  if (!parent || parent.nodeType !== 1) return;
  const { nodeName } = parent;
  if (names.includes(nodeName)) return parent;
  if (EXIT_NODES.includes(nodeName)) return;
  return parent;
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (el) {
  el.blitpunkCanvas = (0, _findBlitpunkCanvasElement2.default)(el);
  el.blitpunk = el.blitpunkCanvas.blitpunk;

  el.entityManager = el.blitpunk.entityManager;
  el.entity = el.entityManager.createEntity();
  el.entity.on(el);

  el.parentSceneElement = (0, _findParentElementByProperty2.default)(el, 'scene');
  el.parentScene = el.parentSceneElement.scene;
  el.parentScene.children.appendChild(el.entity);
};

var _findBlitpunkCanvasElement = __webpack_require__(131);

var _findBlitpunkCanvasElement2 = _interopRequireDefault(_findBlitpunkCanvasElement);

var _findParentElementByProperty = __webpack_require__(132);

var _findParentElementByProperty2 = _interopRequireDefault(_findParentElementByProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (el) {
  el.parentScene.children.removeChild(el.entity);
  el.parentScene = null;
  el.parentSceneElement = null;
  el.entity.off(el);
  el.entityManager.destroyEntity(el.entity);
  el.entity = null;
  el.blitpunk = null;
  el.blitpunkCanvas = null;
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _element_index_array = __webpack_require__(60);

var _element_index_array2 = _interopRequireDefault(_element_index_array);

var _shader_program = __webpack_require__(61);

var _shader_program2 = _interopRequireDefault(_shader_program);

var _shader_texture_group = __webpack_require__(62);

var _shader_texture_group2 = _interopRequireDefault(_shader_texture_group);

var _shader_variable_buffer_group = __webpack_require__(63);

var _shader_variable_buffer_group2 = _interopRequireDefault(_shader_variable_buffer_group);

var _v_o_pool = __webpack_require__(67);

var _v_o_pool2 = _interopRequireDefault(_v_o_pool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pick = __webpack_require__(136);

const getVO = (descriptor, opt) => {
  if (typeof opt === 'function') {
    const vo = descriptor.createVO();
    opt(vo);
    return vo;
  }
  return opt;
};

class SpriteGroup {
  constructor(resourceLibrary, textureLibrary, options) {
    this.resourceLibrary = resourceLibrary;
    this.textureLibrary = textureLibrary;
    this.descriptor = resourceLibrary.findDescriptor(options.descriptor);
    this.voPool = new _v_o_pool2.default(this.descriptor, Object.assign(pick(options, ['capacity', 'usage', 'maxAllocVOSize', 'voArray']), {
      voNew: getVO(this.descriptor, options.voNew),
      voZero: getVO(this.descriptor, options.voZero)
    }));
    this.voPoolShaderAttribs = new _shader_variable_buffer_group2.default(this.voPool);
    this.indices = options.indices || _element_index_array2.default.Generate(this.voPool.capacity, [0, 1, 2, 0, 2, 3], 4 // quads
    // TODO create ElementIndexArray factories! capacity=N, type=quads, ...
    );
    this.shaderProgram = new _shader_program2.default(resourceLibrary.findVertexShader(options.vertexShader), resourceLibrary.findFragmentShader(options.fragmentShader));
    this.primitive = options.primitive;
    this.textures = Object.assign({}, options.textures);
    this.shaderTextureGroup = null;
  }

  get capacity() {
    return this.voPool.capacity;
  }

  get usedCount() {
    return this.voPool.usedCount;
  }
  get availableCount() {
    return this.voPool.availableCount;
  }

  setTexture(sampler, textureId) {
    if (this.textures[sampler] !== textureId) {
      this.textures[sampler] = textureId;
      this.shaderTextureGroup = null;
    }
  }

  loadTextureAtlas(sampler, url) {
    this.textures[sampler] = url;
    this.shaderTextureGroup = null;
    return this.textureLibrary.loadTextureAtlas(url);
  }

  getTextureAtlas(sampler) {
    return this.textureLibrary.getTextureAtlas(this.textures[sampler]);
  }

  createSprite(texture, width, height) {
    const vo = this.voPool.alloc(1);
    if (texture != null) {
      const w = width || texture.width;
      const h = height || texture.height;
      vo.setSize(w, h);
      vo.setTexCoordsByTexture(texture);
    }
    return vo;
  }

  renderFrame(renderer) {
    if (this.shaderTextureGroup == null) {
      this.shaderTextureGroup = new _shader_texture_group2.default(this.textureLibrary, this.textures);
    }
    this.shaderTextureGroup.whenLoaded(texUniforms => {
      const { shaderContext } = renderer;

      shaderContext.pushVar(texUniforms);
      shaderContext.pushVar(this.voPoolShaderAttribs);

      renderer.useShaderProgram(this.shaderProgram);

      renderer.drawIndexed(this.primitive, this.indices);
    });
  }
}
exports.default = SpriteGroup;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _resource_ref = __webpack_require__(8);

var _resource_ref2 = _interopRequireDefault(_resource_ref);

var _web_gl_buffer = __webpack_require__(44);

var _web_gl_buffer2 = _interopRequireDefault(_web_gl_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ElementIndexArray {
  constructor(objectCount, itemCount = 1) {
    this.resourceRef = new _resource_ref2.default(this, {
      target: _web_gl_buffer2.default.ELEMENT_ARRAY_BUFFER,
      usage: 'static'
    });

    this.objectCount = objectCount;
    this.itemCount = itemCount;
    this.length = objectCount * itemCount;

    this.array = new Uint16Array(this.length);

    // needed by WebGlRenderer#syncBuffer
    this.resourceRef.hints.typedArray = this.array;
  }

  /**
   * @param {number} objectCount
   * @param {number[]} indices
   * @param {number} [stride=4]
   * @param {number} [objectOffset=0]
   * @return {ElementIndexArray}
   * @example
   * // Create a ElementIndexArray for 10 quads where each quad made up of 2x triangles (4x vertices and 6x indices)
   * const quadIndices = ElementIndexArray.Generate(10, [0, 1, 2, 0, 2, 3], 4)
   * quadIndices.length        // => 60
   * quadIndices.itemCount     // => 6
   */
  static Generate(objectCount, indices, stride = 4, objectOffset = 0) {
    const arr = new ElementIndexArray(objectCount, indices.length);

    for (let i = 0; i < objectCount; ++i) {
      for (let j = 0; j < indices.length; ++j) {
        arr.array[i * arr.itemCount + j] = indices[j] + (i + objectOffset) * stride;
      }
    }

    return arr;
  }
}
exports.default = ElementIndexArray;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _generate_uuid = __webpack_require__(4);

var _generate_uuid2 = _interopRequireDefault(_generate_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ShaderProgram {
  /**
   * @param {ShaderSource} vertexShader
   * @param {ShaderSource} fragmentShader
   */
  constructor(vertexShader, fragmentShader) {
    /**
     * @type {string}
     */
    this.id = (0, _generate_uuid2.default)();

    /**
     * @type {ShaderSource}
     */
    this.vertexShader = vertexShader;

    /**
     * @type {ShaderSource}
     */
    this.fragmentShader = fragmentShader;
  }
}
exports.default = ShaderProgram;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_variable_group = __webpack_require__(12);

var _shader_variable_group2 = _interopRequireDefault(_shader_variable_group);

var _shader_texture_2d_variable = __webpack_require__(22);

var _shader_texture_2d_variable2 = _interopRequireDefault(_shader_texture_2d_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ShaderTextureGroup {
  constructor(shaderLibrary, shaderTextureMap) {
    this.shaderLibrary = shaderLibrary;
    this.waitFor = Object.keys(shaderTextureMap).map(shaderVarKey => ({
      shaderVarKey,
      textureId: shaderTextureMap[shaderVarKey],
      isLoaded: false
    }));
    this.shaderVarGroup = new _shader_variable_group2.default([]);
    this.shaderVarStore = new Map();
  }

  get isLoaded() {
    return this.waitFor.length === 0 && this.shaderVarGroup.shaderVars.length > 0;
  }

  whenLoaded(onLoaded) {
    if (!this.isLoaded) {
      this.waitFor.forEach(waitFor => {
        if (!waitFor.isLoaded) {
          const state = this.shaderLibrary.states.get(waitFor.textureId);
          if (state === undefined || !state.isReady) return;

          const shaderVar = new _shader_texture_2d_variable2.default(waitFor.shaderVarKey);
          shaderVar.texture = state.texture;
          this.shaderVarGroup.shaderVars.push(shaderVar);

          waitFor.isLoaded = true;
        }
      });
      this.waitFor = this.waitFor.filter(waitFor => waitFor.isLoaded === false);
      if (this.isLoaded) {
        onLoaded(this.shaderVarGroup);
      }
    } else {
      onLoaded(this.shaderVarGroup);
    }
  }
}
exports.default = ShaderTextureGroup;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_variable_group = __webpack_require__(12);

var _shader_variable_group2 = _interopRequireDefault(_shader_variable_group);

var _shader_attrib_variable = __webpack_require__(64);

var _shader_attrib_variable2 = _interopRequireDefault(_shader_attrib_variable);

var _shader_attrib_value = __webpack_require__(65);

var _shader_attrib_value2 = _interopRequireDefault(_shader_attrib_value);

var _shader_variable_alias = __webpack_require__(66);

var _shader_variable_alias2 = _interopRequireDefault(_shader_variable_alias);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Group of shader variables which are referencing one single buffer.
 */
class ShaderVariableBufferGroup extends _shader_variable_group2.default {
  /**
   * @param {VOPool} bufferSource
   */
  constructor(bufferSource) {
    super([]);
    const descriptor = bufferSource.descriptor;
    let firstVar;
    Object.keys(descriptor.attr).forEach(attrName => {
      if (!firstVar) {
        firstVar = new _shader_attrib_variable2.default(attrName, new _shader_attrib_value2.default(attrName, descriptor, bufferSource));
        this.shaderVars.push(firstVar);
      } else {
        this.shaderVars.push(new _shader_variable_alias2.default(attrName, firstVar));
      }
    });
  }

  get bufferSource() {
    return this.shaderVars[0].value.bufferSource;
  }

  get serial() {
    return this.shaderVars[0].serial;
  }

  touch() {
    return this.shaderVars[0].touch();
  }
}
exports.default = ShaderVariableBufferGroup;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_variable = __webpack_require__(5);

var _shader_variable2 = _interopRequireDefault(_shader_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Shader attribute variable.
 */
class ShaderAttribVariable extends _shader_variable2.default {
  /**
   * @param {string} name
   * @param {number|Object} value
   */
  constructor(name, value) {
    super(name, _shader_variable2.default.TYPE.ATTRIB, value);
  }
}
exports.default = ShaderAttribVariable;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _v_o_array = __webpack_require__(7);

var _v_o_array2 = _interopRequireDefault(_v_o_array);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ShaderAttribValue {
  constructor(name, descriptor, bufferSource) {
    this.name = name;
    this.descriptor = descriptor;
    this.bufferSource = bufferSource;
  }

  get attrDescriptor() {
    return this.descriptor.attr[this.name];
  }

  get resourceRef() {
    const { bufferSource } = this;
    return bufferSource instanceof _v_o_array2.default ? bufferSource.resourceRef : bufferSource.voArray.resourceRef;
  }
}
exports.default = ShaderAttribValue;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Shader attribute variable *alias*.
 */
class ShaderVariableAlias {
  /**
   * @param {string} name
   * @param {number|Object} value
   */
  constructor(name, shaderVar) {
    this.name = name;
    this.shaderVar = shaderVar;
  }

  get type() {
    return this.shaderVar.type;
  }

  get value() {
    return this.shaderVar.value;
  }

  get serial() {
    return this.shaderVar.serial;
  }
}
exports.default = ShaderVariableAlias;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _create_vertex_objects = __webpack_require__(135);

var _create_vertex_objects2 = _interopRequireDefault(_create_vertex_objects);

var _generate_uuid = __webpack_require__(4);

var _generate_uuid2 = _interopRequireDefault(_generate_uuid);

var _v_o_array = __webpack_require__(7);

var _v_o_array2 = _interopRequireDefault(_v_o_array);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class VOPool {
  /**
   * @param {VODescriptor} descriptor - vertex object descriptor
   * @param {Object} [options] - Advanced options
   * @param {number} [options.capacity] - Maximum number of *vertex objects*
   * @param {VOArray} [options.voArray] - Vertex object array
   * @param {VertexObject} [options.voZero] - *vertex object* **prototype**
   * @param {VertexObject} [options.voNew] - *vertex object* **prototype**
   * @param {VertexObject} [options.maxAllocVOSize] - never allocate more than *maxAllocVOSize* vertex objects at once
   * @param {string} [options.usage=VOPool.USAGE.DYNAMIC] - vertex data usage hint
   */

  constructor(descriptor, options) {
    this.id = (0, _generate_uuid2.default)();

    this.descriptor = descriptor;
    this.capacity = options && options.capacity || this.descriptor.maxIndexedVOPoolSize;
    this.maxAllocVOSize = options && options.maxAllocVOSize || 0;

    this.usage = options && options.usage || VOPool.USAGE.DYNAMIC;

    let voArray = options && options.voArray;
    if (voArray) {
      if (voArray.usage !== this.usage) {
        throw new Error(`VOPool usage(=${this.usage}) mismatch with given voArray(usage=${voArray.usage})`);
      }
    } else {
      voArray = descriptor.createVOArray(this.capacity, this.usage);
    }
    this.voArray = voArray;

    this.voZero = options && options.voZero || descriptor.createVO();
    this.voNew = options && options.voNew || descriptor.createVO();

    this.availableVOs = [];
    this.usedVOs = [];

    (0, _create_vertex_objects2.default)(this, this.maxAllocVOSize);
  }

  /**
   * Number of in use *vertex objects*.
   * @type {number}
   */

  get usedCount() {
    return this.usedVOs.length;
  }

  /**
   * Number of free and unused *vertex objects*.
   * @type {number}
   */

  get availableCount() {
    return this.capacity - this.usedVOs.length;
  }

  /**
   * Number of **allocated** *vertex objects*.
   * @type {number}
   */

  get allocatedCount() {
    return this.availableVOs.length + this.usedVOs.length;
  }

  /**
   * Return **size** *vertex objects*
   * @return {VertexObject|VertexObject[]}
   */

  alloc(size = 1) {
    if (size > 1) {
      const arr = [];
      for (let i = 0; i < size; ++i) {
        const vo = this.alloc(1);
        if (vo !== undefined) {
          arr.push(vo);
        } else {
          break;
        }
      }
      return arr;
    }

    const vo = this.availableVOs.shift();

    if (vo === undefined) {
      if (this.capacity - this.allocatedCount > 0) {
        (0, _create_vertex_objects2.default)(this, this.maxAllocVOSize);
        return this.alloc();
      } else {
        return;
      }
    }

    this.usedVOs.push(vo);

    vo.voArray.copy(this.voNew.voArray);

    return vo;
  }

  /**
   * @param {VertexObject|VertexObject[]} vo - vertex object(s)
   */

  free(vo) {
    if (Array.isArray(vo)) {
      vo.forEach(_vo => _vo.free());
      return;
    }

    const idx = this.usedVOs.indexOf(vo);

    if (idx === -1) return;

    const lastIdx = this.usedVOs.length - 1;

    if (idx !== lastIdx) {
      const last = this.usedVOs[lastIdx];
      vo.voArray.copy(last.voArray);

      const tmp = last.voArray;
      last.voArray = vo.voArray;
      vo.voArray = tmp;

      this.usedVOs.splice(idx, 1, last);
    }

    this.usedVOs.pop();
    this.availableVOs.unshift(vo);

    vo.voArray.copy(this.voZero.voArray);
  }
}

exports.default = VOPool;
VOPool.USAGE = _v_o_array2.default.USAGE;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(28);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 70 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(176),
    isObjectLike = __webpack_require__(27);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

/**
 * Represents a 2d axis aligned boundary box.
 *
 * @class AABB2
 * @param {number} [x0=0] - x0
 * @param {number} [x1=0] - x1
 * @param {number} [y0=0] - y0
 * @param {number} [y1=0] - y1
 */

class AABB2 {
  constructor(x0 = 0, x1 = 0, y0 = 0, y1 = 0) {
    if (x0 < x1) {
      /**
       * @type {number}
       */
      this.minX = x0;
      /**
       * @type {number}
       */
      this.maxX = x1;
    } else {
      /**
       * @type {number}
       */
      this.minX = x1;
      /**
       * @type {number}
       */
      this.maxX = x0;
    }

    if (y0 < y1) {
      /**
       * @type {number}
       */
      this.minY = y0;
      /**
       * @type {number}
       */
      this.maxY = y1;
    } else {
      /**
       * @type {number}
       */
      this.minY = y1;
      /**
       * @type {number}
       */
      this.maxY = y0;
    }
  }

  /**
   * @type {number}
   */
  get width() {
    return this.maxX - this.minX + 1;
  }

  /**
   * @type {number}
   */
  get height() {
    return this.maxY - this.minY + 1;
  }

  /**
   * @type {number}
   */
  get centerX() {
    return (this.maxX - this.minX) / 2;
  }

  /**
   * @type {number}
   */
  get centerY() {
    return (this.maxY - this.minY) / 2;
  }

  /**
   * Extend the boundary box.
   *
   * @param {number} x - x
   * @param {number} y - y
   */
  addPoint(x, y) {
    if (x < this.minX) {
      this.minX = x;
    } else if (x > this.maxX) {
      this.maxX = x;
    }

    if (y < this.minY) {
      this.minY = y;
    } else if (y > this.maxY) {
      this.maxY = y;
    }
  }

  /**
   * Determinates wether or the 2d point is inside this AABB.
   *
   * @param {number} x - x
   * @param {number} y - y
   * @return {boolean} return true when point is inside the aabb
   */
  isInside(x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
  }

  /**
   * Determinates wether or not this AABB intersects *aabb*.
   *
   * @param {AABB2} aabb - aabb
   * @return {boolean} return true when there is some intersection between both
   */
  isIntersection(aabb) {
    return !(aabb.maxX < this.minX || aabb.minX > this.maxX || aabb.maxY < this.minY || aabb.minY > this.maxY);
  }
}
exports.default = AABB2;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31);


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = defineCustomElements;

var _CanvasElement = __webpack_require__(75);

var _CanvasElement2 = _interopRequireDefault(_CanvasElement);

var _SceneElement = __webpack_require__(129);

var _SceneElement2 = _interopRequireDefault(_SceneElement);

var _TextureAtlasElement = __webpack_require__(130);

var _TextureAtlasElement2 = _interopRequireDefault(_TextureAtlasElement);

var _SpriteGroupElement = __webpack_require__(134);

var _SpriteGroupElement2 = _interopRequireDefault(_SpriteGroupElement);

var _constants = __webpack_require__(0);

__webpack_require__(194);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Define all `<blitpunk-*>` custom html elements.
 * Should be called once at startup.
 */
function defineCustomElements() {
  // define element in the CustomElementRegistry
  window.customElements.define(_constants.DOM_ELEM_CANVAS, _CanvasElement2.default);
  window.customElements.define(_constants.DOM_ELEM_SCENE, _SceneElement2.default);
  window.customElements.define(_constants.DOM_ELEM_TEXTURE_ATLAS, _TextureAtlasElement2.default);
  window.customElements.define(_constants.DOM_ELEM_SPRITE_GROUP, _SpriteGroupElement2.default);
}

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _app = __webpack_require__(32);

var _app2 = _interopRequireDefault(_app);

var _blitpunk = __webpack_require__(31);

var _blitpunk2 = _interopRequireDefault(_blitpunk);

var _readBooleanAttribute = __webpack_require__(55);

var _readBooleanAttribute2 = _interopRequireDefault(_readBooleanAttribute);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global HTMLElement */
const eventize = __webpack_require__(1);

const createContextAttributes = el => ({
  alpha: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_ALPHA, false),
  depth: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_DEPTH, true), // ie 11 has no support for false
  stencil: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_STENCIL, false),
  antialias: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_ANTIALIAS, false),
  premultipliedAlpha: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_PREMULTIPLIED_ALPHA, false),
  preserveDrawingBuffer: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_PRESERVE_DRAW, false)
});

/**
 * The **custom HTML `<blitpunk-canvas></blitpunk-canvas>` element** represents the *webgl* canvas,
 * which acts also as the main API entrypoint for every *blitpunk* application.
 *
 * The size of the html element should be defined by css styles (eg. `display: block; width: 100%; height: 100%`) &mdash; without
 * any styles (or `display: inline`) the canvas will mimic the size of the parent element.
 *
 * You can customize the wegl context by specifying html attributes:
 * - `alpha`
 * - `depth`
 * - `stencil`
 * - `antialias`
 * - `premultiplied-alpha`
 * - `preserve-drawing-buffer`
 *
 * _ATTENTION:_ changing these html attributes has no effect *after* the webgl context is initialized!
 *
 * @example
 * <!DOCTYPE html>
 * <html>
 * <head>
 *   <title>fullscreen blitpunk canvas example</title>
 *   <meta name="viewport" content="width=device-width,initial-scale=1.0">
 *   <style>
 *     html, body {
 *       margin: 0;
 *       overflow: hidden;
 *       width: 100%;
 *       height: 100%;
 *     }
 *   </style>
 * </head>
 * <body>
 *   <blitpunk-canvas alpha antialias>
 *     ...
 *   </blitpunk-canvas>
 *   ...
 */
class CanvasElement extends HTMLElement {
  /** @ignore */
  constructor(_) {
    const self = super(_);
    eventize(self);
    self.blitpunk = new _app2.default();
    self.blitpunk.entity.on(self);
    return self;
  }

  get blitpunkApi() {
    return _blitpunk2.default;
  }
  get blitpunkNodeName() {
    return _constants.NODE_NAME_CANVAS;
  }

  get canvas() {
    return this.blitpunk.canvas;
  }
  get width() {
    return this.blitpunk.width;
  }
  get height() {
    return this.blitpunk.height;
  }

  get glx() {
    return this.blitpunk.glx;
  }
  get renderer() {
    return this.blitpunk.renderer;
  }
  get time() {
    return this.blitpunk.time;
  }
  get startTime() {
    return this.blitpunk.startTime;
  }
  get frameNo() {
    return this.blitpunk.frameNo;
  }

  get componentRegistry() {
    return this.blitpunk.componentRegistry;
  }
  get entityManager() {
    return this.blitpunk.entityManager;
  }
  get resourceLibrary() {
    return this.blitpunk.resourceLibrary;
  }
  get textureLibrary() {
    return this.blitpunk.textureLibrary;
  }

  get scene() {
    return this.blitpunk.entity;
  }

  /** @private */
  static get observedAttributes() {
    return [_constants.ATTR_BLEND_MODE, _constants.ATTR_CLEAR_COLOR, _constants.ATTR_PROJECTION];
  }

  /** @private */
  onKeydown(event) {
    if (event.ctrlKey && event.key === 'd') {
      console.group('<blitpunk/>', 'frameNo', this.frameNo);
      console.log(this);
      console.log(this.blitpunk);
      this.blitpunk.entity.emit('debug', this);
      this.renderer.emit('debug', this.renderer);
      console.groupEnd();
    }
  }

  set clearColor(color) {
    this.blitpunk.clearColor = color;
  }

  get clearColor() {
    const col = this.blitpunk.clearColor;
    if (col) {
      return col.getAlpha() === 1 ? col.toHexString() : col.toRgbString();
    }
  }

  /** @private */
  connectedCallback() {
    this.blitpunk.contextAttributes = Object.freeze(createContextAttributes(this));

    this.onKeydown = this.onKeydown.bind(this);
    document.body.addEventListener('keydown', this.onKeydown);

    this.blitpunk.start(this);

    // TODO check for onInit= attribute?
    // const src = this.getAttribute(ATTR_MODULE_SRC)
    // if (src) {
    // SystemJS.import(src).then((appModule) => {
    // appModule.default(this, Blitpunk)
    // TODO configure blitpunk dynamic package
    // TODO check for .init() method?
    // })
    // }
  }

  /** @private */
  disconnectedCallback() {
    this.blitpunk.destroy();

    document.body.removeEventListener('keydown', this.onKeydown);
  }

  /** @private */
  attributeChangedCallback(attr, oldValue, newValue) {
    switch (attr) {
      case _constants.ATTR_CLEAR_COLOR:
        this.clearColor = newValue;
        break;
      case _constants.ATTR_BLEND_MODE:
      case _constants.ATTR_PROJECTION:
        this.blitpunk.componentRegistry.createOrUpdateComponent(this.blitpunk.entity, attr, newValue);
    }
  }
}
exports.default = CanvasElement;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(77);
var bytesToUuid = __webpack_require__(78);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36)))

/***/ }),
/* 78 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createVO = createVO;

/** @private */
function createVO(obj, descriptor, voArray) {
  // set VODescriptor
  //
  obj.descriptor = descriptor || (voArray ? voArray.descriptor : null);

  if (!obj.descriptor) {
    throw new Error('could not detect VODescriptor!');
  }

  // set VOArray
  //
  obj.voArray = voArray || obj.descriptor.createVOArray();

  if (obj.descriptor !== obj.voArray.descriptor && (obj.descriptor.vertexCount !== obj.voArray.descriptor.vertexCount || obj.descriptor.vertexAttrCount !== obj.voArray.descriptor.vertexAttrCount)) {
    throw new Error('Incompatible vertex object descriptors!');
  }

  return obj;
}

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
class Serial {
  /**
   * @param {number} [initialValue=1]
   */
  constructor(initialValue = 1) {
    this.value = initialValue;
  }

  touch() {
    ++this.value;
  }
}
exports.default = Serial;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (descriptor, proto) {
  const propertiesObject = {

    toArray: {

      value: function (attrNames) {
        const arr = [];
        const attrList = Array.isArray(attrNames) ? attrNames.map(name => descriptor.attr[name]) : descriptor.attrList;
        const len = attrList.length;
        for (let i = 0; i < descriptor.vertexCount; ++i) {
          for (let j = 0; j < len; ++j) {
            const attr = attrList[j];
            for (let k = 0; k < attr.size; ++k) {
              arr.push(attr.getValue(this, i, k));
            }
          }
        }
        return arr;
      }

    }

  };

  Object.keys(descriptor.attr).forEach(name => {
    const attr = descriptor.attr[name];

    _v_o_attr_descriptor2.default.defineProperties(attr, propertiesObject, descriptor);
  });

  descriptor.voPrototype = Object.create(typeof proto === 'object' ? proto : {}, propertiesObject);
};

var _v_o_attr_descriptor = __webpack_require__(10);

var _v_o_attr_descriptor2 = _interopRequireDefault(_v_o_attr_descriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (descriptor) {
  descriptor.typedArrays = {
    float32: false,
    int16: false,
    int32: false,
    int8: false,
    uint16: false,
    uint32: false,
    uint8: false
  };

  Object.keys(descriptor.attr).forEach(name => {
    descriptor.typedArrays[descriptor.attr[name].type] = true;
  });

  Object.freeze(descriptor.typedArrays);

  descriptor.typeList = Object.keys(descriptor.typedArrays).filter(type => descriptor.typedArrays[type]).sort();
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (descriptor, attributes) {
  descriptor.attr = {};
  descriptor.attrNames = [];

  if (Array.isArray(attributes)) {
    let offset = 0;
    let byteOffset = 0;

    for (let i = 0; i < attributes.length; ++i) {
      const attr = attributes[i];

      if (attr.size === undefined) throw new Error('vertex object attribute descriptor has no size!');

      const type = attr.type || 'float32';

      if (attr.name !== undefined) {
        descriptor.attrNames.push(attr.name);
        descriptor.attr[attr.name] = new _v_o_attr_descriptor2.default(attr.name, type, attr.size, offset, byteOffset, !!attr.uniform, attr.attrNames);
      }

      offset += attr.size;
      byteOffset += _typed_array_helpers.BYTES_PER_ELEMENT[type] * attr.size;
    }

    // bytes per vertex is always aligned to 4-bytes!
    descriptor.rightPadBytesPerVertex = byteOffset % 4 > 0 ? 4 - byteOffset % 4 : 0;
    descriptor.bytesPerVertex = byteOffset + descriptor.rightPadBytesPerVertex;
    descriptor.bytesPerVO = descriptor.bytesPerVertex * descriptor.vertexCount;
    descriptor.vertexAttrCount = offset;
  }

  descriptor.attrList = descriptor.attrNames.map(name => descriptor.attr[name]);
};

var _typed_array_helpers = __webpack_require__(9);

var _v_o_attr_descriptor = __webpack_require__(10);

var _v_o_attr_descriptor2 = _interopRequireDefault(_v_o_attr_descriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (descriptor, aliases) {
  if (typeof aliases !== 'object') return;

  Object.keys(aliases).forEach(name => {
    let attr = aliases[name];

    if (typeof attr === 'string') {
      attr = descriptor.attr[attr];

      if (attr !== undefined) {
        descriptor.attr[name] = attr;
      }
    } else {
      descriptor.attr[name] = new _v_o_attr_descriptor2.default(name, attr.type, attr.size, attr.offset, attr.byteOffset, !!attr.uniform, attr.attrNames);
    }
  });
};

var _v_o_attr_descriptor = __webpack_require__(10);

var _v_o_attr_descriptor2 = _interopRequireDefault(_v_o_attr_descriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (spriteLibrary) {
  spriteLibrary.addDescriptor('simple', simple.description).addVertexShader('simple', simple.vertexShader).addFragmentShader('simple', simple.fragmentShader);
};

var _simple = __webpack_require__(86);

var simple = _interopRequireWildcard(_simple);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.description = exports.fragmentShader = exports.vertexShader = undefined;

var _rotate = __webpack_require__(87);

var _rotate2 = _interopRequireDefault(_rotate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const vertexShader = exports.vertexShader = [`

  attribute vec2 pos2d;
  attribute float posZ;
  attribute vec2 uv;
  attribute vec2 translate;
  attribute float rotate;
  attribute float scale;
  attribute float opacity;

  uniform mat4 viewMatrix;

  varying vec4 vTextureCoordScaleOpacity;

  `, (0, _rotate2.default)('rotateZ', 0.0, 0.0, 1.0), `

  void main(void)
  {
    mat4 rotationMatrix = rotateZ(rotate);
    gl_Position = viewMatrix * ((rotationMatrix * (vec4(scale, scale, scale, 1.0) * vec4(pos2d.xy, posZ, 1.0))) + vec4(translate.xy, 0.0, 0.0));
    vTextureCoordScaleOpacity = vec4(uv.xy, opacity, 0.0);
  }
`];

const fragmentShader = exports.fragmentShader = `

  precision mediump float;

  varying vec4 vTextureCoordScaleOpacity;
  uniform sampler2D tex;

  void main(void) {
    gl_FragColor = vTextureCoordScaleOpacity.z * texture2D(tex, vec2(vTextureCoordScaleOpacity.s, vTextureCoordScaleOpacity.t));
  }

`;

const description = exports.description = {
  vertexCount: 4,

  // +-+-+-+-+ +-+-+-+-+ +-+-+
  // |0|1|2|3| |4|5|6|7| |8|9|
  // +-+-+-+-+ +-+-+-+-+ +-+-+
  //
  // |o-o-o|                       (3) position: x,y,z
  //       |o|                     (1) rotate
  //           |o-o|               (2) tex-coords: s, t
  //               |o-o|           (3) translate: tx, ty
  //                     |o|       (1) scale
  //                       |o|     (1) opacity
  //

  attributes: [{ name: 'position', type: 'float32', size: 3, attrNames: ['x', 'y', 'z'] }, { name: 'rotate', type: 'float32', size: 1, uniform: true }, { name: 'texCoords', type: 'float32', size: 2, attrNames: ['s', 't'] }, { name: 'translate', type: 'float32', size: 2, attrNames: ['tx', 'ty'], uniform: true }, { name: 'scale', type: 'float32', size: 1, uniform: true }, { name: 'opacity', type: 'float32', size: 1, uniform: true }],

  aliases: {
    pos2d: { size: 2, type: 'float32', offset: 0 },
    posZ: { size: 1, type: 'float32', offset: 2, uniform: true },
    uv: 'texCoords'
  },

  proto: {
    /**
     * @param {Viewport} viewport
     * @param {number} textureWidth
     * @param {number} textureHeight
     * @param {number} [repeat] - texture repeat factor
     */
    setTexCoordsByViewport(viewport, textureWidth, textureHeight, repeat) {
      let x0 = viewport.x === 0 ? 0 : viewport.x / textureWidth;
      let x1 = (viewport.x + viewport.width) / textureWidth;
      let y0 = 1 - (viewport.y + viewport.height) / textureHeight;
      let y1 = viewport.y === 0 ? 1 : 1 - viewport.y / textureHeight;

      if (repeat !== undefined) {
        x0 *= repeat;
        x1 *= repeat;
        y0 *= repeat;
        y1 *= repeat;
      }

      this.setTexCoords(x0, y0, x1, y0, x1, y1, x0, y1);
    },

    /**
     * @param {Texture} texture
     */
    setTexCoordsByTexture(texture) {
      const x0 = texture.minS;
      const y0 = texture.minT;
      const x1 = texture.maxS;
      const y1 = texture.maxT;

      this.setTexCoords(x0, y0, x1, y0, x1, y1, x0, y1);
    },

    /**
     * @param {number} width
     * @param {number} height
     */
    setSize(width, height) {
      const halfWidth = width * 0.5;
      const halfHeight = (height == null ? width : height) * 0.5;

      this.setPos2d(-halfWidth, halfHeight, halfWidth, halfHeight, halfWidth, -halfHeight, -halfWidth, -halfHeight);
    },

    get width() {
      return this.x1 - this.x3;
    },

    get height() {
      return this.y0 - this.y2;
    },

    get rotateDegree() {
      return this.rotate * 180.0 / Math.PI;
    },

    set rotateDegree(degree) {
      this.rotate = degree * (Math.PI / 180.0);
    },

    get z() {
      return this.z0;
    },

    set z(z) {
      this.z0 = z;
      this.z1 = z;
      this.z2 = z;
      this.z3 = z;
    }
  }
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (funcName = 'rotate', x = 0.0, y = 0.0, z = 1.0) {
  return [`mat4 ${funcName}(float angle) {`, 'float s = sin(angle);', 'float c = cos(angle);', 'float oc = 1.0 - c;', (0, _ret2.default)((0, _mat2.default)((0, _add2.default)((0, _mul2.default)('oc', x * x), 'c'), (0, _sub2.default)((0, _mul2.default)('oc', x * y), (0, _mul2.default)(z, 's')), (0, _add2.default)((0, _mul2.default)('oc', z * x), (0, _mul2.default)(y, 's')), 0, (0, _add2.default)((0, _mul2.default)('oc', x * y), (0, _mul2.default)(z, 's')), (0, _add2.default)((0, _mul2.default)('oc', y * y), 'c'), (0, _sub2.default)((0, _mul2.default)('oc', y * z), (0, _mul2.default)(x, 's')), 0, (0, _sub2.default)((0, _mul2.default)('oc', z * x), (0, _mul2.default)(y, 's')), (0, _add2.default)((0, _mul2.default)('oc', y * z), (0, _mul2.default)(x, 's')), (0, _add2.default)((0, _mul2.default)('oc', z * z), 'c'))), '}'];
};

var _ret = __webpack_require__(88);

var _ret2 = _interopRequireDefault(_ret);

var _mat = __webpack_require__(89);

var _mat2 = _interopRequireDefault(_mat);

var _mul = __webpack_require__(91);

var _mul2 = _interopRequireDefault(_mul);

var _sub = __webpack_require__(92);

var _sub2 = _interopRequireDefault(_sub);

var _add = __webpack_require__(93);

var _add2 = _interopRequireDefault(_add);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = ret;
function ret(res) {
  return `return ${res};`;
}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = mat4;

var _as_float = __webpack_require__(90);

var _as_float2 = _interopRequireDefault(_as_float);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mat4(m00 = 0, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 0, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 0, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1, as = _as_float2.default) {
                              const toStr = as || (x => x + '');
                              return `mat4(${toStr(m00)}, ${toStr(m01)}, ${toStr(m02)}, ${toStr(m03)}, ${toStr(m10)}, ${toStr(m11)}, ${toStr(m12)}, ${toStr(m13)}, ${toStr(m20)}, ${toStr(m21)}, ${toStr(m22)}, ${toStr(m23)}, ${toStr(m30)}, ${toStr(m31)}, ${toStr(m32)}, ${toStr(m33)})`;
}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (number) {
  const str = (number + '').trim();
  if (str.match(/^[0-9]+$/)) {
    return str + '.0';
  }
  return str;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function isNumber(x) {
  return typeof x === 'number';
}

exports.default = (a, b) => {
  if (isNumber(b) && isNumber(a)) {
    return a * b;
  } else if (isNumber(a)) {
    switch (a) {
      case 0:
        return 0;
      case 1:
        return b;
      default:
        return `${a} * ${b}`;
    }
  } else if (isNumber(b)) {
    switch (b) {
      case 0:
        return 0;
      case 1:
        return a;
      default:
        return `${a} * ${b}`;
    }
  } else {
    return `${a} * ${b}`;
  }
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = sub;

function isNumber(x) {
  return typeof x === 'number';
}

function sub(a, b) {
  if (isNumber(a) && isNumber(b)) {
    return a - b;
  } else if (isNumber(a)) {
    switch (a) {
      case 0:
        return `-${b}`;
      default:
        return `${a} - ${b}`;
    }
  } else if (isNumber(b)) {
    switch (b) {
      case 0:
        return a;
      default:
        return `${a} - ${b}`;
    }
  } else {
    return `${a} - ${b}`;
  }
}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = add;

function isNumber(x) {
  return typeof x === 'number';
}

function add(a, b) {
  if (isNumber(a) && isNumber(b)) {
    return a + b;
  } else if (isNumber(a)) {
    switch (a) {
      case 0:
        return b;
      default:
        return `${a} + ${b}`;
    }
  } else if (isNumber(b)) {
    switch (b) {
      case 0:
        return a;
      default:
        return `${a} + ${b}`;
    }
  } else {
    return `${a} + ${b}`;
  }
}

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _web_gl_resource_library = __webpack_require__(95);

var _web_gl_resource_library2 = _interopRequireDefault(_web_gl_resource_library);

var _web_gl_texture_manager = __webpack_require__(102);

var _web_gl_texture_manager2 = _interopRequireDefault(_web_gl_texture_manager);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WebGlContext {
  constructor(gl) {
    Object.defineProperty(this, 'gl', { value: gl });

    initialize(this);

    this.resourceLibrary = new _web_gl_resource_library2.default(this);
    this.boundBuffers = new Map();
    this.currentProgram = 0;
    this.enabledVertexAttribLocations = [];

    this.textureManager = new _web_gl_texture_manager2.default(this);

    this.boundTextures = new Array(this.MAX_TEXTURE_IMAGE_UNITS);
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = { TEXTURE_2D: null };
    }

    this.readCurrentState();
    this.activeTexture(0); // enable first texture unit by default
  }

  destroy() {
    this.textureManager.destroy();
    this.boundBuffers.clear();
    this.resourceLibrary.destroy();
    (0, _destroy2.default)(this);
  }

  /**
   * @param {BlendMode} blendMode
   */
  blend(blendMode) {
    const { gl } = this;
    if (blendMode.enable) {
      if (!this.blendEnabled) {
        gl.enable(gl.BLEND);
        this.blendEnabled = true;
      }
      gl.blendFunc(gl[blendMode.sfactor], gl[blendMode.dfactor]);
    } else if (this.blendEnabled) {
      gl.disable(gl.BLEND);
      this.blendEnabled = false;
    }
  }

  /**
   * @param {number} texUnit
   */
  activeTexture(texUnit) {
    const { gl } = this;
    const tex = gl.TEXTURE0 + texUnit;

    if (this.activeTexUnit !== tex) {
      this.activeTexUnit = tex;
      gl.activeTexture(this.activeTexUnit);
    }
  }

  /**
   * @param {number} glTextureId
   */
  bindTexture2d(glTextureId) {
    const { gl } = this;
    const bound = this.boundTextures[this.activeTexUnit - gl.TEXTURE0];

    if (bound.TEXTURE_2D !== glTextureId) {
      bound.TEXTURE_2D = glTextureId;
      gl.bindTexture(gl.TEXTURE_2D, glTextureId);
    }
  }

  readCurrentState() {
    const { gl } = this;

    // https://developer.mozilla.org/de/docs/Web/API/WebGLRenderingContext/getParameter

    this.boundBuffers.set(gl.ARRAY_BUFFER, gl.getParameter(gl.ARRAY_BUFFER_BINDING));
    this.boundBuffers.set(gl.ELEMENT_ARRAY_BUFFER, gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING));

    this.currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    this.blendEnabled = gl.getParameter(gl.BLEND);
  }

  bindBuffer(target, buffer) {
    if (this.boundBuffers.get(target) !== buffer) {
      this.gl.bindBuffer(target, buffer);
      this.boundBuffers.set(target, buffer);
    }
  }

  /**
   * @return {boolean}
   */
  useProgram(glProgram) {
    if (this.currentProgram !== glProgram) {
      this.gl.useProgram(glProgram);
      this.currentProgram = glProgram;
      return true;
    }
    return false;
  }

  enableVertexAttribArrays(enableLocations) {
    const { gl } = this;

    this.enabledVertexAttribLocations.filter(location => enableLocations.indexOf(location) === -1).forEach(location => {
      gl.disableVertexAttribArray(location);
      this.enabledVertexAttribLocations.splice(enableLocations.indexOf(location), 1);
    });

    enableLocations.forEach(loc => {
      const idx = this.enabledVertexAttribLocations.indexOf(loc);
      if (idx === -1) {
        gl.enableVertexAttribArray(loc);
        this.enabledVertexAttribLocations.push(loc);
      }
    });
  }
}

exports.default = WebGlContext; /** @private */

function initialize(glx) {
  const { gl } = glx;

  glx.DEPTH_BITS = gl.getParameter(gl.DEPTH_BITS);
  glx.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _resource_ref = __webpack_require__(8);

var _resource_ref2 = _interopRequireDefault(_resource_ref);

var _web_gl_shader = __webpack_require__(96);

var _web_gl_shader2 = _interopRequireDefault(_web_gl_shader);

var _web_gl_program = __webpack_require__(98);

var _web_gl_program2 = _interopRequireDefault(_web_gl_program);

var _web_gl_buffer = __webpack_require__(44);

var _web_gl_buffer2 = _interopRequireDefault(_web_gl_buffer);

var _web_gl_texture = __webpack_require__(101);

var _web_gl_texture2 = _interopRequireDefault(_web_gl_texture);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WEB_GL_BUFFER_USAGE = Object.freeze({
  static: _web_gl_buffer2.default.STATIC_DRAW,
  dynamic: _web_gl_buffer2.default.DYNAMIC_DRAW
});

class WebGlResourceLibrary {
  constructor(glx) {
    Object.defineProperty(this, 'glx', { value: glx });

    /** @private */
    this.vertexShader = new Map();
    /** @private */
    this.fragmentShader = new Map();
    /** @private */
    this.shaderProgram = new Map();
    /** @private */
    this.buffer = new Map();
    /** @private */
    this.texture = new Map();
  }

  destroy() {
    this.texture.clear();
    this.buffer.clear();
    this.shaderProgram.clear();
    this.fragmentShader.clear();
    this.vertexShader.clear();
    (0, _destroy2.default)(this);
  }

  loadVertexShader(shaderSource) {
    let glShader = this.vertexShader.get(shaderSource.id);
    if (!glShader) {
      glShader = new _web_gl_shader2.default(this.glx, shaderSource);
      this.vertexShader.set(shaderSource.id, glShader);
    }
    return glShader;
  }

  loadFragementShader(shaderSource) {
    let glShader = this.fragmentShader.get(shaderSource.id);
    if (!glShader) {
      glShader = new _web_gl_shader2.default(this.glx, shaderSource);
      this.vertexShader.set(shaderSource.id, glShader);
    }
    return glShader;
  }

  loadProgram(shaderProgram) {
    let program = this.shaderProgram.get(shaderProgram.id);
    if (!program) {
      program = new _web_gl_program2.default(this.glx, shaderProgram);
      this.shaderProgram.set(shaderProgram.id, program);
    }
    return program;
  }

  /**
   * @param {ResourceRef} ref - resource reference to VOArray or `ElementIndexArray`
   * @returns {ResourceRef} resource reference to `WebGlBuffer`
   */
  loadBuffer(ref) {
    let bufferRef = this.buffer.get(ref.id);
    if (!bufferRef) {
      // create WebGlBuffer
      const target = ref.hints.target || _web_gl_buffer2.default.ARRAY_BUFFER;
      const glBuffer = new _web_gl_buffer2.default(this.glx, target, WEB_GL_BUFFER_USAGE[ref.hints.usage]);
      // create ResourceRef
      bufferRef = new _resource_ref2.default(glBuffer, { id: ref.id, serial: 0 });
      this.buffer.set(ref.id, bufferRef);
    }
    return bufferRef;
  }

  /**
   * @param {ResourceRef} resourceRef
   * @returns {ResourceRef} resource reference to WebGlBuffer
   */
  findBuffer(resourceRef) {
    return this.buffer.get(resourceRef.id);
  }

  /**
   * @param {ResourceRef} texRef - resource reference to texture
   * @returns {ResourceRef} resource reference to WebGlTexture
   */
  loadTexture(texRef) {
    let glTextureRef = this.texture.get(texRef.id);
    if (!glTextureRef) {
      // create WebGlTexture
      const glTex = new _web_gl_texture2.default(this.glx, texRef.resource.imgEl, texRef.hints.flipY, texRef.hints.repeatable, texRef.hints.premultiplyAlpha, texRef.hints.nearest);
      // create ResourceRef
      glTextureRef = new _resource_ref2.default(glTex, { id: texRef.id, serial: 0 });
      this.texture.set(texRef.id, glTextureRef);
    }
    return glTextureRef;
  }
}
exports.default = WebGlResourceLibrary;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_source = __webpack_require__(19);

var _shader_source2 = _interopRequireDefault(_shader_source);

var _source_to_str = __webpack_require__(97);

var _source_to_str2 = _interopRequireDefault(_source_to_str);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WebGlShader {
  constructor(glx, source) {
    this.glx = glx;

    if (!(source instanceof _shader_source2.default)) {
      throw new Error('WebGlShader panic! source must be an instance of ShaderSource!');
    }
    this.source = source;

    const { gl } = glx;
    this.shaderType = gl[source.type];

    this.glShader = gl.createShader(this.shaderType);
    compileShader(this);

    Object.freeze(this);
  }
}

exports.default = WebGlShader;
function compileShader(shader) {
  const { gl } = shader.glx;
  const { glShader, source } = shader;

  const src = (0, _source_to_str2.default)({ glx: shader.glx }, source.source);

  gl.shaderSource(glShader, src);
  gl.compileShader(glShader);

  if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
    const shaderInfoLog = gl.getShaderInfoLog(glShader);

    console.error(shaderInfoLog);
    console.group('shader-info');
    console.debug('shaderSource', shader);
    console.log(source);
    console.groupEnd();

    const err = new Error('WebGlShader compile panic!');
    err.webGlShader = shader;
    err.shaderInfoLog = shaderInfoLog;
    throw err;
  }
}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = sourceToStr;
function sourceToStr(ctx, source) {
  if (typeof source === 'string') {
    return source;
  } else if (typeof source === 'function') {
    return sourceToStr(ctx, source(ctx));
  } else if (Array.isArray(source)) {
    return source.map(sourceToStr.bind(null, ctx)).join('\n');
  } else {
    return source + '';
  }
}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _web_gl_uniform = __webpack_require__(99);

var _web_gl_uniform2 = _interopRequireDefault(_web_gl_uniform);

var _web_gl_attribute = __webpack_require__(100);

var _web_gl_attribute2 = _interopRequireDefault(_web_gl_attribute);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WebGlProgram {
  constructor(glx, shaderProgram) {
    this.glx = glx;

    this.vertexShader = glx.resourceLibrary.loadVertexShader(shaderProgram.vertexShader);
    this.fragmentShader = glx.resourceLibrary.loadFragementShader(shaderProgram.fragmentShader);

    const { gl } = glx;
    this.glProgram = gl.createProgram();

    linkProgram(this, this.vertexShader.glShader, this.fragmentShader.glShader);
    // TODO gl.deleteShader?

    createUniforms(this);
    createAttributes(this);

    Object.freeze(this);
  }

  /**
   * @return {boolean}
   */
  use() {
    const { glx } = this;
    if (glx.useProgram(this.glProgram)) {
      glx.enableVertexAttribArrays(this.attributeLocations);
      return true;
    }
    return false;
  }

  /**
   * @param {ShaderContext} shaderContext
   * @param {WebGlRenderer} renderer
   */
  loadUniforms(shaderContext, renderer) {
    this.uniformNames.forEach(name => {
      let shaderVar = shaderContext.curUniform(name);
      if (shaderVar == null) {
        shaderVar = shaderContext.curTex2d(name);
        if (shaderVar == null) {
          console.error('[WebGlProgram] could not load uniform:', name);
        }
        shaderVar.syncTextureAndValue(renderer);
      }
      this.uniforms[name].setValue(shaderVar.value);
    });
  }

  /**
   * sync buffer before load
   *
   * @param {ShaderContext} shaderContext
   * @param {WebGlRenderer} renderer
   */
  loadAttributes(shaderContext, renderer) {
    this.attributeNames.forEach(name => {
      const attribValue = shaderContext.curAttrib(name).value;
      renderer.syncBuffer(attribValue).bindBuffer();
      this.attributes[name].vertexAttribPointer(attribValue.descriptor);
    });
  }
}

exports.default = WebGlProgram; /** @private */

function createAttributes(program) {
  const { gl } = program.glx;
  const len = gl.getProgramParameter(program.glProgram, gl.ACTIVE_ATTRIBUTES);

  program.attributes = {};
  program.attributeNames = [];
  program.attributeLocations = [];

  for (let i = 0; i < len; ++i) {
    const attrib = new _web_gl_attribute2.default(program, i);
    program.attributes[attrib.name] = attrib;
    program.attributeNames.push(attrib.name);
    program.attributeLocations.push(attrib.location);
  }

  Object.freeze(program.attributes);
}

/** @private */
function createUniforms(program) {
  const { gl } = program.glx;
  const len = gl.getProgramParameter(program.glProgram, gl.ACTIVE_UNIFORMS);

  program.uniforms = {};
  program.uniformNames = [];

  for (let i = 0; i < len; ++i) {
    const uniform = new _web_gl_uniform2.default(program, i);
    program.uniforms[uniform.name] = uniform;
    program.uniformNames.push(uniform.name);
  }

  Object.freeze(program.uniforms);
}

/** @private */
function linkProgram(program, vertexShader, fragmentShader) {
  const { gl } = program.glx;
  const { glProgram } = program;

  gl.attachShader(glProgram, vertexShader);
  gl.attachShader(glProgram, fragmentShader);

  gl.linkProgram(glProgram);

  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
    const err = new Error('WebGlProgram link panic!');
    err.webGlProgram = program;
    throw err;
  }
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
class WebGlUniform {
  constructor(program, index) {
    this.program = program;
    this.glx = program.glx;

    const { gl } = program.glx;
    const { glProgram } = program;

    const { name, size, type } = gl.getActiveUniform(glProgram, index);
    this.name = name;
    this.size = size;
    this.type = type;

    this.location = gl.getUniformLocation(glProgram, name);

    this.setValue = uniformSetter(this);

    Object.freeze(this);
  }
}

exports.default = WebGlUniform;
function uniformSetter(uniform) {
  const { type, location } = uniform;
  const { gl } = uniform.glx;

  switch (type) {
    case gl.FLOAT:
      return value => gl.uniform1f(location, value);

    case gl.FLOAT_VEC2:
      return value => gl.uniform2f(location, value[0], value[1]);

    case gl.FLOAT_VEC3:
      return value => gl.uniform3f(location, value[0], value[1], value[2]);

    case gl.FLOAT_VEC4:
      return value => gl.uniform4f(location, value[0], value[1], value[2], value[3]);

    case gl.FLOAT_MAT4:
      return value => gl.uniformMatrix4fv(location, gl.FALSE, value.mat4);

    case gl.SAMPLER_2D:
      return value => gl.uniform1i(location, value);
  }

  const err = new Error(`WebGlUniform unknown uniform type:${type}`);
  err.webGlUniform = uniform;
  throw err;
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typed_array_helpers = __webpack_require__(9);

const glType = (gl, type) => gl[_typed_array_helpers.GL_ITEM_TYPES[type]];

class WebGlAttribute {
  constructor(program, index) {
    this.program = program;
    this.glx = program.glx;

    const { gl } = program.glx;
    const { glProgram } = program;

    const { name, size, type } = gl.getActiveAttrib(glProgram, index);
    this.name = name;
    this.size = size;
    this.type = type;

    this.location = gl.getAttribLocation(glProgram, name);

    Object.freeze(this);
  }

  /**
   * @param {VODescriptor} descriptor
   */
  vertexAttribPointer(descriptor) {
    const { gl } = this.glx;
    const attr = descriptor.attr[this.name];
    const type = glType(gl, attr.type);
    gl.vertexAttribPointer(this.location, attr.size, type, false, descriptor.bytesPerVertex, attr.byteOffset);
  }
}
exports.default = WebGlAttribute;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
class WebGlTexture {
  /**
   * @param {WebGlContext} glx
   * @param {HTMLImageElement} imgEl
   * @param {boolean} [flipY=false]
   * @param {boolean} [repeatable=false]
   * @param {boolean} [premultiplyAlpha=false]
   * @param {boolean} [nearest=false]
   */
  constructor(glx, imgEl, flipY = false, repeatable = false, premultiplyAlpha = false, nearest = false) {
    this.glx = glx;
    this.imgEl = imgEl;

    this.flipY = flipY;
    this.repeatable = repeatable;
    this.premultiplyAlpha = premultiplyAlpha;
    this.nearest = nearest;

    this.isInitialized = false;
    this.glTexObj = glx.gl.createTexture();
    this.texUnit = -1;
  }

  bind() {
    return this.glx.textureManager.bindWebGlTexture(this);
  }

  uploadImageData() {
    if (this.imgEl == null) return;
    if (!this.isInitialized) {
      initialize(this);
      this.isInitialized = true;
    }

    this.bind();

    const { gl } = this.glx;
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.imgEl);
  }
}

exports.default = WebGlTexture;
function initialize(tex) {
  tex.bind();

  const { gl } = tex.glx;

  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, tex.flipY);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, tex.premultiplyAlpha);

  const wrap = tex.repeatable ? gl.REPEAT : gl.CLAMP_TO_EDGE;
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);

  const filter = tex.nearest ? gl.NEAREST : gl.LINEAR;
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tex.imgEl.width, tex.imgEl.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WebGlTextureManager {
  /**
   * @param {WebGlContext} glx
   */
  constructor(glx) {
    Object.defineProperty(this, 'glx', { value: glx });

    /**
     * texUnit -> WebGlTexture
     * @type {Array<number>}
     */
    this.boundTextures = new Array(glx.MAX_TEXTURE_IMAGE_UNITS);

    for (let i = 0; i < this.boundTextures.length; ++i) {
      this.boundTextures[i] = null;
    }

    this.lastBoundTexUnit = 0;
  }

  destroy() {
    this.boundTextures.length = 0;
    (0, _destroy2.default)(this);
  }

  /**
   * Bind a *texture* to a *texture unit*.
   * @param {WebGlTexture} glTexture
   * @return {number} texture unit
   */
  bindWebGlTexture(glTexture) {
    let texUnit = this.boundTextures.indexOf(glTexture);

    if (texUnit < 0) {
      // texture is unbound
      // find a free texture unit ..
      for (let i = 0; i < this.boundTextures.length; ++i) {
        if (!this.boundTextures[i]) {
          texUnit = i;
          this.boundTextures[i] = glTexture;
          break;
        }
      }

      if (texUnit < 0) {
        // no free texture found
        // so we choose the lru texture unit

        texUnit = this.lastBoundTexUnit;

        let prevGlTex = this.boundTextures[texUnit];
        if (prevGlTex) prevGlTex.texUnit = -1;

        this.lastBoundTexUnit = (this.lastBoundTexUnit + 1) % this.glx.MAX_TEXTURE_IMAGE_UNITS;
      }

      this.glx.activeTexture(texUnit);
      this.glx.bindTexture2d(glTexture.glTexObj);

      glTexture.texUnit = texUnit;
    }

    return texUnit;
  }
}
exports.default = WebGlTextureManager;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _shader_context = __webpack_require__(45);

var _shader_context2 = _interopRequireDefault(_shader_context);

var _destroy = __webpack_require__(2);

var _destroy2 = _interopRequireDefault(_destroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const eventize = __webpack_require__(1);
const tinycolor = __webpack_require__(46);

const autotouchBuffer = (renderer, resourceRef) => {
  const { resource } = resourceRef;
  if (resource.enableAutotouch) {
    if (!renderer.autotouchResources.has(resourceRef.id)) {
      renderer.autotouchResources.set(resourceRef.id, true);
      resource.touch();
    }
  }
};

const applyBlendMode = renderer => {
  const blendMode = renderer.blendStack[renderer.blendStack.length - 1] || renderer.initialBlendMode;
  if (blendMode && !blendMode.isEqual(renderer.currentBlendMode)) {
    renderer.glx.blend(blendMode);
    renderer.currentBlendMode = blendMode;
  }
};

class WebGlRenderer {
  constructor(glx) {
    Object.defineProperty(this, 'glx', { value: glx });

    this.shaderContext = new _shader_context2.default();
    this.autotouchResources = new Map();
    this.clearColor = null;
    this.blendStack = [];
    this.initialBlendMode = null;
    this.currentBlendMode = null;

    eventize(this);
  }

  destroy() {
    this.shaderContext.destroy();
    this.autotouchResources.clear();
    this.blendStack.length = 0;
    (0, _destroy2.default)(this);
  }

  /**
   * Set the framebuffer clear color.
   * Use the *tinycolor* library for css color conversion.
   *
   * @param {String} col - css color definition
   */
  setClearColor(col) {
    this.clearColor = tinycolor(col);
  }

  /**
   * Set the initial blend mode.
   *
   * @param {BlendMode} blendMode
   */
  setInitialBlendMode(blendMode) {
    this.initialBlendMode = blendMode;
  }

  renderFrame(scene, app) {
    this.shaderContext.clear();
    scene.emit('animateFrame', app);
    this.beginRenderFrame();
    scene.emit('renderFrame', this, app);
    this.endRenderFrame();
  }

  beginRenderFrame() {
    this.clearFrameBuffer();
  }

  endRenderFrame() {
    this.autotouchResources.clear();
  }

  clearFrameBuffer() {
    const { gl } = this.glx;

    let clear = gl.COLOR_BUFFER_BIT;
    if (this.glx.DEPTH_BITS > 0) clear = clear | gl.DEPTH_BUFFER_BIT;

    if (this.clearColor !== null) {
      const col = this.clearColor.toRgb();
      gl.clearColor(col.r / 255, col.g / 255, col.b / 255, col.a);
    }
    gl.clear(clear);
  }

  /**
   * Push a new blend mode to the stack.
   *
   * @param {BlendMode} blendMode
   */
  pushBlendMode(blendMode) {
    this.blendStack.push(blendMode);
  }

  /**
   * Remove the current blend mode from internal stack.
   * The initial blend mode can't be removed.
   */
  popBlendMode() {
    this.blendStack.pop();
  }

  /**
   * @param {ShaderProgram} shaderProgram
   */
  useShaderProgram(shaderProgram) {
    const program = this.glx.resourceLibrary.loadProgram(shaderProgram);
    const { shaderContext } = this;
    program.use(shaderContext);
    program.loadUniforms(shaderContext, this);
    program.loadAttributes(shaderContext, this);
  }

  /**
   * @param {string} primitive
   * @param {number} count
   * @param {number} [startIndex=0]
   */
  drawArrays(primitive, count, startIndex = 0) {
    applyBlendMode(this);

    const { gl } = this.glx;
    gl.drawArrays(gl[primitive], startIndex, count);
  }

  /**
   * @param {string} primitive
   * @param {ElementIndexArray} elementIndexArray
   * @param {number} [count]
   * @param {number} [offset=0]
   */
  drawIndexed(primitive, elementIndexArray, count, offset = 0) {
    applyBlendMode(this);
    this.syncBuffer(elementIndexArray).bindBuffer();

    const { gl } = this.glx;
    gl.drawElements(gl[primitive], count || elementIndexArray.length, gl.UNSIGNED_SHORT, offset * elementIndexArray.array.BYTES_PER_ELEMENT);
  }

  /**
   * @param {VOArray|ElementIndexArray} resource
   * @return {WebGlBuffer}
   */
  syncBuffer(resource) {
    const { resourceRef } = resource;
    autotouchBuffer(this, resourceRef);

    const bufferRef = this.glx.resourceLibrary.loadBuffer(resourceRef);
    bufferRef.sync(resourceRef, buffer => buffer.bufferData(resourceRef.hints.typedArray));
    return bufferRef.resource;
  }

  /**
   * @param {Texture} texture
   * @return {WebGlTexture}
   */
  syncTexture(texture) {
    const texRef = texture.resourceRef;
    const glTexRef = this.glx.resourceLibrary.loadTexture(texRef);
    glTexRef.sync(texRef, tex => tex.uploadImageData());
    return glTexRef.resource;
  }
}
exports.default = WebGlRenderer;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (registry) {
  registry.registerComponent('projection', createFactory(_ProjectionComponent2.default));
  registry.registerComponent('children', createFactory(_ChildrenComponent2.default));
  registry.registerComponent('blend-mode', createFactory(_BlendModeComponent2.default));
};

var _parseCssStyledProperties = __webpack_require__(13);

var _parseCssStyledProperties2 = _interopRequireDefault(_parseCssStyledProperties);

var _ProjectionComponent = __webpack_require__(105);

var _ProjectionComponent2 = _interopRequireDefault(_ProjectionComponent);

var _ChildrenComponent = __webpack_require__(112);

var _ChildrenComponent2 = _interopRequireDefault(_ChildrenComponent);

var _BlendModeComponent = __webpack_require__(113);

var _BlendModeComponent2 = _interopRequireDefault(_BlendModeComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const createFactory = ComponentConstructor => ({
  create(entity, data) {
    return new ComponentConstructor(entity, (0, _parseCssStyledProperties2.default)(data));
  },
  update(component, data) {
    component.update((0, _parseCssStyledProperties2.default)(data));
  }
});

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _projection = __webpack_require__(47);

var _projection2 = _interopRequireDefault(_projection);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ProjectionComponent {
  constructor(entity, data) {
    this.projection = new _projection2.default(data);
    entity.on('*', _constants.COMP_PRIO_PROJECTION, this);
  }

  animateFrame(app) {
    this.projection.update(app.width, app.height);
  }

  renderFrame(renderer) {
    renderer.shaderContext.pushVar(this.projection.uniform);
  }

  debug() {
    console.dir(this.projection);
  }

  update(data) {
    console.log('TODO ProjectionComponent.update(', data, ')');
  }

  disconnectedEntity(entity) {
    console.log('ProjectionComponent.disconnectedEntity(', entity, ')');
    entity.off(this);
  }
}
exports.default = ProjectionComponent;

/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(51);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(51);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _constants = __webpack_require__(0);

const eventize = __webpack_require__(1);

const PRIO_BEFORE_CHILDREN = _constants.COMP_PRIO_CHILDREN + 1;
const PRIO_AFTER_CHILDREN = _constants.COMP_PRIO_CHILDREN - 1;

class BeforeChildren {
  constructor(entity) {
    this.entity = entity;
  }

  renderFrame(renderer) {
    this.entity.emit('renderFrameBeforeChildren', renderer);
  }
}

class AfterChildren {
  constructor(entity) {
    this.entity = entity;
  }

  renderFrame(renderer) {
    this.entity.emit('renderFrameAfterChildren', renderer);
  }
}

class ChildrenComponent {
  constructor(entity) {
    eventize(this);

    this.beforeChildren = new BeforeChildren(entity);
    this.afterChildren = new AfterChildren(entity);

    entity.on('*', _constants.COMP_PRIO_CHILDREN, this);
    entity.on('*', PRIO_BEFORE_CHILDREN, this.beforeChildren);
    entity.on('*', PRIO_AFTER_CHILDREN, this.afterChildren);
  }

  renderFrameBeforeChildren() {
    // do not inform children about this event!
  }

  renderFrameAfterChildren() {
    // do not inform children about this event!
  }

  appendChild(entity) {
    if (entity.hasComponent('parentEntity')) {
      entity.destroyComponent('parentEntity');
    }
    entity.setComponent('parentEntity', this);
    this.on(entity);
  }

  removeChild(entity) {
    this.off(entity);
    entity.destroyComponent('parentEntity');
  }

  disconnectedEntity(entity) {
    console.log('ChildrenComponent.disconnectedEntity(', entity, ')');
    entity.off(this.afterChildren);
    entity.off(this.beforeChildren);
    entity.off(this);
  }
}
exports.default = ChildrenComponent;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _blend_mode = __webpack_require__(53);

var _blend_mode2 = _interopRequireDefault(_blend_mode);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const parseBlendModeData = data => ({
  enable: typeof data === 'object' ? data.enable === undefined ? true : !!data.enable : false,
  sfactor: typeof data === 'object' ? typeof data.sfactor === 'string' ? data.sfactor : '' : '',
  dfactor: typeof data === 'object' ? typeof data.dfactor === 'string' ? data.dfactor : '' : ''
});

class BeforeChildren {
  constructor(blendMode) {
    this.blendMode = blendMode;
  }

  renderFrame(renderer) {
    renderer.pushBlendMode(this.blendMode);
  }
}

class AfterChildren {
  renderFrame(renderer) {
    renderer.popBlendMode();
  }
}

class BlendModeComponent {
  constructor(entity, data) {
    const { enable, sfactor, dfactor } = parseBlendModeData(data);
    this.blendMode = new _blend_mode2.default(enable, sfactor, dfactor);
    this.beforeChildren = new BeforeChildren(this.blendMode);
    this.afterChildren = new AfterChildren();
    entity.on('*', _constants.COMP_PRIO_BLEND_BEFORE, this.beforeChildren);
    entity.on('*', _constants.COMP_PRIO_BLEND_AFTER, this.afterChildren);
    entity.on('debug', this);
  }

  debug() {
    console.dir(this.blendMode);
  }

  update(data) {
    const { enable, sfactor, dfactor } = parseBlendModeData(data);
    this.blendMode.enable = enable;
    this.blendMode.sfactor = sfactor;
    this.blendMode.dfactor = dfactor;
  }

  disconnectedEntity(entity) {
    console.log('BlendModeComponent.disconnectedEntity(', entity, ')');
    entity.off(this.afterChildren);
    entity.off(this.beforeChildren);
    entity.off(this);
  }
}
exports.default = BlendModeComponent;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var createCompounder = __webpack_require__(115);

/**
 * Converts `string` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @example
 *
 * _.snakeCase('Foo Bar');
 * // => 'foo_bar'
 *
 * _.snakeCase('fooBar');
 * // => 'foo_bar'
 *
 * _.snakeCase('--FOO-BAR--');
 * // => 'foo_bar'
 */
var snakeCase = createCompounder(function(result, word, index) {
  return result + (index ? '_' : '') + word.toLowerCase();
});

module.exports = snakeCase;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(116),
    deburr = __webpack_require__(117),
    words = __webpack_require__(125);

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var deburrLetter = __webpack_require__(118),
    toString = __webpack_require__(23);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var basePropertyOf = __webpack_require__(119);

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),
/* 119 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(14),
    arrayMap = __webpack_require__(122),
    isArray = __webpack_require__(6),
    isSymbol = __webpack_require__(25);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36)))

/***/ }),
/* 122 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(14);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 124 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var asciiWords = __webpack_require__(126),
    hasUnicodeWord = __webpack_require__(127),
    toString = __webpack_require__(23),
    unicodeWords = __webpack_require__(128);

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 126 */
/***/ (function(module, exports) {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),
/* 128 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
    rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _find_parent_element_by_name = __webpack_require__(56);

var _find_parent_element_by_name2 = _interopRequireDefault(_find_parent_element_by_name);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global HTMLElement */
const eventize = __webpack_require__(1);

class SceneElement extends HTMLElement {
  /** @ignore */
  constructor(_) {
    const self = super(_);
    return eventize(self);
  }

  get blitpunkNodeName() {
    return _constants.NODE_NAME_SCENE;
  }

  get blitpunk() {
    return this.blitpunkCanvas.blitpunk;
  }

  /** @private */
  connectedCallback() {
    this.blitpunkCanvas = (0, _find_parent_element_by_name2.default)(this, _constants.NODE_NAME_CANVAS);
  }

  /** @private */
  disconnectedCallback() {
    this.blitpunkCanvas = null;
  }
}
exports.default = SceneElement;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _connectElementEntities = __webpack_require__(57);

var _connectElementEntities2 = _interopRequireDefault(_connectElementEntities);

var _disconnectElementEntities = __webpack_require__(58);

var _disconnectElementEntities2 = _interopRequireDefault(_disconnectElementEntities);

var _readTextureHints = __webpack_require__(133);

var _readTextureHints2 = _interopRequireDefault(_readTextureHints);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global HTMLElement */
const eventize = __webpack_require__(1);

class TextureAtlasElement extends HTMLElement {
  /** @private */
  static get observedAttributes() {
    return [_constants.ATTR_SRC];
  }

  /** @ignore */
  constructor(_) {
    const self = super(_);
    return eventize(self);
  }

  /** @type {string} */
  get blitpunkNodeName() {
    return _constants.NODE_NAME_TEXTURE_ATLAS;
  }

  /** @type {string} */
  get textureId() {
    return this.entity && this.entity.id;
  }

  loadTextureAtlas(src) {
    if (src && this.entity) {
      if (this.prevUrl !== src) {
        this.prevUrl = src;
        this.textureHints = (0, _readTextureHints2.default)(this);
        this.textureAtlasPromise = this.textureLibrary.loadTextureAtlas(this.textureId, src, this.textureHints).then(atlas => {
          this.textureAtlas = atlas;
          return atlas;
        });
        return this.textureAtlasPromise;
      }
    }
  }

  /** @private */
  debug() {
    console.log(this.textureAtlas);
  }

  /** @private */
  connectedCallback() {
    (0, _connectElementEntities2.default)(this);
    this.textureLibrary = this.parentSceneElement.textureLibrary; // TODO for every element?
    this.loadTextureAtlas(this.getAttribute(_constants.ATTR_SRC));
  }

  /** @private */
  disconnectedCallback() {
    // TODO disconnectedCallback <blitpunk-texture-atlas/>
    this.textureAtlas = null;
    this.textureLibrary = null;
    (0, _disconnectElementEntities2.default)(this);
  }

  /** @private */
  attributeChangedCallback(attr, oldValue, newValue) {
    if (attr === _constants.ATTR_SRC) {
      this.loadTextureAtlas(newValue);
    }
  }
}
exports.default = TextureAtlasElement;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (el) {
  return (0, _find_parent_element_by_name2.default)(el, _constants.NODE_NAME_CANVAS);
};

var _find_parent_element_by_name = __webpack_require__(56);

var _find_parent_element_by_name2 = _interopRequireDefault(_find_parent_element_by_name);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = findParentElementByProperty;
const EXIT_NODES = ['BODY', 'HTML'];

function findParentElementByProperty(node, prop, value) {
  const parent = node.parentElement;
  if (!parent || parent.nodeType !== 1) return;
  const { nodeName } = parent;
  if (EXIT_NODES.includes(nodeName)) return;
  if (value == null && parent[prop] || value != null && parent[prop] === value) return parent;
  return parent;
}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = readTextureHints;

var _readBooleanAttribute = __webpack_require__(55);

var _readBooleanAttribute2 = _interopRequireDefault(_readBooleanAttribute);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readTextureHints(el) {
  return {
    flipY: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_FLIP_Y, false),
    repeatable: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_REPEATABLE, false),
    premultiplyAlpha: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_PREMULTIPLY_ALPHA, true),
    nearest: (0, _readBooleanAttribute2.default)(el, _constants.ATTR_NEAREST, false)
  };
}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _sprite_group = __webpack_require__(59);

var _sprite_group2 = _interopRequireDefault(_sprite_group);

var _parseCssStyledProperties = __webpack_require__(13);

var _parseCssStyledProperties2 = _interopRequireDefault(_parseCssStyledProperties);

var _createVoPropsSetter = __webpack_require__(190);

var _createVoPropsSetter2 = _interopRequireDefault(_createVoPropsSetter);

var _isNonEmptyString = __webpack_require__(191);

var _isNonEmptyString2 = _interopRequireDefault(_isNonEmptyString);

var _isNumberGreaterThanZero = __webpack_require__(192);

var _isNumberGreaterThanZero2 = _interopRequireDefault(_isNumberGreaterThanZero);

var _connectElementEntities = __webpack_require__(57);

var _connectElementEntities2 = _interopRequireDefault(_connectElementEntities);

var _disconnectElementEntities = __webpack_require__(58);

var _disconnectElementEntities2 = _interopRequireDefault(_disconnectElementEntities);

var _syncComponent = __webpack_require__(193);

var _syncComponent2 = _interopRequireDefault(_syncComponent);

var _constants = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const eventize = __webpack_require__(1); /* global HTMLElement */


const createConfig = ({ descriptor, capacity, vertexShader, fragmentShader, primitive, voNew, voZero }) => ({
  descriptor,
  vertexShader,
  fragmentShader,
  primitive,
  capacity: parseInt(capacity, 10),
  voNew: (0, _createVoPropsSetter2.default)(voNew),
  voZero: (0, _createVoPropsSetter2.default)(voZero)
});

// TODO add support for all options from src/core/SpriteGroup
const readConfigFromAttributes = el => createConfig({
  descriptor: el.getAttribute(_constants.ATTR_DESCRIPTOR),
  vertexShader: el.getAttribute(_constants.ATTR_VERTEX_SHADER),
  fragmentShader: el.getAttribute(_constants.ATTR_FRAGMENT_SHADER),
  primitive: el.getAttribute(_constants.ATTR_PRIMITIVE),
  capacity: el.getAttribute(_constants.ATTR_CAPACITY),
  voNew: el.getAttribute(_constants.ATTR_VO_NEW),
  voZero: el.getAttribute(_constants.ATTR_VO_ZERO)
});

const isValidConfig = config => (0, _isNonEmptyString2.default)(config.descriptor) && (0, _isNonEmptyString2.default)(config.vertexShader) && (0, _isNonEmptyString2.default)(config.fragmentShader) && (0, _isNonEmptyString2.default)(config.primitive) && (0, _isNumberGreaterThanZero2.default)(config.capacity);

const createSpriteGroup = el => {
  if (!el.parentScene) return; // TODO find a better way
  const config = readConfigFromAttributes(el);
  if (isValidConfig(config)) {
    el.spriteGroup = new _sprite_group2.default(el.resourceLibrary, el.textureLibrary, config);
    el._resolvePromise(el.spriteGroup);
    delete el._resolvePromise;
  }
};

const syncTextureMap = (el, data) => {
  const { spriteGroup } = el;
  if (!spriteGroup) return;
  const texMap = (0, _parseCssStyledProperties2.default)(data);
  if (!texMap || typeof texMap !== 'object') return;
  el.textureMap = {};
  Object.keys(texMap).forEach(key => {
    const selector = texMap[key];
    const texEl = el.blitpunkCanvas.querySelector(selector);
    el.textureMap[key] = texEl.textureId;
    spriteGroup.setTexture(key, texEl.textureId);
  });
};

class SpriteGroupElement extends HTMLElement {
  /** @private */
  static get observedAttributes() {
    return [_constants.ATTR_BLEND_MODE, _constants.ATTR_CAPACITY, _constants.ATTR_DESCRIPTOR, _constants.ATTR_FRAGMENT_SHADER, _constants.ATTR_PRIMITIVE, _constants.ATTR_TEXTURE_MAP, _constants.ATTR_VERTEX_SHADER];
  }

  /** @ignore */
  constructor(_) {
    const self = super(_);
    self.spriteGroupPromise = new Promise(resolve => {
      self._resolvePromise = resolve;
    });
    return eventize(self);
  }

  /** @type {string} */
  get blitpunkNodeName() {
    return _constants.NODE_NAME_SPRITE_GROUP;
  }

  /** @private */
  renderFrame(renderer) {
    if (this.spriteGroup) {
      this.spriteGroup.renderFrame(renderer);
    }
  }

  /** @private */
  debug() {
    console.log(this.spriteGroup);
    if (this.textureMap) console.log(_constants.ATTR_TEXTURE_MAP, this.textureMap);
  }

  /** @private */
  connectedCallback() {
    (0, _connectElementEntities2.default)(this);

    this.textureLibrary = this.parentSceneElement.textureLibrary;
    this.resourceLibrary = this.parentSceneElement.resourceLibrary;

    createSpriteGroup(this);
    syncTextureMap(this, this.getAttribute(_constants.ATTR_TEXTURE_MAP));
    (0, _syncComponent2.default)(this, _constants.ATTR_BLEND_MODE);
  }

  /** @private */
  disconnectedCallback() {
    // TODO disconnectedCallback <blitpunk-sprite-group/>
    this.textureMap = null;
    this.spriteGroup = null;
    this.textureLibrary = null;
    this.resourceLibrary = null;
    (0, _disconnectElementEntities2.default)(this);
  }

  /** @private */
  attributeChangedCallback(attr, oldValue, newValue) {
    switch (attr) {
      case _constants.ATTR_TEXTURE_MAP:
        syncTextureMap(this, newValue);
        break;
      case _constants.ATTR_BLEND_MODE:
        (0, _syncComponent2.default)(this, attr);
        break;
      default:
        if (!this.spriteGroup) {
          createSpriteGroup(this);
        }
    }
  }
}
exports.default = SpriteGroupElement;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (voPool, maxAllocSize = 0) {
  const max = voPool.capacity - voPool.usedCount - voPool.allocatedCount;
  const len = voPool.allocatedCount + (maxAllocSize > 0 && maxAllocSize < max ? maxAllocSize : max);

  for (let i = voPool.allocatedCount; i < len; i++) {
    let voArray = voPool.voArray.subarray(i);

    let vertexObject = voPool.descriptor.createVO(voArray);
    vertexObject.free = voPool.free.bind(voPool, vertexObject);

    voPool.availableVOs.push(vertexObject);
  }
};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(137),
    flatRest = __webpack_require__(178);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(138),
    hasIn = __webpack_require__(173);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(139),
    baseSet = __webpack_require__(170),
    castPath = __webpack_require__(15);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(15),
    toKey = __webpack_require__(30);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(6),
    isSymbol = __webpack_require__(25);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(142);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(143);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(144);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(145),
    mapCacheDelete = __webpack_require__(165),
    mapCacheGet = __webpack_require__(167),
    mapCacheHas = __webpack_require__(168),
    mapCacheSet = __webpack_require__(169);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(146),
    ListCache = __webpack_require__(158),
    Map = __webpack_require__(164);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(147),
    hashDelete = __webpack_require__(154),
    hashGet = __webpack_require__(155),
    hashHas = __webpack_require__(156),
    hashSet = __webpack_require__(157);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(149),
    isMasked = __webpack_require__(150),
    isObject = __webpack_require__(29),
    toSource = __webpack_require__(152);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(26),
    isObject = __webpack_require__(29);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(151);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(24);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 154 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(159),
    listCacheDelete = __webpack_require__(160),
    listCacheGet = __webpack_require__(161),
    listCacheHas = __webpack_require__(162),
    listCacheSet = __webpack_require__(163);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(17);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(28),
    root = __webpack_require__(24);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(18);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(18);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(18);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(18);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(171),
    castPath = __webpack_require__(15),
    isIndex = __webpack_require__(70),
    isObject = __webpack_require__(29),
    toKey = __webpack_require__(30);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(172),
    eq = __webpack_require__(68);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(69);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(174),
    hasPath = __webpack_require__(175);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 174 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(15),
    isArguments = __webpack_require__(71),
    isArray = __webpack_require__(6),
    isIndex = __webpack_require__(70),
    isLength = __webpack_require__(177),
    toKey = __webpack_require__(30);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(26),
    isObjectLike = __webpack_require__(27);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 177 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(179),
    overRest = __webpack_require__(183),
    setToString = __webpack_require__(185);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(180);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(181),
    isFlattenable = __webpack_require__(182);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 181 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(14),
    isArguments = __webpack_require__(71),
    isArray = __webpack_require__(6);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(184);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 184 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(186),
    shortOut = __webpack_require__(189);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(187),
    defineProperty = __webpack_require__(69),
    identity = __webpack_require__(188);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 188 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 189 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = createVoPropsSetter;

var _parseCssStyledProperties = __webpack_require__(13);

var _parseCssStyledProperties2 = _interopRequireDefault(_parseCssStyledProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createVoPropsSetter(voData) {
  if (!voData) return;
  const voProps = (0, _parseCssStyledProperties2.default)(voData);
  if (!voProps || typeof voProps !== 'object') return;
  const attrKeys = Object.keys(voProps);
  return vo => {
    attrKeys.forEach(key => {
      const attrDesc = vo.descriptor.attr[key];
      if (attrDesc) {
        attrDesc.setValue(vo, voProps[key]);
      } else if (typeof vo[key] === 'function') {
        vo[key](voProps[key]);
      } else {
        vo[key] = voProps[key];
      }
    });
  };
}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isNonEmptyString;
function isNonEmptyString(str) {
  return typeof str === 'string' && str.length > 0;
}

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isNumberGreaterThanZero;
function isNumberGreaterThanZero(num) {
  return typeof num === 'number' && num > 0;
}

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = syncComponent;
function syncComponent(el, name) {
  if (el.blitpunk == null) return;
  if (Array.isArray(name)) {
    name.forEach(syncComponent.bind(null, el));
    return;
  }
  const data = el.getAttribute(name);
  if (data == null) return;
  el.blitpunk.componentRegistry.createOrUpdateComponent(el.entity, name, data);
}

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(195);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(197)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/postcss-loader/lib/index.js!./blitpunk.scss", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/postcss-loader/lib/index.js!./blitpunk.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(196)(undefined);
// imports


// module
exports.push([module.i, "blitpunk-canvas {\n  display: inline-block;\n  font-size: 0;\n  margin: 0;\n  padding: 0; }\n  blitpunk-canvas > canvas {\n    border: 0;\n    margin: 0;\n    overflow: hidden;\n    padding: 0;\n    -ms-touch-action: none;\n    touch-action: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none; }\n\nblitpunk-scene,\nblitpunk-texture-atlas,\nblitpunk-sprite-group {\n  display: none; }\n", ""]);

// exports


/***/ }),
/* 196 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(198);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 198 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _app = __webpack_require__(32);

var _app2 = _interopRequireDefault(_app);

var _v_o_descriptor = __webpack_require__(38);

var _v_o_descriptor2 = _interopRequireDefault(_v_o_descriptor);

var _v_o_pool = __webpack_require__(67);

var _v_o_pool2 = _interopRequireDefault(_v_o_pool);

var _aabb = __webpack_require__(72);

var _aabb2 = _interopRequireDefault(_aabb);

var _blend_mode = __webpack_require__(53);

var _blend_mode2 = _interopRequireDefault(_blend_mode);

var _element_index_array = __webpack_require__(60);

var _element_index_array2 = _interopRequireDefault(_element_index_array);

var _power_of_2_image = __webpack_require__(20);

var _power_of_2_image2 = _interopRequireDefault(_power_of_2_image);

var _projection = __webpack_require__(47);

var _projection2 = _interopRequireDefault(_projection);

var _resource_library = __webpack_require__(37);

var _resource_library2 = _interopRequireDefault(_resource_library);

var _shader_attrib_value = __webpack_require__(65);

var _shader_attrib_value2 = _interopRequireDefault(_shader_attrib_value);

var _shader_attrib_variable = __webpack_require__(64);

var _shader_attrib_variable2 = _interopRequireDefault(_shader_attrib_variable);

var _shader_context = __webpack_require__(45);

var _shader_context2 = _interopRequireDefault(_shader_context);

var _shader_program = __webpack_require__(61);

var _shader_program2 = _interopRequireDefault(_shader_program);

var _shader_source = __webpack_require__(19);

var _shader_source2 = _interopRequireDefault(_shader_source);

var _shader_texture_2d_variable = __webpack_require__(22);

var _shader_texture_2d_variable2 = _interopRequireDefault(_shader_texture_2d_variable);

var _shader_texture_group = __webpack_require__(62);

var _shader_texture_group2 = _interopRequireDefault(_shader_texture_group);

var _shader_uniform_variable = __webpack_require__(52);

var _shader_uniform_variable2 = _interopRequireDefault(_shader_uniform_variable);

var _shader_variable = __webpack_require__(5);

var _shader_variable2 = _interopRequireDefault(_shader_variable);

var _shader_variable_alias = __webpack_require__(66);

var _shader_variable_alias2 = _interopRequireDefault(_shader_variable_alias);

var _shader_variable_buffer_group = __webpack_require__(63);

var _shader_variable_buffer_group2 = _interopRequireDefault(_shader_variable_buffer_group);

var _shader_variable_group = __webpack_require__(12);

var _shader_variable_group2 = _interopRequireDefault(_shader_variable_group);

var _sprite_group = __webpack_require__(59);

var _sprite_group2 = _interopRequireDefault(_sprite_group);

var _texture = __webpack_require__(11);

var _texture2 = _interopRequireDefault(_texture);

var _texture_atlas = __webpack_require__(21);

var _texture_atlas2 = _interopRequireDefault(_texture_atlas);

var _texture_atlas_spec = __webpack_require__(42);

var _texture_atlas_spec2 = _interopRequireDefault(_texture_atlas_spec);

var _texture_library = __webpack_require__(39);

var _texture_library2 = _interopRequireDefault(_texture_library);

var _texture_state = __webpack_require__(41);

var _texture_state2 = _interopRequireDefault(_texture_state);

var _v_o_array = __webpack_require__(7);

var _v_o_array2 = _interopRequireDefault(_v_o_array);

var _v_o_attr_descriptor = __webpack_require__(10);

var _v_o_attr_descriptor2 = _interopRequireDefault(_v_o_attr_descriptor);

var _Viewport = __webpack_require__(200);

var _Viewport2 = _interopRequireDefault(_Viewport);

var _component_registry = __webpack_require__(33);

var _component_registry2 = _interopRequireDefault(_component_registry);

var _entity = __webpack_require__(35);

var _entity2 = _interopRequireDefault(_entity);

var _entity_manager = __webpack_require__(34);

var _entity_manager2 = _interopRequireDefault(_entity_manager);

var _generate_uuid = __webpack_require__(4);

var _generate_uuid2 = _interopRequireDefault(_generate_uuid);

var _mat = __webpack_require__(48);

var _mat2 = _interopRequireDefault(_mat);

var _math_helpers = __webpack_require__(40);

var _parseCssStyledProperties = __webpack_require__(13);

var _parseCssStyledProperties2 = _interopRequireDefault(_parseCssStyledProperties);

var _sample = __webpack_require__(43);

var _sample2 = _interopRequireDefault(_sample);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  App: _app2.default,

  // core
  AABB2: _aabb2.default,
  BlendMode: _blend_mode2.default,
  ElementIndexArray: _element_index_array2.default,
  PowerOf2Image: _power_of_2_image2.default,
  Projection: _projection2.default,
  ResourceLibrary: _resource_library2.default,
  ShaderAttribValue: _shader_attrib_value2.default,
  ShaderAttribVariable: _shader_attrib_variable2.default,
  ShaderContext: _shader_context2.default,
  ShaderProgram: _shader_program2.default,
  ShaderSource: _shader_source2.default,
  ShaderTexture2dVariable: _shader_texture_2d_variable2.default,
  ShaderTextureGroup: _shader_texture_group2.default,
  ShaderUniformVariable: _shader_uniform_variable2.default,
  ShaderVariable: _shader_variable2.default,
  ShaderVariableAlias: _shader_variable_alias2.default,
  ShaderVariableBufferGroup: _shader_variable_buffer_group2.default,
  ShaderVariableGroup: _shader_variable_group2.default,
  SpriteGroup: _sprite_group2.default,
  Texture: _texture2.default,
  TextureAtlas: _texture_atlas2.default,
  TextureAtlasSpec: _texture_atlas_spec2.default,
  TextureLibrary: _texture_library2.default,
  TextureState: _texture_state2.default,
  VOArray: _v_o_array2.default,
  VOAttrDescriptor: _v_o_attr_descriptor2.default,
  VODescriptor: _v_o_descriptor2.default,
  VOPool: _v_o_pool2.default,
  Viewport: _Viewport2.default,

  // ecs
  ComponentRegistry: _component_registry2.default,
  Entity: _entity2.default,
  EntityManager: _entity_manager2.default,

  // utils
  Mat4: _mat2.default,
  findNextPowerOf2: _math_helpers.findNextPowerOf2,
  generateUuid: _generate_uuid2.default,
  isPowerOf2: _math_helpers.isPowerOf2,
  maxOf: _math_helpers.maxOf,
  parseCssStyledProperties: _parseCssStyledProperties2.default,
  sample: _sample2.default
};

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _aabb = __webpack_require__(72);

var _aabb2 = _interopRequireDefault(_aabb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Viewport extends _aabb2.default {
  /**
   * @param {number} x - x
   * @param {number} y - y
   * @param {number} width - width
   * @param {number} height - height
   */
  constructor(x, y, width, height) {
    const minX = parseInt(x, 10);
    const minY = parseInt(y, 10);

    super(minX, minX + parseInt(width, 10) - 1, minY, minY + parseInt(height, 10) - 1);
  }

  /**
   * @type {number}
   */
  get x() {
    return this.minX;
  }

  /**
   * @param {number} x
   * @type {number}
   */
  set x(x) {
    const w = this.width;

    /**
     * @type {number}
     */
    this.minX = x;
    /**
     * @type {number}
     */
    this.maxX = x + w - 1;
  }

  /**
   * @type {number}
   */
  get y() {
    return this.minY;
  }

  /**
   * @param {number} y
   * @type {number}
   */
  set y(y) {
    const h = this.height;

    /**
     * @type {number}
     */
    this.minY = y;
    /**
     * @type {number}
     */
    this.maxY = y + h - 1;
  }

  /**
   * @type {number}
   */
  get width() {
    return this.maxX - this.minX + 1;
  }

  /**
   * @param {number} y
   * @type {number}
   */
  set width(w) {
    /**
     * @type {number}
     */
    this.maxX = this.minX + w - 1;
  }

  /**
   * @type {number}
   */
  get height() {
    return this.maxY - this.minY + 1;
  }

  /**
   * @param {number} y
   * @type {number}
   */
  set height(h) {
    /**
     * @type {number}
     */
    this.maxY = this.minY + h - 1;
  }
}
exports.default = Viewport;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyNmYxMGJmOGM2MTY2MzY0OTg2NiIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNwZWFyd29sZi9ldmVudGl6ZS9zcmMvZXZlbnRpemUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvZ2VuZXJhdGVfdXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9zaGFkZXJfdmFyaWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Zfb19hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvcmVzb3VyY2VfcmVmLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy90eXBlZF9hcnJheV9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Zfb19hdHRyX2Rlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9zaGFkZXJfdmFyaWFibGVfZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3BhcnNlQ3NzU3R5bGVkUHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3NoYWRlcl9zb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvcG93ZXJfb2ZfMl9pbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS90ZXh0dXJlX2F0bGFzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3NoYWRlcl90ZXh0dXJlXzJkX3ZhcmlhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JsaXRwdW5rLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Vjcy9jb21wb25lbnRfcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Vjcy9lbnRpdHlfbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZWNzL2VudGl0eS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Jlc291cmNlX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdl9vX2Rlc2NyaXB0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdGV4dHVyZV9saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9tYXRoX2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdGV4dHVyZV9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS90ZXh0dXJlX2F0bGFzX3NwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL3dlYl9nbF9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc2hhZGVyX2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rpbnljb2xvcjIvdGlueWNvbG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Byb2plY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc2hhZGVyX3VuaWZvcm1fdmFyaWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvYmxlbmRfbW9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbG9nLmpzIiwid2VicGFjazovLy8uL3NyYy9kb20vbGliL3JlYWRCb29sZWFuQXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9kb20vbGliL2ZpbmRfcGFyZW50X2VsZW1lbnRfYnlfbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2xpYi9jb25uZWN0RWxlbWVudEVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL3NyYy9kb20vbGliL2Rpc2Nvbm5lY3RFbGVtZW50RW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc3ByaXRlX2dyb3VwLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2VsZW1lbnRfaW5kZXhfYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc2hhZGVyX3Byb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc2hhZGVyX3RleHR1cmVfZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc2hhZGVyX3ZhcmlhYmxlX2J1ZmZlcl9ncm91cC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9zaGFkZXJfYXR0cmliX3ZhcmlhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3NoYWRlcl9hdHRyaWJfdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc2hhZGVyX3ZhcmlhYmxlX2FsaWFzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Zfb19wb29sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2FhYmIyLmpzIiwid2VicGFjazovLy8uL3NyYy9kb20vZGVmaW5lQ3VzdG9tRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbS9lbGVtZW50cy9DYW52YXNFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdl9vX2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvc2VyaWFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Zfb19kZXNjcmlwdG9yL2NyZWF0ZV92X29fcHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Zfb19kZXNjcmlwdG9yL2NyZWF0ZV90eXBlZF9hcnJheXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdl9vX2Rlc2NyaXB0b3IvY3JlYXRlX2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdl9vX2Rlc2NyaXB0b3IvY3JlYXRlX2FsaWFzZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc3ByaXRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9zcHJpdGVzL3NpbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvc2hhZGVyX2hlbHBlcnMvcm90YXRlLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9zaGFkZXJfaGVscGVycy9yZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL21hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL2FzX2Zsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9zaGFkZXJfaGVscGVycy9tdWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL3N1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvc2hhZGVyX2hlbHBlcnMvYWRkLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXIvd2ViX2dsX2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlci93ZWJfZ2xfcmVzb3VyY2VfbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL3dlYl9nbF9zaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL3NvdXJjZV90b19zdHIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlci93ZWJfZ2xfcHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL3dlYl9nbF91bmlmb3JtLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXIvd2ViX2dsX2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL3dlYl9nbF90ZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXIvd2ViX2dsX3RleHR1cmVfbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL3dlYl9nbF9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL3JlZ2lzdGVyRGVmYXVsdENvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbS9jb21wb25lbnRzL1Byb2plY3Rpb25Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvcXVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2NvbXBvbmVudHMvQ2hpbGRyZW5Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbS9jb21wb25lbnRzL0JsZW5kTW9kZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NuYWtlQ2FzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVDb21wb3VuZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVidXJyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlYnVyckxldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC93b3Jkcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVdvcmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGVXb3JkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVXb3Jkcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2VsZW1lbnRzL1NjZW5lRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2VsZW1lbnRzL1RleHR1cmVBdGxhc0VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbS9saWIvZmluZEJsaXRwdW5rQ2FudmFzRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2xpYi9maW5kUGFyZW50RWxlbWVudEJ5UHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbS9saWIvcmVhZFRleHR1cmVIaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2VsZW1lbnRzL1Nwcml0ZUdyb3VwRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS92X29fcG9vbC9jcmVhdGVfdmVydGV4X29iamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvY3JlYXRlVm9Qcm9wc1NldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaXNOb25FbXB0eVN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaXNOdW1iZXJHcmVhdGVyVGhhblplcm8uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbS9saWIvc3luY0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2JsaXRwdW5rLnNjc3M/NjVjYSIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tL2JsaXRwdW5rLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvVmlld3BvcnQuanMiXSwibmFtZXMiOlsiRE9NX0VMRU1fQ0FOVkFTIiwiRE9NX0VMRU1fU0NFTkUiLCJET01fRUxFTV9TUFJJVEVfR1JPVVAiLCJET01fRUxFTV9URVhUVVJFX0FUTEFTIiwiTk9ERV9OQU1FX0NBTlZBUyIsInRvVXBwZXJDYXNlIiwiTk9ERV9OQU1FX1NDRU5FIiwiTk9ERV9OQU1FX1NQUklURV9HUk9VUCIsIk5PREVfTkFNRV9URVhUVVJFX0FUTEFTIiwiQ09NUF9QUklPX1BST0pFQ1RJT04iLCJDT01QX1BSSU9fQkxFTkRfQkVGT1JFIiwiQ09NUF9QUklPX0NISUxEUkVOIiwiQ09NUF9QUklPX0JMRU5EX0FGVEVSIiwiQVRUUl9BTFBIQSIsIkFUVFJfQU5USUFMSUFTIiwiQVRUUl9CTEVORF9NT0RFIiwiQVRUUl9DQVBBQ0lUWSIsIkFUVFJfQ0xFQVJfQ09MT1IiLCJBVFRSX0RFUFRIIiwiQVRUUl9ERVNDUklQVE9SIiwiQVRUUl9GTElQX1kiLCJBVFRSX0ZSQUdNRU5UX1NIQURFUiIsIkFUVFJfTU9EVUxFX1NSQyIsIkFUVFJfTkVBUkVTVCIsIkFUVFJfUFJFTVVMVElQTElFRF9BTFBIQSIsIkFUVFJfUFJFTVVMVElQTFlfQUxQSEEiLCJBVFRSX1BSRVNFUlZFX0RSQVciLCJBVFRSX1BSSU1JVElWRSIsIkFUVFJfUFJPSkVDVElPTiIsIkFUVFJfUkVQRUFUQUJMRSIsIkFUVFJfU1JDIiwiQVRUUl9TVEVOQ0lMIiwiQVRUUl9URVhUVVJFX01BUCIsIkFUVFJfVkVSVEVYX1NIQURFUiIsIkFUVFJfVk9fTkVXIiwiQVRUUl9WT19aRVJPIiwib2JqIiwiZGVzdHJveWVkIiwiZXZlbnRpemUiLCJpcyIsIm9mZiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsInJlcXVpcmUiLCJ1dWlkIiwiU2hhZGVyVmFyaWFibGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ0eXBlIiwiX3ZhbHVlIiwic2VyaWFsIiwidmFsIiwidG91Y2giLCJUWVBFIiwiZnJlZXplIiwiVU5JRk9STSIsIkFUVFJJQiIsIlRFWFRVUkVfMkQiLCJWT0FycmF5IiwiZGVzY3JpcHRvciIsImNhcGFjaXR5IiwiZGF0YSIsInVzYWdlIiwiVVNBR0UiLCJEWU5BTUlDIiwiYXV0b3RvdWNoIiwidW5kZWZpbmVkIiwicmVzb3VyY2VSZWYiLCJBcnJheUJ1ZmZlciIsImZsb2F0MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkRhdGFWaWV3IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJieXRlc1BlclZPIiwiaGludHMiLCJ0eXBlZEFycmF5IiwiYnVmZmVyQnl0ZU9mZnNldCIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJ0eXBlTGlzdCIsImZpbHRlciIsImVuYWJsZUF1dG90b3VjaCIsImNvcHkiLCJmcm9tVk9BcnJheSIsInRvT2Zmc2V0Iiwib2Zmc2V0Iiwic2V0Iiwic3ViYXJyYXkiLCJiZWdpbiIsInNpemUiLCJTVEFUSUMiLCJSZXNvdXJjZVJlZiIsInJlc291cmNlIiwiaWQiLCJpc1N5bmNlZCIsInNvdXJjZVJlZiIsIm5lZWRTeW5jIiwic3luYyIsImNiIiwiQllURVNfUEVSX0VMRU1FTlQiLCJmbG9hdDMyIiwiaW50MTYiLCJpbnQzMiIsImludDgiLCJ1aW50MTYiLCJ1aW50MzIiLCJ1aW50OCIsIlRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SIiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJJbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVWludDhBcnJheSIsIlRZUEVEX0FSUkFZX0dFVFRFUiIsImludDMyQXJyYXkiLCJpbnQxNkFycmF5IiwiaW50OEFycmF5IiwidWludDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQ4QXJyYXkiLCJHTF9JVEVNX1RZUEVTIiwiVk9BdHRyRGVzY3JpcHRvciIsInVuaWZvcm0iLCJhdHRyTmFtZXMiLCJieXRlc1BlckVsZW1lbnQiLCJieXRlc1BlclZlcnRleCIsInZlcnRleEF0dHJDb3VudCIsImRlZmluZVByb3BlcnRpZXMiLCJhdHRyRGVzYyIsInByb3BlcnRpZXNPYmplY3QiLCJnZXRBcnJheSIsInZlcnRleENvdW50IiwiaSIsImoiLCJ2YWx1ZUdldHRlciIsImdldFYxdSIsInZhbHVlU2V0dGVyIiwic2V0VjF1IiwiZ2V0VmFsdWUiLCJ2byIsImNhbGwiLCJzZXRWYWx1ZSIsImFyZyIsImdldCIsImVudW1lcmFibGUiLCJzZXRWTnYiLCJhcmdzIiwiYXBwbHkiLCJjYW1lbGl6ZSIsInZhbHVlR2V0dGVycyIsImN1clZhbHVlR2V0dGVyIiwicHVzaCIsInZpIiwiZ2V0Vk51Iiwic2V0Vk51IiwiaWR4Iiwic2V0dGVyTmFtZSIsImF0dHJQb3N0Zml4IiwiY3VyVmVydGV4VmFsdWVHZXR0ZXJzIiwiaW5kZXgiLCJwb3N0Zml4IiwiYXR0ckluZGV4Iiwidm9BcnJheSIsInZlY3Rvckxlbmd0aCIsIl9hcnJheSIsIm4iLCJhcmd1bWVudHMiLCJzdWJzdHIiLCJnZXRPcHRpb24iLCJvcHRpb25zIiwiZGVmYXVsdFZhbHVlIiwiVGV4dHVyZSIsInNvdXJjZSIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJwYXJlbnQiLCJpbWFnZSIsIl9yZXNvdXJjZVJlZiIsImZsaXBZIiwicmVwZWF0YWJsZSIsInByZW11bHRpcGx5QWxwaGEiLCJuZWFyZXN0Iiwib3JpZ1dpZHRoIiwib3JpZ0hlaWdodCIsIkVycm9yIiwiX3dpZHRoIiwiX2hlaWdodCIsInJvb3QiLCJpbWdFbCIsInciLCJoIiwibWluUyIsInRleHR1cmUiLCJtaW5UIiwibWF4UyIsIm1heFQiLCJsb2FkIiwidXJsIiwidGV4dHVyZUhpbnRzIiwiY29tcGxldGUiLCJ0aGVuIiwicDJpbWciLCJTaGFkZXJWYXJpYWJsZUdyb3VwIiwic2hhZGVyVmFycyIsInB1c2hWYXIiLCJzaGFkZXJDb250ZXh0IiwiYmluZCIsInBvcFZhciIsInJlTnVtYmVyIiwicmVVcmwiLCJyZVZlYzIiLCJyZVZlYzMiLCJyZVZlYzQiLCJyZUZ1bmMiLCJwYXJzZVZhbHVlIiwibGVuIiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiSlNPTiIsInBhcnNlIiwiZXhlYyIsInBhcnNlRmxvYXQiLCJtIiwiVVJMIiwidHJpbSIsInNsaWNlIiwibWFwIiwiaW5kZXhPZk5leHROb25XaGl0ZXNwYWNlIiwic3RyIiwiY3VySWR4IiwiaW5kZXhPZk5leHRTZXBlcmF0b3IiLCJzZXBlcmF0b3IiLCJpc0luc2lkZSIsInNwbGl0SW50b1Byb3BUb2tlbnMiLCJwcm9wVG9rZW5zIiwidG8iLCJzcGxpdEludG9Qcm9wcyIsInRva2VucyIsInRvayIsImNvbG9uIiwiaW5kZXhPZiIsInByb3AiLCJwYXJzZUNzc1N0eWxlZFByb3BlcnRpZXMiLCJwcm9wcyIsInZhbHVlcyIsIlNoYWRlclNvdXJjZSIsIkhUTUxFbGVtZW50IiwidGV4dENvbnRlbnQiLCJWRVJURVhfU0hBREVSIiwiRlJBR01FTlRfU0hBREVSIiwiUG93ZXJPZjJJbWFnZSIsImZyb20iLCJ3aW5kb3ciLCJJbWFnZSIsInNyYyIsIlByb21pc2UiLCJyZXNvbHZlIiwib3JpZ09uTG9hZCIsIm9ubG9hZCIsInNldFBvd2VyT2YySW1nRWwiLCJpc0NvbXBsZXRlIiwiY29udmVydFRvUG93ZXJPZjIiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiVGV4dHVyZUF0bGFzIiwicm9vdFRleHR1cmUiLCJzcGVjIiwiZnJhbWVzIiwiTWFwIiwiYWRkRnJhbWUiLCJnZXRGcmFtZSIsImdldFJhbmRvbUZyYW1lIiwiQXJyYXkiLCJnZXRSYW5kb21GcmFtZU5hbWUiLCJmcmFtZU5hbWVzIiwiZmV0Y2hPcHRpb25zIiwiYXRsYXNTcGVjIiwiY3JlYXRlVGV4dHVyZUF0bGFzIiwiaW1hZ2VVcmwiLCJTaGFkZXJUZXh0dXJlMmRWYXJpYWJsZSIsInN5bmNUZXh0dXJlQW5kVmFsdWUiLCJyZW5kZXJlciIsImdsVGV4Iiwic3luY1RleHR1cmUiLCJjdXN0b21FbGVtZW50cyIsIndoZW5SZWFkeSIsIndoZW5EZWZpbmVkIiwidGlueWNvbG9yIiwibm93IiwicGVyZm9ybWFuY2UiLCJkZWZhdWx0T3B0aW9uIiwiZGVmYXVsdFZhbHVlRm4iLCJBcHAiLCJjb21wb25lbnRSZWdpc3RyeSIsImVudGl0eU1hbmFnZXIiLCJyZXNvdXJjZUxpYnJhcnkiLCJ0ZXh0dXJlTGlicmFyeSIsImNvbnRleHRBdHRyaWJ1dGVzIiwiYWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJ0aW1lIiwibGFzdEZyYW1lVGltZSIsInRpbWVGcmFtZU9mZnNldCIsImZyYW1lTm8iLCJjbGVhckNvbG9yIiwiY3JlYXRlR2xDb250ZXh0IiwiZW50aXR5IiwiY3JlYXRlRW50aXR5Iiwic2V0Q29tcG9uZW50IiwiY3JlYXRlQ29tcG9uZW50IiwiZWwiLCJzdGFydGVkIiwic3RvcHBlZCIsIl9jbGVhckNvbG9yIiwiY29sb3IiLCJzZXRDbGVhckNvbG9yIiwiY2FuU3RhcnQiLCJzdGFydCIsInJlc2l6ZSIsInJlcXVlc3RBbmltYXRlIiwiZ2x4Iiwic3RhcnRUaW1lIiwiYXBwZW5kQ2hpbGQiLCJyYWZTdWJzY3JpcHRpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhbmltYXRlIiwiY2FuY2VsQW5pbWF0ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2FuU3RvcCIsInN0b3AiLCJkZXN0cm95IiwiZXJyMCIsImVycjEiLCJlcnIyIiwiZXJyMyIsImVycjQiLCJyZW1vdmVDaGlsZCIsImNhbkFuaW1hdGUiLCJyZW5kZXJGcmFtZSIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImRpc3BsYXkiLCJwYXJlbnROb2RlIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndQeCIsImNsaWVudFdpZHRoIiwiaFB4IiwiY2xpZW50SGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiZ2wiLCJ2aWV3cG9ydCIsImN0eEF0dHJzIiwiQ29tcG9uZW50UmVnaXN0cnkiLCJyZWdpc3RyeSIsInJlZ2lzdGVyQ29tcG9uZW50IiwiY29tcG9uZW50RmFjdG9yeSIsImZhY3RvcnkiLCJjb21wb25lbnQiLCJjcmVhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJ1cGRhdGUiLCJjcmVhdGVPclVwZGF0ZUNvbXBvbmVudCIsIkVudGl0eU1hbmFnZXIiLCJlbnRpdGllcyIsImdldEVudGl0eSIsImRlc3Ryb3lFbnRpdHkiLCJkZWxldGUiLCJkZXN0cm95QWxsRW50aXRpZXMiLCJjbGVhciIsImRlc3Ryb3lBbGxDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImRlc3Ryb3lDb21wb25lbnQiLCJFbnRpdHkiLCJoYXNDb21wb25lbnQiLCJoYXMiLCJjb25uZWN0ZWRFbnRpdHkiLCJkaXNjb25uZWN0ZWRFbnRpdHkiLCJlbWl0IiwiUmVzb3VyY2VMaWJyYXJ5IiwiZGVzY3JpcHRvcnMiLCJ2ZXJ0ZXhTaGFkZXJzIiwiZnJhZ21lbnRTaGFkZXJzIiwiYWRkRGVzY3JpcHRvciIsImRlc2NyaXB0aW9uIiwiYWRkVmVydGV4U2hhZGVyIiwiYWRkRnJhZ21lbnRTaGFkZXIiLCJmaW5kRGVzY3JpcHRvciIsImZpbmRWZXJ0ZXhTaGFkZXIiLCJmaW5kRnJhZ21lbnRTaGFkZXIiLCJWT0Rlc2NyaXB0b3IiLCJhdHRyaWJ1dGVzIiwiYWxpYXNlcyIsInByb3RvIiwicGFyc2VJbnQiLCJhdHRyIiwiY3JlYXRlVk9BcnJheSIsImNyZWF0ZVZPIiwidm9Qcm90b3R5cGUiLCJoYXNBdHRyaWJ1dGUiLCJtYXhJbmRleGVkVk9Qb29sU2l6ZSIsImZsb29yIiwiVGV4dHVyZUxpYnJhcnkiLCJzdGF0ZXMiLCJsb2FkVGV4dHVyZSIsInN0YXRlIiwicHJvbWlzZSIsImxvYWRUZXh0dXJlQXRsYXMiLCJhdGxhcyIsImdldFRleHR1cmVBdGxhcyIsIndoZW5Mb2FkZWQiLCJ0ZXh0dXJlSWQiLCJzaGFkZXJWYXJLZXkiLCJvbkxvYWRlZCIsImlzUmVhZHkiLCJzaGFkZXJWYXIiLCJtYXhPZiIsImEiLCJiIiwiZmluZE5leHRQb3dlck9mMiIsInAiLCJpc1Bvd2VyT2YyIiwiVGV4dHVyZVN0YXRlIiwidGV4IiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJUZXh0dXJlQXRsYXNTcGVjIiwianNvbkRlZiIsIm1ldGEiLCJpbWciLCJmcmFtZSIsImZldGNoIiwicmVzcG9uc2UiLCJqc29uIiwic2FtcGxlIiwiYXJyIiwicmFuZG9tIiwiV2ViR2xCdWZmZXIiLCJ0YXJnZXQiLCJBUlJBWV9CVUZGRVIiLCJTVEFUSUNfRFJBVyIsImdsQnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiYmluZEJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIkRZTkFNSUNfRFJBVyIsIlNoYWRlckNvbnRleHQiLCJhdHRyaWIiLCJ0ZXgyZCIsInNoYWRlclZhcmlhYmxlIiwibGFuZSIsInNoYWRlclZhckxhbmUiLCJjdXJWYXIiLCJzaGFkZXJWYXJNYXAiLCJjdXJVbmlmb3JtIiwiY3VyQXR0cmliIiwiY3VyVGV4MmQiLCJVTklGT1JNX05BTUUiLCJQcm9qZWN0aW9uIiwiZGVzaXJlZFdpZHRoIiwiZGVzaXJlZEhlaWdodCIsInBpeGVsUmF0aW8iLCJzaXplRml0IiwidW5pZm9ybU5hbWUiLCJ1cGRhdGVPcnRobyIsInBlcnNwZWN0aXZlIiwiY3VycmVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsImN1cnJlbnRSYXRpbyIsImRlc2lyZWRSYXRpbyIsImlzQ292ZXIiLCJmYWN0b3IiLCJtYXQ0IiwiREVHMlJBRCIsIlBJIiwiTWF0NCIsImlkZW50aXR5Iiwib3J0aG8iLCJ6UmFuZ2UiLCJwb3ciLCJodyIsImhoIiwiaHoiLCJkaXN0YW5jZSIsImFzcGVjdCIsIm5lYXIiLCJmYXIiLCJoYWxmSGVpZ2h0IiwiZm92eSIsImF0YW4iLCJ0cmFuc2xhdGUiLCJ6Iiwic2NhbGUiLCJyb3RhdGVYIiwiZGVnIiwicm90YXRlWSIsInJvdGF0ZVoiLCJtdWx0aXBseSIsImNsb25lIiwiZG9sbHkiLCJzeCIsInN5Iiwic3oiLCJTaGFkZXJVbmlmb3JtVmFyaWFibGUiLCJzbmFrZUNhc2UiLCJCbGVuZE1vZGUiLCJlbmFibGUiLCJzZmFjdG9yIiwiZGZhY3RvciIsIl9zZmFjdG9yIiwiX2RmYWN0b3IiLCJpc0VxdWFsIiwib3RoZXIiLCJsb2ciLCJkZWJ1ZyIsImdldEF0dHJpYnV0ZSIsInRvTG93ZXJDYXNlIiwiZmluZFBhcmVudEVsZW1lbnRCeU5hbWUiLCJFWElUX05PREVTIiwibm9kZSIsIm5hbWVzIiwicGFyZW50RWxlbWVudCIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpbmNsdWRlcyIsImJsaXRwdW5rQ2FudmFzIiwiYmxpdHB1bmsiLCJvbiIsInBhcmVudFNjZW5lRWxlbWVudCIsInBhcmVudFNjZW5lIiwic2NlbmUiLCJjaGlsZHJlbiIsInBpY2siLCJnZXRWTyIsIm9wdCIsIlNwcml0ZUdyb3VwIiwidm9Qb29sIiwiYXNzaWduIiwidm9OZXciLCJ2b1plcm8iLCJ2b1Bvb2xTaGFkZXJBdHRyaWJzIiwiaW5kaWNlcyIsIkdlbmVyYXRlIiwic2hhZGVyUHJvZ3JhbSIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwicHJpbWl0aXZlIiwidGV4dHVyZXMiLCJzaGFkZXJUZXh0dXJlR3JvdXAiLCJ1c2VkQ291bnQiLCJhdmFpbGFibGVDb3VudCIsInNldFRleHR1cmUiLCJzYW1wbGVyIiwiY3JlYXRlU3ByaXRlIiwiYWxsb2MiLCJzZXRTaXplIiwic2V0VGV4Q29vcmRzQnlUZXh0dXJlIiwidGV4VW5pZm9ybXMiLCJ1c2VTaGFkZXJQcm9ncmFtIiwiZHJhd0luZGV4ZWQiLCJFbGVtZW50SW5kZXhBcnJheSIsIm9iamVjdENvdW50IiwiaXRlbUNvdW50IiwiYXJyYXkiLCJzdHJpZGUiLCJvYmplY3RPZmZzZXQiLCJTaGFkZXJQcm9ncmFtIiwiU2hhZGVyVGV4dHVyZUdyb3VwIiwic2hhZGVyTGlicmFyeSIsInNoYWRlclRleHR1cmVNYXAiLCJ3YWl0Rm9yIiwiaXNMb2FkZWQiLCJzaGFkZXJWYXJHcm91cCIsInNoYWRlclZhclN0b3JlIiwiU2hhZGVyVmFyaWFibGVCdWZmZXJHcm91cCIsImJ1ZmZlclNvdXJjZSIsImZpcnN0VmFyIiwiYXR0ck5hbWUiLCJTaGFkZXJBdHRyaWJWYXJpYWJsZSIsIlNoYWRlckF0dHJpYlZhbHVlIiwiYXR0ckRlc2NyaXB0b3IiLCJTaGFkZXJWYXJpYWJsZUFsaWFzIiwiVk9Qb29sIiwibWF4QWxsb2NWT1NpemUiLCJhdmFpbGFibGVWT3MiLCJ1c2VkVk9zIiwiYWxsb2NhdGVkQ291bnQiLCJzaGlmdCIsImZyZWUiLCJpc0FycmF5IiwiX3ZvIiwibGFzdElkeCIsImxhc3QiLCJ0bXAiLCJzcGxpY2UiLCJwb3AiLCJ1bnNoaWZ0IiwiQUFCQjIiLCJ4MCIsIngxIiwieTAiLCJ5MSIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJjZW50ZXJYIiwiY2VudGVyWSIsImFkZFBvaW50IiwiaXNJbnRlcnNlY3Rpb24iLCJhYWJiIiwiZGVmaW5lQ3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiLCJjcmVhdGVDb250ZXh0QXR0cmlidXRlcyIsIkNhbnZhc0VsZW1lbnQiLCJfIiwic2VsZiIsImJsaXRwdW5rQXBpIiwiYmxpdHB1bmtOb2RlTmFtZSIsIm9ic2VydmVkQXR0cmlidXRlcyIsIm9uS2V5ZG93biIsImV2ZW50IiwiY3RybEtleSIsImdyb3VwIiwiZ3JvdXBFbmQiLCJjb2wiLCJnZXRBbHBoYSIsInRvSGV4U3RyaW5nIiwidG9SZ2JTdHJpbmciLCJjb25uZWN0ZWRDYWxsYmFjayIsImJvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIlNlcmlhbCIsImluaXRpYWxWYWx1ZSIsInRvQXJyYXkiLCJhdHRyTGlzdCIsImsiLCJ0eXBlZEFycmF5cyIsInNvcnQiLCJyaWdodFBhZEJ5dGVzUGVyVmVydGV4Iiwic3ByaXRlTGlicmFyeSIsInNpbXBsZSIsInBvczJkIiwicG9zWiIsInV2Iiwic2V0VGV4Q29vcmRzQnlWaWV3cG9ydCIsInRleHR1cmVXaWR0aCIsInRleHR1cmVIZWlnaHQiLCJyZXBlYXQiLCJzZXRUZXhDb29yZHMiLCJoYWxmV2lkdGgiLCJzZXRQb3MyZCIsIngzIiwieTIiLCJyb3RhdGVEZWdyZWUiLCJyb3RhdGUiLCJkZWdyZWUiLCJ6MCIsInoxIiwiejIiLCJ6MyIsImZ1bmNOYW1lIiwicmV0IiwicmVzIiwibTAwIiwibTAxIiwibTAyIiwibTAzIiwibTEwIiwibTExIiwibTEyIiwibTEzIiwibTIwIiwibTIxIiwibTIyIiwibTIzIiwibTMwIiwibTMxIiwibTMyIiwibTMzIiwiYXMiLCJ0b1N0ciIsIm51bWJlciIsIm1hdGNoIiwiaXNOdW1iZXIiLCJzdWIiLCJhZGQiLCJXZWJHbENvbnRleHQiLCJpbml0aWFsaXplIiwiYm91bmRCdWZmZXJzIiwiY3VycmVudFByb2dyYW0iLCJlbmFibGVkVmVydGV4QXR0cmliTG9jYXRpb25zIiwidGV4dHVyZU1hbmFnZXIiLCJib3VuZFRleHR1cmVzIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJyZWFkQ3VycmVudFN0YXRlIiwiYWN0aXZlVGV4dHVyZSIsImJsZW5kIiwiYmxlbmRNb2RlIiwiYmxlbmRFbmFibGVkIiwiQkxFTkQiLCJibGVuZEZ1bmMiLCJkaXNhYmxlIiwidGV4VW5pdCIsIlRFWFRVUkUwIiwiYWN0aXZlVGV4VW5pdCIsImJpbmRUZXh0dXJlMmQiLCJnbFRleHR1cmVJZCIsImJvdW5kIiwiYmluZFRleHR1cmUiLCJnZXRQYXJhbWV0ZXIiLCJBUlJBWV9CVUZGRVJfQklORElORyIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkciLCJDVVJSRU5UX1BST0dSQU0iLCJ1c2VQcm9ncmFtIiwiZ2xQcm9ncmFtIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXlzIiwiZW5hYmxlTG9jYXRpb25zIiwibG9jYXRpb24iLCJkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkiLCJsb2MiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsIkRFUFRIX0JJVFMiLCJXRUJfR0xfQlVGRkVSX1VTQUdFIiwic3RhdGljIiwiZHluYW1pYyIsIldlYkdsUmVzb3VyY2VMaWJyYXJ5IiwibG9hZFZlcnRleFNoYWRlciIsInNoYWRlclNvdXJjZSIsImdsU2hhZGVyIiwibG9hZEZyYWdlbWVudFNoYWRlciIsImxvYWRQcm9ncmFtIiwicHJvZ3JhbSIsImxvYWRCdWZmZXIiLCJyZWYiLCJidWZmZXJSZWYiLCJmaW5kQnVmZmVyIiwidGV4UmVmIiwiZ2xUZXh0dXJlUmVmIiwiV2ViR2xTaGFkZXIiLCJzaGFkZXJUeXBlIiwiY3JlYXRlU2hhZGVyIiwiY29tcGlsZVNoYWRlciIsInNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwic2hhZGVySW5mb0xvZyIsImdldFNoYWRlckluZm9Mb2ciLCJ3ZWJHbFNoYWRlciIsInNvdXJjZVRvU3RyIiwiY3R4Iiwiam9pbiIsIldlYkdsUHJvZ3JhbSIsImNyZWF0ZVByb2dyYW0iLCJsaW5rUHJvZ3JhbSIsImNyZWF0ZVVuaWZvcm1zIiwiY3JlYXRlQXR0cmlidXRlcyIsInVzZSIsImF0dHJpYnV0ZUxvY2F0aW9ucyIsImxvYWRVbmlmb3JtcyIsInVuaWZvcm1OYW1lcyIsInVuaWZvcm1zIiwibG9hZEF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVOYW1lcyIsImF0dHJpYlZhbHVlIiwic3luY0J1ZmZlciIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiQUNUSVZFX0FUVFJJQlVURVMiLCJBQ1RJVkVfVU5JRk9STVMiLCJhdHRhY2hTaGFkZXIiLCJMSU5LX1NUQVRVUyIsIndlYkdsUHJvZ3JhbSIsIldlYkdsVW5pZm9ybSIsImdldEFjdGl2ZVVuaWZvcm0iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ1bmlmb3JtU2V0dGVyIiwiRkxPQVQiLCJ1bmlmb3JtMWYiLCJGTE9BVF9WRUMyIiwidW5pZm9ybTJmIiwiRkxPQVRfVkVDMyIsInVuaWZvcm0zZiIsIkZMT0FUX1ZFQzQiLCJ1bmlmb3JtNGYiLCJGTE9BVF9NQVQ0IiwidW5pZm9ybU1hdHJpeDRmdiIsIkZBTFNFIiwiU0FNUExFUl8yRCIsInVuaWZvcm0xaSIsIndlYkdsVW5pZm9ybSIsImdsVHlwZSIsIldlYkdsQXR0cmlidXRlIiwiZ2V0QWN0aXZlQXR0cmliIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJXZWJHbFRleHR1cmUiLCJpc0luaXRpYWxpemVkIiwiZ2xUZXhPYmoiLCJjcmVhdGVUZXh0dXJlIiwiYmluZFdlYkdsVGV4dHVyZSIsInVwbG9hZEltYWdlRGF0YSIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInBpeGVsU3RvcmVpIiwiVU5QQUNLX0ZMSVBfWV9XRUJHTCIsIlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCIsIndyYXAiLCJSRVBFQVQiLCJDTEFNUF9UT19FREdFIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfV1JBUF9TIiwiVEVYVFVSRV9XUkFQX1QiLCJORUFSRVNUIiwiTElORUFSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiV2ViR2xUZXh0dXJlTWFuYWdlciIsImxhc3RCb3VuZFRleFVuaXQiLCJnbFRleHR1cmUiLCJwcmV2R2xUZXgiLCJhdXRvdG91Y2hCdWZmZXIiLCJhdXRvdG91Y2hSZXNvdXJjZXMiLCJhcHBseUJsZW5kTW9kZSIsImJsZW5kU3RhY2siLCJpbml0aWFsQmxlbmRNb2RlIiwiY3VycmVudEJsZW5kTW9kZSIsIldlYkdsUmVuZGVyZXIiLCJzZXRJbml0aWFsQmxlbmRNb2RlIiwiYXBwIiwiYmVnaW5SZW5kZXJGcmFtZSIsImVuZFJlbmRlckZyYW1lIiwiY2xlYXJGcmFtZUJ1ZmZlciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwidG9SZ2IiLCJyIiwiZyIsInB1c2hCbGVuZE1vZGUiLCJwb3BCbGVuZE1vZGUiLCJkcmF3QXJyYXlzIiwiY291bnQiLCJzdGFydEluZGV4IiwiZWxlbWVudEluZGV4QXJyYXkiLCJkcmF3RWxlbWVudHMiLCJVTlNJR05FRF9TSE9SVCIsImdsVGV4UmVmIiwiY3JlYXRlRmFjdG9yeSIsIkNvbXBvbmVudENvbnN0cnVjdG9yIiwiUHJvamVjdGlvbkNvbXBvbmVudCIsInByb2plY3Rpb24iLCJhbmltYXRlRnJhbWUiLCJkaXIiLCJQUklPX0JFRk9SRV9DSElMRFJFTiIsIlBSSU9fQUZURVJfQ0hJTERSRU4iLCJCZWZvcmVDaGlsZHJlbiIsIkFmdGVyQ2hpbGRyZW4iLCJDaGlsZHJlbkNvbXBvbmVudCIsImJlZm9yZUNoaWxkcmVuIiwiYWZ0ZXJDaGlsZHJlbiIsInJlbmRlckZyYW1lQmVmb3JlQ2hpbGRyZW4iLCJyZW5kZXJGcmFtZUFmdGVyQ2hpbGRyZW4iLCJwYXJzZUJsZW5kTW9kZURhdGEiLCJCbGVuZE1vZGVDb21wb25lbnQiLCJTY2VuZUVsZW1lbnQiLCJUZXh0dXJlQXRsYXNFbGVtZW50IiwicHJldlVybCIsInRleHR1cmVBdGxhc1Byb21pc2UiLCJ0ZXh0dXJlQXRsYXMiLCJmaW5kUGFyZW50RWxlbWVudEJ5UHJvcGVydHkiLCJyZWFkVGV4dHVyZUhpbnRzIiwiY3JlYXRlQ29uZmlnIiwicmVhZENvbmZpZ0Zyb21BdHRyaWJ1dGVzIiwiaXNWYWxpZENvbmZpZyIsImNvbmZpZyIsImNyZWF0ZVNwcml0ZUdyb3VwIiwic3ByaXRlR3JvdXAiLCJfcmVzb2x2ZVByb21pc2UiLCJzeW5jVGV4dHVyZU1hcCIsInRleE1hcCIsInRleHR1cmVNYXAiLCJzZWxlY3RvciIsInRleEVsIiwicXVlcnlTZWxlY3RvciIsIlNwcml0ZUdyb3VwRWxlbWVudCIsInNwcml0ZUdyb3VwUHJvbWlzZSIsIm1heEFsbG9jU2l6ZSIsIm1heCIsInZlcnRleE9iamVjdCIsImNyZWF0ZVZvUHJvcHNTZXR0ZXIiLCJ2b0RhdGEiLCJ2b1Byb3BzIiwiYXR0cktleXMiLCJpc05vbkVtcHR5U3RyaW5nIiwiaXNOdW1iZXJHcmVhdGVyVGhhblplcm8iLCJudW0iLCJzeW5jQ29tcG9uZW50IiwiVmlld3BvcnQiLCJnZW5lcmF0ZVV1aWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLHlDQUF5QztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNELG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLHlDQUF5QztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFELG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdCQUF3Qjs7QUFFbkY7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw0QkFBNEIsZ0JBQWdCO0FBQzFILDhFQUE4RSwyQkFBMkIsZ0JBQWdCO0FBQ3pILHFEQUFxRCxvREFBb0QsZ0JBQWdCO0FBQ3pILHFEQUFxRCxvREFBb0QsZ0JBQWdCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsMEJBQTBCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLEtBQUssa0JBQWtCLFlBQVksa0JBQWtCO0FBQ3JEO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixh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SztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoYkE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixh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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFD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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1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cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQkxJVFBVTktcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQkxJVFBVTktcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNzMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDI2ZjEwYmY4YzYxNjYzNjQ5ODY2IiwiLyogZXNsaW50IG5vLW11bHRpLXNwYWNlczogW1wiZXJyb3JcIiwgeyBleGNlcHRpb25zOiB7IFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6IHRydWUgfSB9XSAqL1xuXG5leHBvcnQgY29uc3QgRE9NX0VMRU1fQ0FOVkFTICAgICAgICA9ICdibGl0cHVuay1jYW52YXMnXG5leHBvcnQgY29uc3QgRE9NX0VMRU1fU0NFTkUgICAgICAgICA9ICdibGl0cHVuay1zY2VuZSdcbmV4cG9ydCBjb25zdCBET01fRUxFTV9TUFJJVEVfR1JPVVAgID0gJ2JsaXRwdW5rLXNwcml0ZS1ncm91cCdcbmV4cG9ydCBjb25zdCBET01fRUxFTV9URVhUVVJFX0FUTEFTID0gJ2JsaXRwdW5rLXRleHR1cmUtYXRsYXMnXG5cbmV4cG9ydCBjb25zdCBOT0RFX05BTUVfQ0FOVkFTICAgICAgICA9IERPTV9FTEVNX0NBTlZBUy50b1VwcGVyQ2FzZSgpXG5leHBvcnQgY29uc3QgTk9ERV9OQU1FX1NDRU5FICAgICAgICAgPSBET01fRUxFTV9TQ0VORS50b1VwcGVyQ2FzZSgpXG5leHBvcnQgY29uc3QgTk9ERV9OQU1FX1NQUklURV9HUk9VUCAgPSBET01fRUxFTV9TUFJJVEVfR1JPVVAudG9VcHBlckNhc2UoKVxuZXhwb3J0IGNvbnN0IE5PREVfTkFNRV9URVhUVVJFX0FUTEFTID0gRE9NX0VMRU1fVEVYVFVSRV9BVExBUy50b1VwcGVyQ2FzZSgpXG5cbmV4cG9ydCBjb25zdCBDT01QX1BSSU9fUFJPSkVDVElPTiAgID0gMTAwMFxuZXhwb3J0IGNvbnN0IENPTVBfUFJJT19CTEVORF9CRUZPUkUgPSA1MDBcbmV4cG9ydCBjb25zdCBDT01QX1BSSU9fQ0hJTERSRU4gICAgID0gMTAwXG5leHBvcnQgY29uc3QgQ09NUF9QUklPX0JMRU5EX0FGVEVSICA9IC01MDBcblxuZXhwb3J0IGNvbnN0IEFUVFJfQUxQSEEgICAgICAgICAgICAgICA9ICdhbHBoYSdcbmV4cG9ydCBjb25zdCBBVFRSX0FOVElBTElBUyAgICAgICAgICAgPSAnYW50aWFsaWFzJ1xuZXhwb3J0IGNvbnN0IEFUVFJfQkxFTkRfTU9ERSAgICAgICAgICA9ICdibGVuZC1tb2RlJ1xuZXhwb3J0IGNvbnN0IEFUVFJfQ0FQQUNJVFkgICAgICAgICAgICA9ICdjYXBhY2l0eSdcbmV4cG9ydCBjb25zdCBBVFRSX0NMRUFSX0NPTE9SICAgICAgICAgPSAnY2xlYXItY29sb3InXG5leHBvcnQgY29uc3QgQVRUUl9ERVBUSCAgICAgICAgICAgICAgID0gJ2RlcHRoJ1xuZXhwb3J0IGNvbnN0IEFUVFJfREVTQ1JJUFRPUiAgICAgICAgICA9ICdkZXNjcmlwdG9yJ1xuZXhwb3J0IGNvbnN0IEFUVFJfRkxJUF9ZICAgICAgICAgICAgICA9ICdmbGlwLXknXG5leHBvcnQgY29uc3QgQVRUUl9GUkFHTUVOVF9TSEFERVIgICAgID0gJ2ZyYWdtZW50LXNoYWRlcidcbmV4cG9ydCBjb25zdCBBVFRSX01PRFVMRV9TUkMgICAgICAgICAgPSAnbW9kdWxlLXNyYydcbmV4cG9ydCBjb25zdCBBVFRSX05FQVJFU1QgICAgICAgICAgICAgPSAnbmVhcmVzdCdcbmV4cG9ydCBjb25zdCBBVFRSX1BSRU1VTFRJUExJRURfQUxQSEEgPSAncHJlbXVsdGlwbGllZC1hbHBoYSdcbmV4cG9ydCBjb25zdCBBVFRSX1BSRU1VTFRJUExZX0FMUEhBICAgPSAncHJlbXVsdGlwbHktYWxwaGEnXG5leHBvcnQgY29uc3QgQVRUUl9QUkVTRVJWRV9EUkFXICAgICAgID0gJ3ByZXNlcnZlLWRyYXdpbmctYnVmZmVyJ1xuZXhwb3J0IGNvbnN0IEFUVFJfUFJJTUlUSVZFICAgICAgICAgICA9ICdwcmltaXRpdmUnXG5leHBvcnQgY29uc3QgQVRUUl9QUk9KRUNUSU9OICAgICAgICAgID0gJ3Byb2plY3Rpb24nXG5leHBvcnQgY29uc3QgQVRUUl9SRVBFQVRBQkxFICAgICAgICAgID0gJ3JlcGVhdGFibGUnXG5leHBvcnQgY29uc3QgQVRUUl9TUkMgICAgICAgICAgICAgICAgID0gJ3NyYydcbmV4cG9ydCBjb25zdCBBVFRSX1NURU5DSUwgICAgICAgICAgICAgPSAnc3RlbmNpbCdcbmV4cG9ydCBjb25zdCBBVFRSX1RFWFRVUkVfTUFQICAgICAgICAgPSAndGV4dHVyZS1tYXAnXG5leHBvcnQgY29uc3QgQVRUUl9WRVJURVhfU0hBREVSICAgICAgID0gJ3ZlcnRleC1zaGFkZXInXG5leHBvcnQgY29uc3QgQVRUUl9WT19ORVcgICAgICAgICAgICAgID0gJ3ZvLW5ldydcbmV4cG9ydCBjb25zdCBBVFRSX1ZPX1pFUk8gICAgICAgICAgICAgPSAndm8temVybydcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vY29uc3RhbnRzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzTWFwID0gY2FuVXNlTWFwKCk7XG52YXIgaGFzU3ltYm9sID0gY2FuVXNlU3ltYm9sKCk7XG52YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcblxudmFyIHdhcm4gPSBoYXNDb25zb2xlID8gY29uc29sZVtjb25zb2xlLndhcm4gPyAnd2FybicgOiAnbG9nJ10uYmluZChjb25zb2xlKSA6IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgUFJPUF9OQU1FU1BBQ0UgID0gIWhhc1N5bWJvbCA/ICdAQGV2ZW50aXplJyA6IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFTeW1ib2wuZXZlbnRpemUpIHtcbiAgICAgICAgU3ltYm9sLmV2ZW50aXplID0gU3ltYm9sKCdldmVudGl6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gU3ltYm9sLmV2ZW50aXplO1xufSkoKTtcblxudmFyIENBVENIX0FMTF9FVkVOVCA9ICcqJztcbnZhciBMT0dfTkFNRVNQQUNFICAgPSAnW2V2ZW50aXplLmpzXSc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGV2ZW50aXplKCBvYmplY3QgKVxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBldmVudGl6ZSAobykge1xuXG4gICAgaWYgKG9bUFJPUF9OQU1FU1BBQ0VdKSByZXR1cm4gbztcblxuICAgIHZhciBfZSA9IHtcbiAgICAgICAgbGFzdENhbGxiYWNrSWQgOiAwLFxuICAgICAgICBjYWxsYmFja3MgICAgICA6IHt9LFxuICAgICAgICBib3VuZE9iamVjdHMgICA6IFtdXG4gICAgfTtcblxuICAgIF9lLmNhbGxiYWNrc1tDQVRDSF9BTExfRVZFTlRdID0gW107XG5cbiAgICB2YXIgX2VQdWJsaWMgPSBkZWZpbmVQdWJsaWNQcm9wZXJ0aWVzUk8oe30sIHtcbiAgICAgICAgc2lsZW5jZWQgOiBmYWxzZSxcbiAgICAgICAgb2ZmICAgICAgOiBbXVxuICAgIH0pO1xuXG4gICAgZGVmaW5lSGlkZGVuUHJvcGVydHlSTyhvLCBQUk9QX05BTUVTUEFDRSwgX2VQdWJsaWMpO1xuXG4gICAgaWYgKGV2ZW50aXplLlBSSU9fREVGQVVMVCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgZGVmaW5lUHVibGljUHJvcGVydGllc1JPKGV2ZW50aXplLCB7XG4gICAgICAgICAgICBQUklPX01BWCAgICAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICBQUklPX0EgICAgICAgOiAxMDAwMDAwMDAwLFxuICAgICAgICAgICAgUFJJT19CICAgICAgIDogMTAwMDAwMDAsXG4gICAgICAgICAgICBQUklPX0MgICAgICAgOiAxMDAwMDAsXG4gICAgICAgICAgICBQUklPX0RFRkFVTFQgOiAwLFxuICAgICAgICAgICAgUFJJT19MT1cgICAgIDogLTEwMDAwMCxcbiAgICAgICAgICAgIFBSSU9fTUlOICAgICA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBvYmplY3Qub24oIGV2ZW50TmFtZSwgWyBwcmlvLCBdIGNhbGxiYWNrRnVuYyApXG4gICAgLy8gb2JqZWN0Lm9uKCBldmVudE5hbWUsIFsgcHJpbywgXSBvYmogKVxuICAgIC8vXG4gICAgLy8gb2JqZWN0Lm9uKCBjYWxsYmFja0Z1bmMgKSAgICA9PiBvYmplY3Qub24oICcqJywgY2FsbGJhY2tGdW5jIClcbiAgICAvLyBvYmplY3Qub24oIG9iaiApICAgICAgICAgICAgID0+IG9iamVjdC5vbiggJyonLCBvYmogKVxuICAgIC8vXG4gICAgLy8gb2JqZWN0Lm9uKCBldmVudE5hbWUgKVxuICAgIC8vIG9iamVjdC5vbigpXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgby5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHByaW8sIGZuKSB7ICAvLyAtLS0ge3t7XG5cbiAgICAgICAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoX2VQdWJsaWMuc2lsZW5jZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVQdWJsaWNQcm9wZXJ0eVJPKF9lUHVibGljLCAnc2lsZW5jZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgX2VQdWJsaWMub2ZmLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICBpID0gX2VQdWJsaWMub2ZmLmluZGV4T2YoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lUHVibGljLm9mZi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgZXZlbnROYW1lID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhbGlhcyBmb3I6IG9uKCcqJywgbGlzdGVuZXIpXG5cbiAgICAgICAgICAgICAgICBmbiA9IGV2ZW50TmFtZTtcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBDQVRDSF9BTExfRVZFTlQ7XG4gICAgICAgICAgICAgICAgcHJpbyA9IGV2ZW50aXplLlBSSU9fREVGQVVMVDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ29uc29sZSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKExPR19OQU1FU1BBQ0UsICcub24oKSBjYWxsZWQgd2l0aCBpbnN1ZmZpY2llbnQgYXJndW1lbnRzIScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzTGVuID09PSAyKSB7XG4gICAgICAgICAgICBmbiA9IHByaW87XG4gICAgICAgICAgICBwcmlvID0gZXZlbnRpemUuUFJJT19ERUZBVUxUO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50aXplQ2FsbGJhY2tzID0gX2UuY2FsbGJhY2tzO1xuICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGV2ZW50aXplQ2FsbGJhY2tzW2V2ZW50TmFtZV0gfHwgKGV2ZW50aXplQ2FsbGJhY2tzW2V2ZW50TmFtZV0gPSBbXSk7XG4gICAgICAgIHZhciBsaXN0ZW5lcklkID0gY3JlYXRlSWQoKTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZGVmaW5lUHVibGljUHJvcGVydGllc1JPKHt9LCB7XG4gICAgICAgICAgICBpZCAgICAgICAgIDogbGlzdGVuZXJJZCxcbiAgICAgICAgICAgIGZuICAgICAgICAgOiBmbixcbiAgICAgICAgICAgIHByaW8gICAgICAgOiAodHlwZW9mIHByaW8gIT09ICdudW1iZXInID8gZXZlbnRpemUuUFJJT19ERUZBVUxUIDogcHJpbyksXG4gICAgICAgICAgICBpc0Z1bmN0aW9uIDogKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50TGlzdGVuZXIucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuc29ydChzb3J0TGlzdGVuZXJCeVByaW8pO1xuXG4gICAgICAgIHJldHVybiBsaXN0ZW5lcklkO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUlkICgpIHtcbiAgICAgICAgcmV0dXJuICsrX2UubGFzdENhbGxiYWNrSWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydExpc3RlbmVyQnlQcmlvIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW8gIT09IGIucHJpbyA/IGIucHJpbyAtIGEucHJpbyA6IGEuaWQgLSBiLmlkO1xuICAgIH1cblxuICAgIC8vIC0tLSBvbiB9fX1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIG9iamVjdC5vbmNlKCBldmVudE5hbWUsIFsgcHJpbywgXSBjYWxsYmFja0Z1bmMgKVxuICAgIC8vIG9iamVjdC5vbmNlKCBldmVudE5hbWUsIFsgcHJpbywgXSBvYmogKVxuICAgIC8vXG4gICAgLy8gb2JqZWN0Lm9uY2UoIGNhbGxiYWNrRnVuYyApICAgICAgPT4gb2JqZWN0Lm9uY2UoICcqJywgY2FsbGJhY2tGdW5jIClcbiAgICAvLyBvYmplY3Qub25jZSggb2JqICkgICAgICAgICAgICAgICA9PiBvYmplY3Qub25jZSggJyonLCBvYmogKVxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgby5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcHJpbywgZm4pIHsgIC8vIC0tLSB7e3tcblxuICAgICAgICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFhcmdzTGVuIHx8IGFyZ3NMZW4gPiAzKSB7XG4gICAgICAgICAgICBpZiAoaGFzQ29uc29sZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oTE9HX05BTUVTUEFDRSwgJy5vbmNlKCkgY2FsbGVkIHdpdGggaW5zdWZmaWNpZW50IGFyZ3VtZW50cyEnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3NMZW4gPT09IDEpIHtcblxuICAgICAgICAgICAgZm4gPSBldmVudE5hbWU7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBDQVRDSF9BTExfRVZFTlQ7XG4gICAgICAgICAgICBwcmlvID0gZXZlbnRpemUuUFJJT19ERUZBVUxUO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMikge1xuXG4gICAgICAgICAgICBmbiA9IHByaW87XG4gICAgICAgICAgICBwcmlvID0gZXZlbnRpemUuUFJJT19ERUZBVUxUO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBvLm9uKGV2ZW50TmFtZSwgcHJpbywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBvLm9mZihpZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaWQ7XG5cbiAgICB9O1xuXG4gICAgLy8gLS0tIG9uY2UgfX19XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gb2JqZWN0Lm9mZiggaWQgKVxuICAgIC8vIG9iamVjdC5vZmYoIGNhbGxiYWNrIClcbiAgICAvLyBvYmplY3Qub2ZmKCBvYmogKVxuICAgIC8vIG9iamVjdC5vZmYoIGV2ZW50TmFtZSApXG4gICAgLy8gb2JqZWN0Lm9mZigpXG4gICAgLy9cbiAgICAvLyBkZWFjdGl2ZSBsaXN0ZW5lciBieSBpZCBvciBwcmV2aW91c2x5IGJvdW5kIG9iamVjdCBvclxuICAgIC8vIGZ1bmN0aW9uIHJlZmVyZW5jZSBvciBldmVudCBuYW1lIG9yIHNpbGVuY2UgYWxsIGV2ZW50c1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIG8ub2ZmID0gZnVuY3Rpb24gKGlkKSB7ICAvLyAtLSB7e3tcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFfZVB1YmxpYy5zaWxlbmNlZCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVB1YmxpY1Byb3BlcnR5Uk8oX2VQdWJsaWMsICdzaWxlbmNlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIF9lUHVibGljLm9mZi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBieSBldmVudCBuYW1lXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKF9lUHVibGljLm9mZi5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBfZVB1YmxpYy5vZmYucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRpemVDYWxsYmFja3MgPSBfZS5jYWxsYmFja3M7XG4gICAgICAgIHZhciBjYiwgaSwgaiwgX2NhbGxiYWNrcywga2V5cztcbiAgICAgICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIGlkID09PSAnb2JqZWN0JztcblxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaWQgPT09ICdmdW5jdGlvbicgfHwgaXNPYmplY3QpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBieSBpZCBvciBmdW5jdGlvbiByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRpemVDYWxsYmFja3MpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2tzID0gZXZlbnRpemVDYWxsYmFja3Nba2V5c1tqXV07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2IgPSBfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2IuaWQgPT09IGlkIHx8IGNiLmZuID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBieSBib3VuZCBvYmplY3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaSA9IF9lLmJvdW5kT2JqZWN0cy5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgIGlmICggaSA+PSAwICkge1xuICAgICAgICAgICAgICAgIF9lLmJvdW5kT2JqZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyAtLS0gb2ZmIH19fVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIG9iamVjdC5jb25uZWN0KCBvYmosIG1hcHBpbmcgKVxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgb2JqZWN0LmNvbm5lY3Qob3B0aW9ucywge1xuICAgIC8vICAgICAgICBvblByb2plY3Rpb25VcGRhdGVkIDogWzEwMCwgJ3Byb2plY3Rpb25VcGRhdGVkJ10sXG4gICAgLy8gICAgICAgIG9uRnJhbWUgICAgICAgICAgICAgOiAnZnJhbWUnLFxuICAgIC8vICAgICAgICBvbkZyYW1lRW5kICAgICAgICAgIDogJ2ZyYW1lRW5kJ1xuICAgIC8vICAgfSlcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBvLmNvbm5lY3QgPSBmdW5jdGlvbiAob2JqLCBtYXBwaW5nKSB7ICAvLyAtLS0ge3t7XG4gICAgICAgIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ3NMZW4gPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29ubmVjdFdpdGhNYXBwaW5nKHRoaXMsIG9iaiwgbWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ29uc29sZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oTE9HX05BTUVTUEFDRSwgJy5jb25uZWN0KCkgY2FsbGVkIHdpdGggaW5zdWZmaWNpZW50IGFyZ3VtZW50cyAobmVlZCAyIGFyZ3MsIGJ1dCBnb3QgJyArIGFyZ3NMZW4gKyAnKScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2JpbmRPYmplY3QgKG9iaikge1xuXG4gICAgICAgIC8vIFRPRE8gY29ubmVjdChvYmopIHNob3VsZCAuLlxuICAgICAgICAvLyAtIHN1cHBvcnQgcHJpb3JpdHlcbiAgICAgICAgLy8gLSBzdXBwb3J0IGZpbHRlcnM/ICh2aWEgb25seSwgZXhjZXB0IG9wdGlvbnMpXG4gICAgICAgIC8vIC0gc3VwcG9ydCBzZW5kZXJDb250ZXh0QXJndW1lbnQ/OiAncHJlcGVuZCd8J2FwcGVuZCd8ZmFsc2VcblxuICAgICAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgICAgICB2YXIgaSA9IF9lLmJvdW5kT2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgX2UuYm91bmRPYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Nvbm5lY3RXaXRoTWFwcGluZyAob2JqLCBvcHRpb25zLCBsaXN0ZW5lck1hcCkge1xuXG4gICAgICAgIHZhciBldmVudE5hbWUsIGxpc3Rlbk5hbWUsIGxpc3RlbkZ1bmMsIHByaW87XG5cbiAgICAgICAgZm9yIChsaXN0ZW5OYW1lIGluIGxpc3RlbmVyTWFwKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJNYXAuaGFzT3duUHJvcGVydHkobGlzdGVuTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5GdW5jID0gb3B0aW9uc1tsaXN0ZW5OYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbkZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gbGlzdGVuZXJNYXBbbGlzdGVuTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW8gPSBldmVudE5hbWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWVbMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvID0gZXZlbnRpemUuUFJJT19ERUZBVUxUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iai5vbihldmVudE5hbWUsIHByaW8sIGxpc3RlbkZ1bmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG5cbiAgICB9XG5cbiAgICAvLyAtLS0gY29ubmVjdCB9fX1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBvYmplY3QuZW1pdCggZXZlbnROYW1lIFssIGFyZ3VtZW50cyAuLiBdIClcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBvLmVtaXQgPSBmdW5jdGlvbiAoKSB7ICAvLyAtLS0ge3t7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXG4gICAgICAgIHZhciBhcmdzV2l0aEV2ZW50TmFtZSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzV2l0aEV2ZW50TmFtZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJnc1dpdGhFdmVudE5hbWVbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnROYW1lID0gYXJnc1dpdGhFdmVudE5hbWVbMF07XG4gICAgICAgIHZhciBhcmdzV2l0aG91dEV2ZW50TmFtZSA9IGFyZ3NXaXRoRXZlbnROYW1lLnNsaWNlKDEpO1xuICAgICAgICB2YXIgc2VuZGVyQ3R4ID0gdGhpcztcblxuICAgICAgICBfZGlzcGF0Y2goZXZlbnROYW1lLCBmdW5jdGlvbiAobGlzdGVuZXIpIHtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbi5hcHBseShzZW5kZXJDdHgsIGFyZ3NXaXRob3V0RXZlbnROYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gbGlzdGVuZXIuZm5bZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KGxpc3RlbmVyLmZuLCBhcmdzV2l0aG91dEV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lci5mbi5lbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmZuLmVtaXQuYXBwbHkobGlzdGVuZXIuZm4sIGFyZ3NXaXRoRXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gKGZuLCBib3VuZE9iaikge1xuXG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShib3VuZE9iaiwgYXJnc1dpdGhvdXRFdmVudE5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib3VuZE9iai5lbWl0KSB7XG4gICAgICAgICAgICAgICAgYm91bmRPYmouZW1pdC5hcHBseShib3VuZE9iaiwgYXJnc1dpdGhFdmVudE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Rpc3BhdGNoIChldmVudE5hbWUsIGVtaXRMaXN0ZW5lciwgZW1pdEJvdW5kT2JqZWN0KSB7XG5cbiAgICAgICAgaWYgKF9lUHVibGljLnNpbGVuY2VkKSByZXR1cm47XG4gICAgICAgIGlmIChfZVB1YmxpYy5vZmYuaW5kZXhPZihldmVudE5hbWUpID49IDApIHJldHVybjtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzICAgICAgICAgICAgICA9IF9lLmNhbGxiYWNrc1tldmVudE5hbWVdO1xuICAgICAgICB2YXIgY2F0Y2hBbGxMaXN0ZW5lcnMgICAgICA9IF9lLmNhbGxiYWNrc1tDQVRDSF9BTExfRVZFTlRdO1xuICAgICAgICB2YXIgYm91bmRPYmpzQ291bnQgICAgICAgICA9IF9lLmJvdW5kT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgIHZhciBoYXNCb3VuZE9iamVjdHNFbWl0dGVkID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gX2VtaXRCb3VuZE9iamVjdHMgKCkge1xuICAgICAgICAgICAgdmFyIGosIGJvLCBmbjtcbiAgICAgICAgICAgIGlmIChib3VuZE9ianNDb3VudCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBib3VuZE9ianNDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvID0gX2UuYm91bmRPYmplY3RzW2pdO1xuICAgICAgICAgICAgICAgICAgICBmbiA9IGJvW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRCb3VuZE9iamVjdChmbiwgYm8pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJvW1BST1BfTkFNRVNQQUNFXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEJvdW5kT2JqZWN0KG51bGwsIGJvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLCBsZW4sIGxpc3RlbjtcblxuICAgICAgICBpZiAobGlzdGVuZXJzIHx8IGNhdGNoQWxsTGlzdGVuZXJzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgPyBsaXN0ZW5lcnMuY29uY2F0KGNhdGNoQWxsTGlzdGVuZXJzKSA6IGNhdGNoQWxsTGlzdGVuZXJzO1xuICAgICAgICAgICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghaGFzQm91bmRPYmplY3RzRW1pdHRlZCAmJiBsaXN0ZW4gJiYgbGlzdGVuLnByaW8gPCBldmVudGl6ZS5QUklPX0RFRkFVTFQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2VtaXRCb3VuZE9iamVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQm91bmRPYmplY3RzRW1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXRMaXN0ZW5lcihsaXN0ZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNCb3VuZE9iamVjdHNFbWl0dGVkKSBfZW1pdEJvdW5kT2JqZWN0cygpO1xuXG4gICAgfVxuXG4gICAgLy8gLS0tIGVtaXQgfX19XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gb2JqZWN0LmVtaXRSZWR1Y2UoIGV2ZW50TmFtZSBbLCB2YWx1ZT0ge30gXSBbLCBhcmd1bWVudHMgLi4gXSApXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgby5lbWl0UmVkdWNlID0gZnVuY3Rpb24gKCkgeyAgLy8gLS0tIHt7e1xuXG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnROYW1lID0gYXJncy5zaGlmdCgpO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VmFsdWUgKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWUoYXJnc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3R4ID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3NXaXRoRXZlbnROYW1lID0gW2V2ZW50TmFtZV0uY29uY2F0KGFyZ3MpO1xuXG4gICAgICAgIF9kaXNwYXRjaChldmVudE5hbWUsIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShsaXN0ZW5lci5mbi5hcHBseShjdHgsIGFyZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gbGlzdGVuZXIuZm5bZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZm4uYXBwbHkobGlzdGVuZXIuZm4sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyLmZuLmVtaXRSZWR1Y2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1dpdGhFdmVudE5hbWVbMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUobGlzdGVuZXIuZm4uZW1pdFJlZHVjZS5hcHBseShsaXN0ZW5lci5mbiwgYXJnc1dpdGhFdmVudE5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gKGZuLCBib3VuZE9iaikge1xuXG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoZm4uYXBwbHkoYm91bmRPYmosIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICB9O1xuXG4gICAgLy8gLS0tIGVtaXQgfX19XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gb2JqZWN0LmZyb20oIGV2ZW50TmFtZSwgT2JzZXJ2YWJsZSApXG4gICAgLy9cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgICAgb2JqZWN0XG4gICAgLy8gICAgICAgICAgLmZyb20oJ2ZvbycsIFJ4Lk9ic2VydmFibGUpXG4gICAgLy8gICAgICAgICAgLmZpbHRlcih4ID0+IHggJSAyID09PSAwKVxuICAgIC8vICAgICAgICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgLy9cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBvLmZyb20gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBvYnNlcnZhYmxlKSB7ICAvLyAtLS0ge3t7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBvYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuXG4gICAgICAgICAgICB2YXIgaWQgPSBzZWxmLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGRhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vZmYoaWQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gLS0tIGZyb20gfX19XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gb2JqZWN0LnN1YnNjcmliZSggT2JzZXJ2YWJsZSwgb25OZXh0Wywgb25FcnJvcl1bLCBvbkNvbXBsZXRlXSApXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gICAgICBvYmplY3Quc3Vic2NyaWJlKGEsICd2YWx1ZScsICdlcnJvcicpOyAgIC8vIGEgPT4gT2JzZXJ2YWJsZVxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIG8uc3Vic2NyaWJlID0gZnVuY3Rpb24gKHNvdXJjZSwgb25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlKSB7ICAvLyAtLS0ge3t7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQob25OZXh0LCB2YWx1ZSk7XG4gICAgICAgIH0sIG9uRXJyb3IgPyBmdW5jdGlvbiAoZXJyb3JWYWx1ZSkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KG9uRXJyb3IsIGVycm9yVmFsdWUpO1xuICAgICAgICB9IDogdW5kZWZpbmVkLCBvbkNvbXBsZXRlID8gZnVuY3Rpb24gKGNvbXBsZXRlVmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdChvbkNvbXBsZXRlLCBjb21wbGV0ZVZhbHVlKTtcbiAgICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgfTtcblxuICAgIC8vIC0tLSBzdWJzY3JpYmUgfX19XG5cbiAgICByZXR1cm4gbztcblxufSAvLyA8PSBldmVudGl6ZSgpXG5cblxuZXZlbnRpemUuaXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICEhKCBvYmogJiYgb2JqW1BST1BfTkFNRVNQQUNFXSApO1xufTtcblxuXG5kZWZpbmVIaWRkZW5Qcm9wZXJ0eVJPKCBldmVudGl6ZSxcbiAgICAnRXZlbnRpemVOYW1lc3BhY2UnLCBQUk9QX05BTUVTUEFDRSk7XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBldmVudGl6ZS5xdWV1ZShbIHF1ZXVlSWQgXVssIG9wdGlvbnNdKSA6IHF1ZXVlXG4vL1xuLy8gb3B0aW9ucyBhcmU6XG4vLyAgICAtIHJlcGxhY2U6IHRydWV8ZmFsc2UgIC0gcmVwbGFjZSBwcmV2aW91cyBldmVudHMgd2l0aCBzYW1lIG5hbWVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHF1ZXVlIGlzIGluIGNvbGxlY3Rpb24gbW9kZVxuLy9cbi8vIHF1ZXVlLnBsYXkoKSAgICAgICAgICAgICAgLSBhY3RpdmF0ZSBwbGF5IChpbW1lZGlhdGVseSBlbWl0KSBtb2RlXG4vLyBxdWV1ZS5jb2xsZWN0KCkgICAgICAgICAgIC0gYWN0aXZhdGUgY29sbGVjdGlvbiAoc3RvcmUgYWxsIGV2ZW50cykgbW9kZVxuLy8gcXVldWUudG9nZ2xlKCkgICAgICAgICAgICAtIHRvZ2dsZSBzdGF0ZVxuLy8gcXVldWUuc3RhdGUgICAgICAgICAgICAgICAtICdwbGF5J3wnY29sbGVjdCdcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5kZWZpbmVIaWRkZW5Qcm9wZXJ0eVJPKGV2ZW50aXplLCAncXVldWVzJywgaGFzTWFwID8gbmV3IE1hcCA6IHt9KTtcblxuZXZlbnRpemUucXVldWUgPSBmdW5jdGlvbiAoaWQvKiwgb3B0aW9ucyAqLykge1xuXG4gICAgdmFyIHF1ZXVlLCBvcHRpb25zO1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdvYmplY3QnIHx8IGxlbiA9PT0gMikge1xuICAgICAgICAgICAgcXVldWUgPSBoYXNNYXAgPyBldmVudGl6ZS5xdWV1ZXMuZ2V0KGlkKSA6IGV2ZW50aXplLnF1ZXVlc1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPT09IDEgJiYgdHlwZW9mIGlkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgICBxdWV1ZSA9IGNyZWF0ZVF1ZXVlKGlkLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGhhc01hcCkge1xuICAgICAgICAgICAgZXZlbnRpemUucXVldWVzLnNldChxdWV1ZS5pZCwgcXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRpemUucXVldWVzW3F1ZXVlLmlkXSA9IHF1ZXVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlO1xuXG59O1xuXG5cbnZhciBTVEFURSA9ICdzdGF0ZSc7XG52YXIgUExBWSA9ICdwbGF5JztcbnZhciBDT0xMRUNUID0gJ2NvbGxlY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVRdWV1ZSAoaWQsIG9wdGlvbnMpIHtcblxuICAgIHZhciBxdWV1ZUlkID0gKCh0eXBlb2YgaWQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpZCA9PT0gJ3N5bWJvbCcpICYmIGlkKSB8fCBjcmVhdGVVdWlkKCk7XG4gICAgdmFyIHF1ZXVlID0gZXZlbnRpemUoe30pO1xuICAgIHZhciBpc1JlcGxhY2UgPSAhIShvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSk7XG5cbiAgICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgZGVmaW5lUHVibGljUHJvcGVydHlSTyhxdWV1ZSwgU1RBVEUsIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgdmFyIGVtaXQgPSAoZnVuY3Rpb24gKF9lbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIF9lbWl0LmFwcGx5KHF1ZXVlLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KShxdWV1ZS5lbWl0KTtcblxuICAgIGRlZmluZUhpZGRlblByb3BlcnR5Uk8ocXVldWUsICdldmVudHMnLCBbXSk7XG4gICAgZGVmaW5lUHVibGljUHJvcGVydHlSTyhxdWV1ZSwgJ2lkJywgcXVldWVJZCk7XG5cbiAgICBxdWV1ZS5jb2xsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocXVldWVbU1RBVEVdICE9PSBDT0xMRUNUKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShDT0xMRUNUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfTtcblxuICAgIHF1ZXVlLmVtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXVlW1NUQVRFXSA9PT0gUExBWSkge1xuICAgICAgICAgICAgZW1pdChhcmdzKTtcbiAgICAgICAgfSBlbHNlIHsgIC8vIENPTExFQ1RcbiAgICAgICAgICAgIGlmIChpc1JlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuLCBldmVudE5hbWUgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHF1ZXVlLmV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWUuZXZlbnRzW2ldWzBdID09PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmV2ZW50c1tpXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5ldmVudHMucHVzaChhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBxdWV1ZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocXVldWVbU1RBVEVdICE9PSBQTEFZKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShQTEFZKTtcbiAgICAgICAgICAgIHF1ZXVlLmV2ZW50cy5mb3JFYWNoKGVtaXQpO1xuICAgICAgICAgICAgcXVldWUuZXZlbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH07XG5cbiAgICBxdWV1ZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZVtTVEFURV0gIT09IFBMQVkgPyBxdWV1ZS5wbGF5KCkgOiBxdWV1ZS5jb2xsZWN0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBxdWV1ZS5wbGF5KCk7XG5cbn1cblxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBoZWxwZXIgZnVuY3Rpb25zXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuZnVuY3Rpb24gY3JlYXRlVXVpZCAoKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvY3JlYXRlLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XG4gICAgdmFyIHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSoxNnwwLCB2ID0gYyA9PSAneCcgPyByIDogKHImMHgzfDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFzU3ltYm9sID8gU3ltYm9sKHV1aWQpIDogdXVpZDtcbn1cblxuZnVuY3Rpb24gY2FuVXNlU3ltYm9sICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGNhblVzZU1hcCAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVQdWJsaWNQcm9wZXJ0eVJPIChvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICB2YWx1ZSAgICAgICAgOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZSAgIDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVB1YmxpY1Byb3BlcnRpZXNSTyAob2JqLCBhdHRycykge1xuICAgIHZhciBpLCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgIGZvciAoaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGRlZmluZVB1YmxpY1Byb3BlcnR5Uk8ob2JqLCBrZXlzW2ldLCBhdHRyc1trZXlzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUhpZGRlblByb3BlcnR5Uk8gKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgIHZhbHVlICAgICAgICA6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGUgOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG4vLyAtLS0gZW5kXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBldmVudGl6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BzcGVhcndvbGYvZXZlbnRpemUvc3JjL2V2ZW50aXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IGV2ZW50aXplID0gcmVxdWlyZSgnQHNwZWFyd29sZi9ldmVudGl6ZScpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm5cbiAgaWYgKG9iai5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmIChldmVudGl6ZS5pcyhvYmopICYmIHR5cGVvZiBvYmoub2ZmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVE9ETyBldmVudGl6ZS5kZXN0cm95KG9iailcbiAgICBvYmoub2ZmKClcbiAgfVxuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgIGRlbGV0ZSBvYmpba2V5XVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdkZXN0cm95ZWQnLCB7IHZhbHVlOiB0cnVlIH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvZGVzdHJveS5qcyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbi8qKlxuICogQ29tbW9uIHV0aWxpdGllc1xuICogQG1vZHVsZSBnbE1hdHJpeFxuICovXG5cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IGxldCBBUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZXhwb3J0IGNvbnN0IFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbmNvbnN0IGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tlbGVrdGl2L25vZGUtdXVpZFxuLyoqIEBwcml2YXRlICovXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZC92NCcpXG5cbmV4cG9ydCBkZWZhdWx0IHV1aWRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9nZW5lcmF0ZV91dWlkLmpzIiwiLyoqXG4gKiBHZW5lcmljIGNvbnRhaW5lciBmb3Igc2hhZGVyIHZhcmlhYmxlcy4gZWcuIHVuaWZvcm0sIHZlcnRleCBhdHRyaWJ1dGVzLCB0ZXh0dXJlcyAuLlxuICogQGRlc2NcbiAqIEVhY2ggdGltZSB5b3UgY2hhbmdlIHRoZSB2YWx1ZSwgYSBzZXJpYWwgbnVtYmVyIHdpbGwgYmUgaW5jcmVhc2VkLlxuICogVXNlIGAudG91Y2goKWAgaWYgeW91IHdhbnQgdG8gaW5jcmVhc2UgdGhlIHNlcmlhbCBudW1iZXIgd2l0aG91dCBjaGFuZ2luZyB0aGUgdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclZhcmlhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCB0eXBlLCB2YWx1ZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcmlhbCBudW1iZXIgaW5jcmVhc2VzIGVhY2ggdGltZSB5b3UgY2hhbmdlIHRoZSB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2VyaWFsID0gMFxuICB9XG5cbiAgZ2V0IHZhbHVlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVcbiAgfVxuXG4gIHNldCB2YWx1ZSAodmFsKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsXG4gICAgICArK3RoaXMuc2VyaWFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHNlcmlhbCBudW1iZXIuXG4gICAqL1xuICB0b3VjaCAoKSB7XG4gICAgKyt0aGlzLnNlcmlhbFxuICB9XG59XG5cblNoYWRlclZhcmlhYmxlLlRZUEUgPSBPYmplY3QuZnJlZXplKHtcbiAgVU5JRk9STTogJ3VuaWZvcm0nLFxuICBBVFRSSUI6ICdhdHRyaWInLFxuICBURVhUVVJFXzJEOiAndGV4MmQnXG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc2hhZGVyX3ZhcmlhYmxlLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZXNvdXJjZVJlZiBmcm9tICcuLi91dGlscy9yZXNvdXJjZV9yZWYnXG5cbmltcG9ydCB7IEJZVEVTX1BFUl9FTEVNRU5ULCBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiB9IGZyb20gJy4uL3V0aWxzL3R5cGVkX2FycmF5X2hlbHBlcnMnXG5cbi8qKlxuICogVmVydGV4IE9iamVjdCBBcnJheVxuICpcbiAqIEBjbGFzcyBWT0FycmF5XG4gKlxuICogQHBhcmFtIHtWT0Rlc2NyaXB0b3J9IGRlc2NyaXB0b3IgLSAqVmVydGV4IG9iamVjdCogZGVzY3JpcHRvclxuICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IC0gTWF4aW11bSBudW1iZXIgb2YgKnZlcnRleCBvYmplY3RzKlxuICogQHBhcmFtIHs/QXJyYXlCdWZmZXJ8RGF0YVZpZXd8RmxvYXQzMkFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VzYWdlPVZPQXJyYXkuVVNBR0UuRFlOQU1JQ10gdXNhZ2UgaGludFxuICogQHBhcmFtIHtib29sZWFufSBbYXV0b3RvdWNoXSBhdXRvdG91Y2hcbiAqXG4gKiBAZGVzY1xuICogQW4gYXJyYXkgb2YgKnZlcnRleCBvYmplY3RzKi5cbiAqIEhhcyBhIG1heGltdW0gY2FwYWNpdHkgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSAqdmVydGV4IG9iamVjdCBkZXNjcmlwdG9yKi5cbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVk9BcnJheSB7XG4gIGNvbnN0cnVjdG9yIChkZXNjcmlwdG9yLCBjYXBhY2l0eSwgZGF0YSwgdXNhZ2UgPSBWT0FycmF5LlVTQUdFLkRZTkFNSUMsIGF1dG90b3VjaCA9IHVuZGVmaW5lZCkge1xuICAgIC8qKiBAdHlwZSB7UmVzb3VyY2VSZWZ9ICovXG4gICAgdGhpcy5yZXNvdXJjZVJlZiA9IG5ldyBSZXNvdXJjZVJlZih0aGlzLCB7IHVzYWdlIH0pXG5cbiAgICAvKiogQHR5cGUge1ZPRGVzY3JpcHRvcn0gKi9cbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSlcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgdGhpcy5mbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCAvIDQpXG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICB0aGlzLmZsb2F0MzJBcnJheSA9IGRhdGFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG5ldyBBcnJheUJ1ZmZlcihjYXBhY2l0eSAqIGRlc2NyaXB0b3IuYnl0ZXNQZXJWTykpXG4gICAgfVxuXG4gICAgLy8gbmVlZGVkIGJ5IFdlYkdsUmVuZGVyZXIjc3luY0J1ZmZlclxuICAgIHRoaXMucmVzb3VyY2VSZWYuaGludHMudHlwZWRBcnJheSA9IHRoaXMuZmxvYXQzMkFycmF5XG5cbiAgICBjb25zdCB7IGJ1ZmZlciwgYnVmZmVyQnl0ZU9mZnNldCwgYnVmZmVyQnl0ZUxlbmd0aCB9ID0gdGhpc1xuICAgIGRlc2NyaXB0b3IudHlwZUxpc3QuZmlsdGVyKHR5cGUgPT4gdHlwZSAhPT0gJ2Zsb2F0MzInKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgdGhpc1tgJHt0eXBlfUFycmF5YF0gPSBuZXcgKFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SW3R5cGVdKShidWZmZXIsIGJ1ZmZlckJ5dGVPZmZzZXQsIGJ1ZmZlckJ5dGVMZW5ndGggLyBCWVRFU19QRVJfRUxFTUVOVFt0eXBlXSlcbiAgICB9KVxuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuZW5hYmxlQXV0b3RvdWNoID0gdHlwZW9mIGF1dG90b3VjaCA9PT0gJ2Jvb2xlYW4nID8gYXV0b3RvdWNoIDogdXNhZ2UgPT09IFZPQXJyYXkuVVNBR0UuRFlOQU1JQ1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIGluY3JlYXNlIHNlcmlhbCB2YWx1ZSBmcm9tIHJlc291cmNlIHJlZmVyZW5jZVxuICAgKi9cbiAgdG91Y2ggKCkge1xuICAgIHRoaXMucmVzb3VyY2VSZWYuc2VyaWFsLnRvdWNoKClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7QXJyYXlCdWZmZXJ9ICovXG4gIGdldCBidWZmZXIgKCkge1xuICAgIHJldHVybiB0aGlzLmZsb2F0MzJBcnJheS5idWZmZXJcbiAgfVxuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBnZXQgYnVmZmVyQnl0ZU9mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxvYXQzMkFycmF5LmJ5dGVPZmZzZXRcbiAgfVxuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBnZXQgYnVmZmVyQnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxvYXQzMkFycmF5LmJ5dGVMZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5ICoqYWxsKiogKnZlcnRleCBvYmplY3QqIGRhdGEgZnJvbSBhbiBleHRlcm5hbCB2ZXJ0ZXggYXJyYXkgdG8gdGhlIGludGVybmFsIGFycmF5XG4gICAqIEBwYXJhbSB7Vk9BcnJheX0gZnJvbVZPQXJyYXkgLSBUaGUgc291cmNlIHZlcnRleCBhcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RvT2Zmc2V0PTBdIC0gKlZlcnRleCBvYmplY3QqIG9mZnNldCBmb3IgdGhlIGludGVybmFsIHZlcnRleCBhcnJheVxuICAgKi9cbiAgY29weSAoZnJvbVZPQXJyYXksIHRvT2Zmc2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIGlmICh0b09mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvZmZzZXQgPSB0b09mZnNldCAqICh0aGlzLmRlc2NyaXB0b3IuYnl0ZXNQZXJWTyA+PiAyKVxuICAgIH1cblxuICAgIHRoaXMuZmxvYXQzMkFycmF5LnNldChmcm9tVk9BcnJheS5mbG9hdDMyQXJyYXksIG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBWT0FycmF5ICpzdWIqIGFycmF5XG4gICAqIEBkZXNjXG4gICAqIFRoaXMgd2lsbCAqKm5vdCoqICpjb3B5KiB0aGUgaW50ZXJuYWwgdmVydGV4IGRhdGEgLSB0aGlzIHdpbGwgY3JlYXRlIGEgbmV3IHZpZXcgaW50byB0aGUgaW50ZXJuYWwgYnVmZmVyLlxuICAgKiBCb3RoICh0aGUgbmV3IFZPQXJyYXkgYW5kIHRoZSBjdXJyZW50IG9uZSkgd2lsbCBzaGFyZSB0aGVcbiAgICogc2FtZSBtZW1vcnkgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gLSBJbmRleCBvZiBmaXJzdCB2ZXJ0ZXggb2JqZWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXVxuICAgKiBAcmV0dXJuIHtWT0FycmF5fVxuICAgKi9cbiAgc3ViYXJyYXkgKGJlZ2luLCBzaXplID0gMSkge1xuICAgIHJldHVybiBuZXcgVk9BcnJheSh0aGlzLmRlc2NyaXB0b3IsIHNpemUsXG4gICAgICBuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIsXG4gICAgICAgICh0aGlzLmJ1ZmZlckJ5dGVPZmZzZXQgKyAoYmVnaW4gKiB0aGlzLmRlc2NyaXB0b3IuYnl0ZXNQZXJWTykpLFxuICAgICAgICBzaXplICogdGhpcy5kZXNjcmlwdG9yLmJ5dGVzUGVyVk8pKVxuICB9XG59XG5cblZPQXJyYXkuVVNBR0UgPSBPYmplY3QuZnJlZXplKHtcbiAgU1RBVElDOiAnc3RhdGljJyxcbiAgRFlOQU1JQzogJ2R5bmFtaWMnXG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvdl9vX2FycmF5LmpzIiwiaW1wb3J0IGdlbmVyYXRlVXVpZCBmcm9tICcuL2dlbmVyYXRlX3V1aWQnXG5pbXBvcnQgU2VyaWFsIGZyb20gJy4vc2VyaWFsJ1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZXNvdXJjZSByZWZlcmVuY2Ugd2hpY2ggcG9pbnRzIHRvIGEgKnJlbmRlcmFibGUgcmVzb3VyY2UqLlxuICogRXZlcnkgcmVzb3VyY2UgaGFzIGFuIGlkLCBzZXJpYWwgYW5kIHBvc3NpYmxlIHJlc291cmNlIGFsbG9jYXRpb24gKmhpbnRzKi5cbiAqIFRoZSByZXNvdXJjZSByZWZlcmVuY2Ugd2lsbCBiZSB1c2VkIGJ5IHRoZSByZXNvdXJjZSBsaWJyYXJ5IHRvIGZpbmQgb3JcbiAqIGNyZWF0ZSAqcmVuZGVyYWJsZSByZXNvdXJjZXMqIChsaWtlIFdlYkdsQnVmZmVyLCBXZWJHbFRleHR1cmUsIC4uKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzb3VyY2VSZWYge1xuICBjb25zdHJ1Y3RvciAocmVzb3VyY2UsIGhpbnRzID0ge30pIHtcbiAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2VcbiAgICB0aGlzLmhpbnRzID0gaGludHNcbiAgICB0aGlzLmlkID0gaGludHMuaWQgfHwgZ2VuZXJhdGVVdWlkKClcbiAgICB0aGlzLnNlcmlhbCA9IG5ldyBTZXJpYWwodHlwZW9mIGhpbnRzLnNlcmlhbCA9PT0gJ251bWJlcicgPyBoaW50cy5zZXJpYWwgOiAxKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzb3VyY2VSZWZ9IHNvdXJjZVJlZlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU3luY2VkIChzb3VyY2VSZWYpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnNlcmlhbFxuICAgIHJldHVybiB2YWx1ZSA+IDAgJiYgdmFsdWUgPT09IHNvdXJjZVJlZi5zZXJpYWwudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Jlc291cmNlUmVmfSBzb3VyY2VSZWZcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBuZWVkU3luYyAoc291cmNlUmVmKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzU3luY2VkKHNvdXJjZVJlZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Jlc291cmNlUmVmfSBzb3VyY2VSZWZcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcbiAgICovXG4gIHN5bmMgKHNvdXJjZVJlZiwgY2IpIHtcbiAgICBpZiAodGhpcy5uZWVkU3luYyhzb3VyY2VSZWYpKSB7XG4gICAgICBjYih0aGlzLnJlc291cmNlKVxuICAgICAgdGhpcy5zZXJpYWwudmFsdWUgPSBzb3VyY2VSZWYuc2VyaWFsLnZhbHVlXG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvcmVzb3VyY2VfcmVmLmpzIiwiXG4vKiogQHByaXZhdGUgKi9cbmNvbnN0IEJZVEVTX1BFUl9FTEVNRU5UID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGZsb2F0MzI6IDQsXG4gIGludDE2OiAyLFxuICBpbnQzMjogNCxcbiAgaW50ODogMSxcbiAgdWludDE2OiAyLFxuICB1aW50MzI6IDQsXG4gIHVpbnQ4OiAxXG59KVxuXG4vKiogQHByaXZhdGUgKi9cbmNvbnN0IFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGZsb2F0MzI6IEZsb2F0MzJBcnJheSxcbiAgaW50MTY6IEludDE2QXJyYXksXG4gIGludDMyOiBJbnQzMkFycmF5LFxuICBpbnQ4OiBJbnQ4QXJyYXksXG4gIHVpbnQxNjogVWludDE2QXJyYXksXG4gIHVpbnQzMjogVWludDMyQXJyYXksXG4gIHVpbnQ4OiBVaW50OEFycmF5XG59KVxuXG4vKiogQHByaXZhdGUgKi9cbmNvbnN0IFRZUEVEX0FSUkFZX0dFVFRFUiA9IE9iamVjdC5mcmVlemUoe1xuICBmbG9hdDMyOiAob2JqKSA9PiBvYmouZmxvYXQzMkFycmF5LFxuICBpbnQzMjogKG9iaikgPT4gb2JqLmludDMyQXJyYXksXG4gIGludDE2OiAob2JqKSA9PiBvYmouaW50MTZBcnJheSxcbiAgaW50ODogKG9iaikgPT4gb2JqLmludDhBcnJheSxcbiAgdWludDMyOiAob2JqKSA9PiBvYmoudWludDMyQXJyYXksXG4gIHVpbnQxNjogKG9iaikgPT4gb2JqLnVpbnQxNkFycmF5LFxuICB1aW50ODogKG9iaikgPT4gb2JqLnVpbnQ4QXJyYXlcbn0pXG5cbi8qKiBAcHJpdmF0ZSAqL1xuY29uc3QgR0xfSVRFTV9UWVBFUyA9IE9iamVjdC5mcmVlemUoe1xuICBmbG9hdDMyOiAnRkxPQVQnLFxuICBpbnQxNjogJ1NIT1JUJyxcbiAgaW50MzI6ICdJTlQnLFxuICBpbnQ4OiAnQllURScsXG4gIHVpbnQxNjogJ1VOU0lHTkVEX1NIT1JUJyxcbiAgdWludDMyOiAnVU5TSUdORURfSU5UJyxcbiAgdWludDg6ICdVTlNJR05FRF9CWVRFJ1xufSlcblxuZXhwb3J0IHtcbiAgQllURVNfUEVSX0VMRU1FTlQsXG4gIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SLFxuICBUWVBFRF9BUlJBWV9HRVRURVIsXG4gIEdMX0lURU1fVFlQRVNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy90eXBlZF9hcnJheV9oZWxwZXJzLmpzIiwiaW1wb3J0IHsgQllURVNfUEVSX0VMRU1FTlQsIFRZUEVEX0FSUkFZX0dFVFRFUiB9IGZyb20gJy4uL3V0aWxzL3R5cGVkX2FycmF5X2hlbHBlcnMnXG5cbi8qKlxuICogVmVydGV4IG9iamVjdCAqYXR0cmlidXRlKiBkZXNjcmlwdG9yLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWT0F0dHJEZXNjcmlwdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSAtIGVpdGhlciBgb2Zmc2V0YCBvciBgYnl0ZU9mZnNldGAgbXVzdCBiZSBzcGVjaWZpZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtieXRlT2Zmc2V0XSAtIGVpdGhlciBgb2Zmc2V0YCBvciBgYnl0ZU9mZnNldGAgbXVzdCBiZSBzcGVjaWZpZWRcbiAgICogQHBhcmFtIHtib29sZWFufSB1bmlmb3JtXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFthdHRyTmFtZXNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgdHlwZSwgc2l6ZSwgb2Zmc2V0LCBieXRlT2Zmc2V0LCB1bmlmb3JtLCBhdHRyTmFtZXMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMuc2l6ZSA9IHNpemVcbiAgICB0aGlzLnVuaWZvcm0gPSB1bmlmb3JtXG4gICAgdGhpcy5hdHRyTmFtZXMgPSBhdHRyTmFtZXNcblxuICAgIHRoaXMuYnl0ZXNQZXJFbGVtZW50ID0gQllURVNfUEVSX0VMRU1FTlRbIHRoaXMudHlwZSBdXG4gICAgdGhpcy5ieXRlc1BlclZlcnRleCA9IHRoaXMuYnl0ZXNQZXJFbGVtZW50ICogc2l6ZVxuXG4gICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gb2Zmc2V0ICogdGhpcy5ieXRlc1BlckVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldFxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vZmZzZXQgPSBieXRlT2Zmc2V0IC8gdGhpcy5ieXRlc1BlckVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGF0dHJpYnV0ZXMgcGVyIHZlcnRleFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdmVydGV4QXR0ckNvdW50IChkZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3IuYnl0ZXNQZXJWZXJ0ZXggLyB0aGlzLmJ5dGVzUGVyRWxlbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVmaW5lUHJvcGVydGllcyAoYXR0ckRlc2MsIHByb3BlcnRpZXNPYmplY3QsIGRlc2NyaXB0b3IpIHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGF0dHJEZXNjXG4gICAgY29uc3QgZ2V0QXJyYXkgPSBUWVBFRF9BUlJBWV9HRVRURVJbYXR0ckRlc2MudHlwZV1cbiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGRlc2NyaXB0b3IudmVydGV4Q291bnRcbiAgICBjb25zdCB2ZXJ0ZXhBdHRyQ291bnQgPSBhdHRyRGVzYy52ZXJ0ZXhBdHRyQ291bnQoZGVzY3JpcHRvcilcbiAgICBjb25zdCBvZmZzZXQgPSBhdHRyRGVzYy5ieXRlT2Zmc2V0IC8gYXR0ckRlc2MuYnl0ZXNQZXJFbGVtZW50XG5cbiAgICBsZXQgaSwgalxuXG4gICAgaWYgKGF0dHJEZXNjLnNpemUgPT09IDEpIHtcbiAgICAgIGlmIChhdHRyRGVzYy51bmlmb3JtKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlR2V0dGVyID0gZ2V0VjF1KGdldEFycmF5LCBvZmZzZXQpXG4gICAgICAgIGNvbnN0IHZhbHVlU2V0dGVyID0gc2V0VjF1KGdldEFycmF5LCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXR0ckNvdW50LCBvZmZzZXQpXG5cbiAgICAgICAgYXR0ckRlc2MuZ2V0VmFsdWUgPSAodm8pID0+IHZhbHVlR2V0dGVyLmNhbGwodm8pXG4gICAgICAgIGF0dHJEZXNjLnNldFZhbHVlID0gKHZvLCBhcmcpID0+IHZhbHVlU2V0dGVyLmNhbGwodm8sIGFyZylcblxuICAgICAgICBwcm9wZXJ0aWVzT2JqZWN0WyBuYW1lIF0gPSB7XG4gICAgICAgICAgZ2V0OiB2YWx1ZUdldHRlcixcbiAgICAgICAgICBzZXQ6IHZhbHVlU2V0dGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVTZXR0ZXIgPSBzZXRWTnYoZ2V0QXJyYXksIDEsIHZlcnRleENvdW50LCB2ZXJ0ZXhBdHRyQ291bnQsIG9mZnNldClcblxuICAgICAgICBhdHRyRGVzYy5zZXRWYWx1ZSA9ICh2bywgYXJncykgPT4gdmFsdWVTZXR0ZXIuYXBwbHkodm8sIGFyZ3MpXG5cbiAgICAgICAgcHJvcGVydGllc09iamVjdFsgJ3NldCcgKyBjYW1lbGl6ZShuYW1lKSBdID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVNldHRlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUdldHRlcnMgPSBbXVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLnZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgICBjb25zdCBjdXJWYWx1ZUdldHRlciA9IGdldFYxdShnZXRBcnJheSwgb2Zmc2V0ICsgKGkgKiB2ZXJ0ZXhBdHRyQ291bnQpKVxuXG4gICAgICAgICAgdmFsdWVHZXR0ZXJzLnB1c2goY3VyVmFsdWVHZXR0ZXIpXG5cbiAgICAgICAgICBwcm9wZXJ0aWVzT2JqZWN0WyBuYW1lICsgaSBdID0ge1xuXG4gICAgICAgICAgICBnZXQ6IGN1clZhbHVlR2V0dGVyLFxuICAgICAgICAgICAgc2V0OiBzZXRWTnYoZ2V0QXJyYXksIDEsIDEsIDAsIG9mZnNldCArIChpICogdmVydGV4QXR0ckNvdW50KSksXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyRGVzYy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICh2bywgdmkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVHZXR0ZXJzW3ZpXS5jYWxsKHZvKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyRGVzYy5zaXplID49IDIpIHtcbiAgICAgIGlmIChhdHRyRGVzYy51bmlmb3JtKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlR2V0dGVyID0gZ2V0Vk51KGdldEFycmF5LCBvZmZzZXQpXG4gICAgICAgIGNvbnN0IHZhbHVlU2V0dGVyID0gc2V0Vk51KGdldEFycmF5LCBhdHRyRGVzYy5zaXplLCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXR0ckNvdW50LCBvZmZzZXQpXG5cbiAgICAgICAgYXR0ckRlc2MuZ2V0VmFsdWUgPSAodm8sIHZpLCBpZHgpID0+IHZhbHVlR2V0dGVyLmNhbGwodm8sIGlkeClcbiAgICAgICAgYXR0ckRlc2Muc2V0VmFsdWUgPSAodm8sIGFyZ3MpID0+IHZhbHVlU2V0dGVyLmFwcGx5KHZvLCBhcmdzKVxuXG4gICAgICAgIHByb3BlcnRpZXNPYmplY3RbICdnZXQnICsgY2FtZWxpemUobmFtZSkgXSA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllc09iamVjdFsgJ3NldCcgKyBjYW1lbGl6ZShuYW1lKSBdID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVNldHRlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0ckRlc2Muc2l6ZTsgKytpKSB7XG4gICAgICAgICAgY29uc3Qgc2V0dGVyTmFtZSA9IGF0dHJQb3N0Zml4KGF0dHJEZXNjLCBuYW1lLCBpKVxuXG4gICAgICAgICAgcHJvcGVydGllc09iamVjdFsgc2V0dGVyTmFtZSBdID0ge1xuXG4gICAgICAgICAgICBnZXQ6IGdldFYxdShnZXRBcnJheSwgb2Zmc2V0ICsgaSksXG4gICAgICAgICAgICBzZXQ6IHNldFYxdShnZXRBcnJheSwgdmVydGV4Q291bnQsIHZlcnRleEF0dHJDb3VudCwgb2Zmc2V0ICsgaSksXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlU2V0dGVyID0gc2V0Vk52KGdldEFycmF5LCBhdHRyRGVzYy5zaXplLCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXR0ckNvdW50LCBvZmZzZXQpXG5cbiAgICAgICAgYXR0ckRlc2Muc2V0VmFsdWUgPSAodm8sIGFyZ3MpID0+IHZhbHVlU2V0dGVyLmFwcGx5KHZvLCBhcmdzKVxuXG4gICAgICAgIHByb3BlcnRpZXNPYmplY3RbICdzZXQnICsgY2FtZWxpemUobmFtZSkgXSA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVTZXR0ZXIsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWVHZXR0ZXJzID0gW11cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci52ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgY3VyVmVydGV4VmFsdWVHZXR0ZXJzID0gW11cblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhdHRyRGVzYy5zaXplOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRlck5hbWUgPSBhdHRyUG9zdGZpeChhdHRyRGVzYywgbmFtZSwgaikgKyBpXG4gICAgICAgICAgICBjb25zdCBjdXJWYWx1ZUdldHRlciA9IGdldFYxdShnZXRBcnJheSwgb2Zmc2V0ICsgKGkgKiB2ZXJ0ZXhBdHRyQ291bnQpICsgailcblxuICAgICAgICAgICAgY3VyVmVydGV4VmFsdWVHZXR0ZXJzLnB1c2goY3VyVmFsdWVHZXR0ZXIpXG5cbiAgICAgICAgICAgIHByb3BlcnRpZXNPYmplY3RbIHNldHRlck5hbWUgXSA9IHtcblxuICAgICAgICAgICAgICBnZXQ6IGN1clZhbHVlR2V0dGVyLFxuICAgICAgICAgICAgICBzZXQ6IHNldFZOdihnZXRBcnJheSwgMSwgMSwgMCwgb2Zmc2V0ICsgKGkgKiB2ZXJ0ZXhBdHRyQ291bnQpICsgaiksXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlR2V0dGVycy5wdXNoKGN1clZlcnRleFZhbHVlR2V0dGVycylcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJEZXNjLmdldFZhbHVlID0gZnVuY3Rpb24gKHZvLCB2aSwgaWR4KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlR2V0dGVyc1t2aV1baWR4XS5jYWxsKHZvKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gYXR0clBvc3RmaXggKGF0dHJEZXNjLCBuYW1lLCBpbmRleCkge1xuICBpZiAoYXR0ckRlc2MuYXR0ck5hbWVzKSB7XG4gICAgbGV0IHBvc3RmaXggPSBhdHRyRGVzYy5hdHRyTmFtZXNbIGluZGV4IF1cblxuICAgIGlmIChwb3N0Zml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwb3N0Zml4XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnXycgKyBpbmRleFxufVxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGdldFZOdSAoZ2V0QXJyYXksIG9mZnNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGF0dHJJbmRleCkge1xuICAgIHJldHVybiBnZXRBcnJheSh0aGlzLnZvQXJyYXkpWyBvZmZzZXQgKyBhdHRySW5kZXggXVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gc2V0Vk51IChnZXRBcnJheSwgdmVjdG9yTGVuZ3RoLCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXR0ckNvdW50LCBvZmZzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfYXJyYXkgPSBnZXRBcnJheSh0aGlzLnZvQXJyYXkpXG4gICAgbGV0IGlcbiAgICBsZXQgblxuXG4gICAgZm9yIChpID0gMDsgaSA8IHZlcnRleENvdW50OyArK2kpIHtcbiAgICAgIGZvciAobiA9IDA7IG4gPCB2ZWN0b3JMZW5ndGg7ICsrbikge1xuICAgICAgICBfYXJyYXlbIChpICogdmVydGV4QXR0ckNvdW50KSArIG9mZnNldCArIG4gXSA9IGFyZ3VtZW50c1tuXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGdldFYxdSAoZ2V0QXJyYXksIG9mZnNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRBcnJheSh0aGlzLnZvQXJyYXkpWyBvZmZzZXQgXVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gc2V0Vk52IChnZXRBcnJheSwgdmVjdG9yTGVuZ3RoLCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXR0ckNvdW50LCBvZmZzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfYXJyYXkgPSBnZXRBcnJheSh0aGlzLnZvQXJyYXkpXG4gICAgbGV0IGlcbiAgICBsZXQgblxuXG4gICAgZm9yIChpID0gMDsgaSA8IHZlcnRleENvdW50OyArK2kpIHtcbiAgICAgIGZvciAobiA9IDA7IG4gPCB2ZWN0b3JMZW5ndGg7ICsrbikge1xuICAgICAgICBfYXJyYXlbKGkgKiB2ZXJ0ZXhBdHRyQ291bnQpICsgb2Zmc2V0ICsgbl0gPSBhcmd1bWVudHNbKGkgKiB2ZWN0b3JMZW5ndGgpICsgbl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBzZXRWMXUgKGdldEFycmF5LCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXR0ckNvdW50LCBvZmZzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGNvbnN0IF9hcnJheSA9IGdldEFycmF5KHRoaXMudm9BcnJheSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgX2FycmF5WyAoaSAqIHZlcnRleEF0dHJDb3VudCkgKyBvZmZzZXQgXSA9IHZhbHVlXG4gICAgfVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gY2FtZWxpemUgKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3Zfb19hdHRyX2Rlc2NyaXB0b3IuanMiLCJpbXBvcnQgUG93ZXJPZjJJbWFnZSBmcm9tICcuL3Bvd2VyX29mXzJfaW1hZ2UnXG5pbXBvcnQgUmVzb3VyY2VSZWYgZnJvbSAnLi4vdXRpbHMvcmVzb3VyY2VfcmVmJ1xuXG5jb25zdCBnZXRPcHRpb24gPSAob3B0aW9ucywga2V5LCBkZWZhdWx0VmFsdWUpID0+IG9wdGlvbnMgIT0gbnVsbFxuICA/IChvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRWYWx1ZSkgOiBkZWZhdWx0VmFsdWVcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIGhvbGRzIGEgcmVmZXJlbmNlIHRvIGEgYDxpbWc+YCBvciBgPGNhbnZhcz5gIGVsZW1lbnQuXG4gKiBUZXh0dXJlcyBjYW4gZm9ybSBoaWVyYWNoaWNhbCBzdHJ1Y3R1cmVzLlxuICogVGhlICpyb290KiB0ZXh0dXJlIGNvbnRhaW5zIGFsd2F5cyB0aGUgaW1hZ2UgcmVmZXJlbmNlLCBhbGwgb3RoZXIgKnN1YiogdGV4dHVyZXMgY29udGFpblxuICogcmVmZXJlbmNlcyB0byB0aGVpciBwYXJlbnQgKGFuZCB0aGUgcm9vdCkuXG4gKlxuICogQGNsYXNzIFRleHR1cmVcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuICogY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGNhbnZhcylcbiAqIHRleHR1cmUud2lkdGggICAgLy8gPT4gMzAwIDwtIGRlZmF1bHQgc2l6ZSBvZiA8Y2FudmFzPiBlbGVtZW50XG4gKiB0ZXh0dXJlLmhlaWdodCAgIC8vID0+IDE1MFxuICpcbiAqIGxldCBzdWJUZXggPSBuZXcgVGV4dHVyZSh0ZXh0dXJlLCAzMCwgMTUsIDEwMCwgMTAwKVxuICogc3ViVGV4LndpZHRoICAgIC8vID0+IDEwMFxuICpcbiAqIFRleHR1cmUubG9hZCgndGVzdC9hc3NldHMvYmlyZC1jaGlja2VuLXBlbmd1aW4ucG5nJykudGhlbih0ZXggPT4ge1xuICogICB0ZXgud2lkdGggICAgLy8gPT4gNjQwXG4gKiAgIHRleC5oZWlnaHQgICAvLyA9PiA0ODBcbiAqIH0pXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RleHR1cmV8UG93ZXJPZjJJbWFnZXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2UgLSBpbWFnZSBlbGVtZW50cyBtdXN0IGJlICpjb21wbGV0ZWQqIChsb2FkZWQpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaGludHNdIHRleHR1cmUgaGludHNcbiAgICogQHBhcmFtIHtib29sZWFufSBbaGludHMuZmxpcFk9ZmFsc2VdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpbnRzLnJlcGVhdGFibGU9ZmFsc2VdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpbnRzLnByZW11bHRpcGx5QWxwaGE9dHJ1ZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChzb3VyY2UsIHdpZHRoLCBoZWlnaHQsIHggPSAwLCB5ID0gMCwgaGludHMgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5wYXJlbnQgPSBzb3VyY2VcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1Bvd2VyT2YySW1hZ2V8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy5pbWFnZSA9IG51bGxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmICd3aWR0aCcgaW4gc291cmNlICYmICdoZWlnaHQnIGluIHNvdXJjZSkge1xuICAgICAgdGhpcy5pbWFnZSA9IHNvdXJjZVxuICAgICAgdGhpcy5wYXJlbnQgPSBudWxsXG5cbiAgICAgIHRoaXMuX3Jlc291cmNlUmVmID0gbmV3IFJlc291cmNlUmVmKHRoaXMsIHtcbiAgICAgICAgZmxpcFk6IGdldE9wdGlvbihoaW50cywgJ2ZsaXBZJywgZmFsc2UpLFxuICAgICAgICByZXBlYXRhYmxlOiBnZXRPcHRpb24oaGludHMsICdyZXBlYXRhYmxlJywgZmFsc2UpLFxuICAgICAgICBwcmVtdWx0aXBseUFscGhhOiBnZXRPcHRpb24oaGludHMsICdwcmVtdWx0aXBseUFscGhhJywgdHJ1ZSksXG4gICAgICAgIG5lYXJlc3Q6IGdldE9wdGlvbihoaW50cywgJ25lYXJlc3QnLCBmYWxzZSlcbiAgICAgIH0pXG5cbiAgICAgIGlmICgnb3JpZ1dpZHRoJyBpbiBzb3VyY2UgJiYgJ29yaWdIZWlnaHQnIGluIHNvdXJjZSkge1xuICAgICAgICB3aWR0aCA9IHNvdXJjZS5vcmlnV2lkdGhcbiAgICAgICAgaGVpZ2h0ID0gc291cmNlLm9yaWdIZWlnaHRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgVGV4dHVyZSgpIHBhbmljOiB1bmV4cGVjdGVkIHNvdXJjZSBhcmd1bWVudCEnKVxuICAgIH1cblxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGhcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHRcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy54ID0geFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy55ID0geVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHJvb3QgKCkge1xuICAgIHJldHVybiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucm9vdCkgfHwgdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGltZ0VsICgpIHtcbiAgICBjb25zdCB7IHJvb3QgfSA9IHRoaXNcbiAgICByZXR1cm4gcm9vdC5pbWFnZS5pbWdFbCB8fCByb290LmltYWdlXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1Jlc291cmNlUmVmfVxuICAgKi9cbiAgZ2V0IHJlc291cmNlUmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VSZWYgfHwgdGhpcy5yb290LnJlc291cmNlUmVmXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCAoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5fd2lkdGggPT09ICdudW1iZXInXG4gICAgICA/IHRoaXMuX3dpZHRoXG4gICAgICA6ICh0aGlzLmltYWdlXG4gICAgICAgID8gdGhpcy5pbWFnZS53aWR0aFxuICAgICAgICA6ICh0aGlzLnBhcmVudFxuICAgICAgICAgID8gdGhpcy5yb290LndpZHRoXG4gICAgICAgICAgOiAwXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBzZXQgd2lkdGggKHcpIHtcbiAgICB0aGlzLl93aWR0aCA9IHdcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCAoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5faGVpZ2h0ID09PSAnbnVtYmVyJ1xuICAgICAgPyB0aGlzLl9oZWlnaHRcbiAgICAgIDogKHRoaXMuaW1hZ2VcbiAgICAgICAgPyB0aGlzLmltYWdlLmhlaWdodFxuICAgICAgICA6ICh0aGlzLnBhcmVudFxuICAgICAgICAgID8gdGhpcy5yb290LmhlaWdodFxuICAgICAgICAgIDogMFxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgc2V0IGhlaWdodCAoaCkge1xuICAgIHRoaXMuX2hlaWdodCA9IGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pblMgKCkge1xuICAgIGxldCB4ID0gdGhpcy54XG4gICAgbGV0IHRleHR1cmUgPSB0aGlzXG5cbiAgICB3aGlsZSAoKHRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudCkgIT0gbnVsbCkge1xuICAgICAgeCArPSB0ZXh0dXJlLnhcbiAgICB9XG5cbiAgICByZXR1cm4geCAvIHRoaXMucm9vdC5pbWFnZS53aWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWluVCAoKSB7XG4gICAgbGV0IHkgPSB0aGlzLnlcbiAgICBsZXQgdGV4dHVyZSA9IHRoaXNcblxuICAgIHdoaWxlICgodGV4dHVyZSA9IHRleHR1cmUucGFyZW50KSAhPSBudWxsKSB7XG4gICAgICB5ICs9IHRleHR1cmUueVxuICAgIH1cblxuICAgIHJldHVybiB5IC8gdGhpcy5yb290LmltYWdlLmhlaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4UyAoKSB7XG4gICAgbGV0IHggPSB0aGlzLnggKyB0aGlzLndpZHRoXG4gICAgbGV0IHRleHR1cmUgPSB0aGlzXG5cbiAgICB3aGlsZSAoKHRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudCkgIT0gbnVsbCkge1xuICAgICAgeCArPSB0ZXh0dXJlLnhcbiAgICB9XG5cbiAgICByZXR1cm4geCAvIHRoaXMucm9vdC5pbWFnZS53aWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4VCAoKSB7XG4gICAgbGV0IHkgPSB0aGlzLnkgKyB0aGlzLmhlaWdodFxuICAgIGxldCB0ZXh0dXJlID0gdGhpc1xuXG4gICAgd2hpbGUgKCh0ZXh0dXJlID0gdGV4dHVyZS5wYXJlbnQpICE9IG51bGwpIHtcbiAgICAgIHkgKz0gdGV4dHVyZS55XG4gICAgfVxuXG4gICAgcmV0dXJuIHkgLyB0aGlzLnJvb3QuaW1hZ2UuaGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICAqIExvYWRzIGFuIGltYWdlIGZyb20gdXJsIGFuZCByZXR1cm5zIGEgdGV4dHVyZS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGV4dHVyZUhpbnRzXVxuICAgICogQHJldHVybnMge1Byb21pc2U8VGV4dHVyZT59XG4gICAgKi9cbiAgc3RhdGljIGxvYWQgKHVybCwgdGV4dHVyZUhpbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBQb3dlck9mMkltYWdlKHVybCkuY29tcGxldGUudGhlbihwMmltZyA9PiBuZXcgVGV4dHVyZShwMmltZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDAsIDAsIHRleHR1cmVIaW50cykpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3RleHR1cmUuanMiLCJcbi8qKlxuICogR3JvdXAgb2Ygc2hhZGVyIHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyVmFyaWFibGVHcm91cCB7XG4gIC8qKlxuICAqIEBwYXJhbSB7QXJyYXk8U2hhZGVyVmFyaWFibGV8U2hhZGVyVmFyaWFibGVBbGlhcz59IHNoYWRlclZhcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzaGFkZXJWYXJzKSB7XG4gICAgdGhpcy5zaGFkZXJWYXJzID0gc2hhZGVyVmFyc1xuICB9XG5cbiAgcHVzaFZhciAoc2hhZGVyQ29udGV4dCkge1xuICAgIHRoaXMuc2hhZGVyVmFycy5mb3JFYWNoKHNoYWRlckNvbnRleHQucHVzaFZhci5iaW5kKHNoYWRlckNvbnRleHQpKVxuICB9XG5cbiAgcG9wVmFyIChzaGFkZXJDb250ZXh0KSB7XG4gICAgdGhpcy5zaGFkZXJWYXJzLmZvckVhY2goc2hhZGVyQ29udGV4dC5wb3BWYXIuYmluZChzaGFkZXJDb250ZXh0KSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc2hhZGVyX3ZhcmlhYmxlX2dyb3VwLmpzIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5jb25zdCByZU51bWJlciA9IC9eWy0rXT8oXFxkK1xcLnxcXC4pP1xcZCsoZVxcZCt8ZVstK11cXGQrKT8kL1xuY29uc3QgcmVVcmwgPSAvXnVybFxcKFxccyooW14pXSspXFwpJC9cbmNvbnN0IHJlVmVjMiA9IC9edmVjMlxcKFxccyooWy0rXFxkLmVdKylcXHMqLFxccyooWy0rXFxkLmVdKylcXHMqXFwpJC9cbmNvbnN0IHJlVmVjMyA9IC9edmVjM1xcKFxccyooWy0rXFxkLmVdKylcXHMqLFxccyooWy0rXFxkLmVdKylcXHMqLFxccyooWy0rXFxkLmVdKylcXHMqXFwpJC9cbmNvbnN0IHJlVmVjNCA9IC9edmVjNFxcKFxccyooWy0rXFxkLmVdKylcXHMqLFxccyooWy0rXFxkLmVdKylcXHMqLFxccyooWy0rXFxkLmVdKylcXHMqLFxccyooWy0rXFxkLmVdKylcXHMqXFwpJC9cbmNvbnN0IHJlRnVuYyA9IC9eXFxzKlthLXpBLVpdK1xcKFxccypbXildK1xcKVxccyokL1xuXG4vLyBwYXJzZVZhbHVlKHN0cikgZXhwZWN0cyBhIHRyaW1tZWQgc3RyaW5nIVxuLy9cbi8vIHNwZWNpYWwgdHJhbnNmb3JtIHJ1bGVzOlxuLy9cbi8vICAgKHN0cmluZykgICA9PiAodHlwZSlcbi8vICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICcuLi4nICAgICAgPT4gc3RyaW5nOiAuLi5cbi8vICAgXCIuLi5cIiAgICAgID0+IHN0cmluZzogLi4uXG4vLyAgIDEyMyAgICAgICAgPT4gbnVtYmVyXG4vLyAgIDEyMy40NTYgICAgPT4gbnVtYmVyXG4vLyAgIG51bGwgICAgICAgPT4gb2JqZWN0OiBudWxsXG4vLyAgIHVuZGVmaW5lZCAgPT4gdW5kZWZpbmVkXG4vLyAgIHRydWUgICAgICAgPT4gYm9vbGVhbjogdHJ1ZVxuLy8gICBmYWxzZSAgICAgID0+IGJvb2xlYW46IGZhbHNlXG4vLyAgIHsuLi59ICAgICAgPT4gSlNPTi5wYXJzZSguLi4pXG4vLyAgIFsuLi5dICAgICAgPT4gSlNPTi5wYXJzZSguLi4pXG4vLyAgIHVybCguLi4pICAgPT4gbmV3IFVSTCguLi4pXG4vLyAgIHZlYzIoPG51bWJlcj4sIDxudW1iZXI+KSA9PiBuZXcgRmxvYXQzMkFycmF5KFtudW1iZXIsIG51bWJlcl0pXG4vLyAgIHZlYzMoPG51bWJlcj4sIDxudW1iZXI+LCA8bnVtYmVyPikgPT4gbmV3IEZsb2F0MzJBcnJheShbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pXG4vLyAgIHZlYzQoPG51bWJlcj4sIDxudW1iZXI+LCA8bnVtYmVyPiwgPG51bWJlcj4pID0+IG5ldyBGbG9hdDMyQXJyYXkoWy4uLl0pXG4vL1xuZnVuY3Rpb24gcGFyc2VWYWx1ZSAodmFsdWUpIHtcbiAgY29uc3QgbGVuID0gdmFsdWUubGVuZ3RoXG4gIGlmIChsZW4gPj0gMiAmJiB2YWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIHZhbHVlLmVuZHNXaXRoKCdcIicpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAyKVxuICB9IGVsc2UgaWYgKGxlbiA+PSAyICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ3snKSAmJiB2YWx1ZS5lbmRzV2l0aCgnfScpKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpXG4gIH0gZWxzZSBpZiAobGVuID49IDIgJiYgdmFsdWUuc3RhcnRzV2l0aCgnWycpICYmIHZhbHVlLmVuZHNXaXRoKCddJykpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgfSBlbHNlIGlmIChsZW4gPj0gMiAmJiB2YWx1ZS5zdGFydHNXaXRoKCdcXCcnKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXFwnJykpIHtcbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDIpXG4gIH0gZWxzZSBpZiAobGVuID4gMCAmJiByZU51bWJlci5leGVjKHZhbHVlKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKVxuICB9XG5cbiAgbGV0IG0gPSByZVVybC5leGVjKHZhbHVlKVxuICBpZiAobSkgcmV0dXJuIG5ldyBVUkwobVsxXS50cmltKCkpXG5cbiAgbSA9IHJlVmVjMi5leGVjKHZhbHVlKVxuICBpZiAobSkgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobS5zbGljZSgxLCAzKS5tYXAocGFyc2VGbG9hdCkpXG5cbiAgbSA9IHJlVmVjMy5leGVjKHZhbHVlKVxuICBpZiAobSkgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobS5zbGljZSgxLCA0KS5tYXAocGFyc2VGbG9hdCkpXG5cbiAgbSA9IHJlVmVjNC5leGVjKHZhbHVlKVxuICBpZiAobSkgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobS5zbGljZSgxLCA1KS5tYXAocGFyc2VGbG9hdCkpXG5cbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJ251bGwnOiByZXR1cm4gbnVsbFxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiB1bmRlZmluZWRcbiAgICBjYXNlICd0cnVlJzogcmV0dXJuIHRydWVcbiAgICBjYXNlICdmYWxzZSc6IHJldHVybiBmYWxzZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mTmV4dE5vbldoaXRlc3BhY2UgKHN0ciwgY3VySWR4KSB7XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgbGV0IGkgPSBjdXJJZHhcbiAgaWYgKGkgPj0gbGVuKSByZXR1cm4gbGVuXG4gIGRvIHtcbiAgICBpZiAoc3RyW2ldID09PSAnICcgfHwgc3RyW2ldID09PSAnXFx0Jykge1xuICAgICAgKytpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9IHdoaWxlIChpIDwgbGVuKVxuICByZXR1cm4gbGVuXG59XG5cbmZ1bmN0aW9uIGluZGV4T2ZOZXh0U2VwZXJhdG9yIChzdHIsIGN1cklkeCwgc2VwZXJhdG9yID0gJzsnKSB7XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgbGV0IGkgPSBjdXJJZHhcbiAgbGV0IGlzSW5zaWRlID0gbnVsbFxuICBkbyB7XG4gICAgaWYgKGlzSW5zaWRlID09PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHN0cltpXSkge1xuICAgICAgICBjYXNlIHNlcGVyYXRvcjogcmV0dXJuIGlcbiAgICAgICAgY2FzZSAnXFwnJzpcbiAgICAgICAgICBpc0luc2lkZSA9ICdcXCcnXG4gICAgICAgICAgKytpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIGlzSW5zaWRlID0gJ1wiJ1xuICAgICAgICAgICsraVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgIGlzSW5zaWRlID0gJyknXG4gICAgICAgICAgKytpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgaXNJbnNpZGUgPSAnfSdcbiAgICAgICAgICArK2lcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICBpICs9IDJcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICsraVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RyW2ldID09PSBpc0luc2lkZSkge1xuICAgICAgICBpc0luc2lkZSA9IG51bGxcbiAgICAgICAgKytpXG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGkgKz0gMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKytpXG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChpIDwgbGVuKVxuICByZXR1cm4gbGVuXG59XG5cbmZ1bmN0aW9uIHNwbGl0SW50b1Byb3BUb2tlbnMgKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgIXN0cikgcmV0dXJuXG5cbiAgY29uc3QgcHJvcFRva2VucyA9IFtdXG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcblxuICBsZXQgaSA9IGluZGV4T2ZOZXh0Tm9uV2hpdGVzcGFjZShzdHIsIDApXG4gIGRvIHtcbiAgICBjb25zdCB0byA9IGluZGV4T2ZOZXh0U2VwZXJhdG9yKHN0ciwgaSwgJzsnKVxuICAgIGlmICh0byA+IGkpIHtcbiAgICAgIHByb3BUb2tlbnMucHVzaChzdHIuc2xpY2UoaSwgdG8pKVxuICAgIH1cbiAgICBpID0gaW5kZXhPZk5leHROb25XaGl0ZXNwYWNlKHN0ciwgdG8gKyAxKVxuICB9IHdoaWxlIChpIDwgbGVuKVxuXG4gIHJldHVybiBwcm9wVG9rZW5zXG59XG5cbmZ1bmN0aW9uIHNwbGl0SW50b1Byb3BzIChzdHIpIHtcbiAgY29uc3QgdG9rZW5zID0gc3BsaXRJbnRvUHJvcFRva2VucyhzdHIpXG4gIGlmICghdG9rZW5zKSByZXR1cm5cbiAgcmV0dXJuIHRva2Vucy5tYXAoKHRvaykgPT4ge1xuICAgIGlmIChyZUZ1bmMuZXhlYyh0b2spKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogdG9rLnRyaW0oKSB9XG4gICAgfVxuICAgIGNvbnN0IGNvbG9uID0gdG9rLmluZGV4T2YoJzonKVxuICAgIGlmIChjb2xvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB0b2sudHJpbSgpIH1cbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdG9rLnNsaWNlKDAsIGNvbG9uKS50cmltKClcbiAgICBjb25zdCB2YWx1ZSA9IHRvay5zdWJzdHIoY29sb24gKyAxKS50cmltKClcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgdmFsdWVcbiAgICB9XG4gIH0pLmZpbHRlcigocHJvcCkgPT4gIShwcm9wLmtleSA9PT0gJycgJiYgcHJvcC52YWx1ZSA9PT0gJycpKVxufVxuXG5mdW5jdGlvbiBwYXJzZUNzc1N0eWxlZFByb3BlcnRpZXMgKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgcmV0dXJuIGRhdGFcblxuICAvLyA9PiBqc29uXG4gIGNvbnN0IHN0ciA9IGRhdGEudHJpbSgpXG4gIGlmIChzdHIuc3RhcnRzV2l0aCgneycpICYmIHN0ci5lbmRzV2l0aCgnfScpKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKVxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBzcGxpdEludG9Qcm9wcyhzdHIpXG5cbiAgLy8gPT4gdW5kZWZpbmVkXG4gIGlmICghcHJvcHMgfHwgcHJvcHMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoJ2tleScgaW4gcHJvcHNbMF0pIHtcbiAgICAvLyA9PiBwcm9wZXJ0aWVzXG4gICAgY29uc3QgbWFwID0ge31cbiAgICBwcm9wcy5mb3JFYWNoKCh7IGtleSwgdmFsdWUgfSkgPT4ge1xuICAgICAgbWFwW2tleV0gPSBwYXJzZVZhbHVlKHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIG1hcFxuICB9IGVsc2Uge1xuICAgIC8vID0+IGFycmF5IG9mIHZhbHVlcyBPUiBzaW5nbGUgdmFsdWVcbiAgICBjb25zdCB2YWx1ZXMgPSBwcm9wcy5tYXAoKHsgdmFsdWUgfSkgPT4gcGFyc2VWYWx1ZSh2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPT09IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXNcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZUNzc1N0eWxlZFByb3BlcnRpZXNcbmV4cG9ydCB7XG4gIHNwbGl0SW50b1Byb3BUb2tlbnMsXG4gIHNwbGl0SW50b1Byb3BzLFxuICBpbmRleE9mTmV4dE5vbldoaXRlc3BhY2UsXG4gIGluZGV4T2ZOZXh0U2VwZXJhdG9yLFxuICBwYXJzZVZhbHVlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvcGFyc2VDc3NTdHlsZWRQcm9wZXJ0aWVzLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbmltcG9ydCBnZW5lcmF0ZVVVSUQgZnJvbSAnLi4vdXRpbHMvZ2VuZXJhdGVfdXVpZCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyU291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gYFZFUlRFWF9TSEFERVJgIG9yIGBGUkFHTUVOVF9TSEFERVJgXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBzb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzb3VyY2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBnZW5lcmF0ZVVVSUQoKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gc291cmNlLnRleHRDb250ZW50IDogc291cmNlXG4gIH1cbn1cblxuU2hhZGVyU291cmNlLlZFUlRFWF9TSEFERVIgPSAnVkVSVEVYX1NIQURFUidcblNoYWRlclNvdXJjZS5GUkFHTUVOVF9TSEFERVIgPSAnRlJBR01FTlRfU0hBREVSJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc2hhZGVyX3NvdXJjZS5qcyIsImltcG9ydCB7IGlzUG93ZXJPZjIsIGZpbmROZXh0UG93ZXJPZjIgfSBmcm9tICcuLi91dGlscy9tYXRoX2hlbHBlcnMnXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGA8aW1nPmAgb3IgYDxjYW52YXM+YCBlbGVtZW50IHdoaWNoIHNpemVzICh3aWR0aCBhbmQgaGVpZ2h0KSBhcmVcbiAqIGFsd2F5cyBwb3dlciBvZiAyLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3dlck9mMkltYWdlIHtcbiAgLyoqXG4gICAqIElmIGltYWdlIGRpbWVuc2lvbiBpcyBOT1QgcG93ZXIgb2YgMiB0aGVuIGNyZWF0ZSBhIG5ldyBgPGNhbnZhcz5gXG4gICAqICh3aXRoIHBvd2VyIG9mIDIgZGltZW5zaW9uKSBhbmQgY29weSB0aGUgb3JpZ2luYWwgaW1hZ2UgY29udGVudCBvbnRvIGl0LlxuICAgKiBTaW5jZSBmZXRjaGluZyBpbWdlIGRhdGEgZnJvbSBzZXJ2ZXIgaXMgYSAqYXN5bmMqIG9wZXJhdGlvbiB0aGUgYGltZ0VsYCBwcm9wZXJ0eVxuICAgKiBjYW4gYmUgYG51bGxgIHJpZ2h0IGFmdGVyIG9iamVjdCBjb25zdHJ1Y3Rpb24gYW5kIHdpbGwgYmUgc2V0IGxhdGVyIGFmdGVyXG4gICAqIGltYWdlIGlzIGxvYWRlZCAoYW5kIHBvc3NpYmxlIGNvbnZlcnRlZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGZyb20gLSB1cmwgb3IgaHRtbCAqaW1hZ2UqIGVsZW1lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChmcm9tKSB7XG4gICAgbGV0IGltZ0VsXG4gICAgaWYgKHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJykge1xuICAgICAgaW1nRWwgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICAgIGltZ0VsLnNyYyA9IGZyb21cbiAgICB9IGVsc2Uge1xuICAgICAgaW1nRWwgPSBmcm9tXG4gICAgfVxuICAgIGlmIChpbWdFbC5jb21wbGV0ZSA9PT0gZmFsc2UgfHwgKGltZ0VsLndpZHRoID09PSAwICYmIGltZ0VsLmhlaWdodCA9PT0gMCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuaW1nRWwgPSBudWxsXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtQcm9taXNlPFBvd2VyT2YySW1hZ2U+fVxuICAgICAgICovXG4gICAgICB0aGlzLmNvbXBsZXRlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdPbkxvYWQgPSBpbWdFbC5vbmxvYWRcbiAgICAgICAgaW1nRWwub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChvcmlnT25Mb2FkKSBvcmlnT25Mb2FkLmNhbGwoaW1nRWwpXG4gICAgICAgICAgc2V0UG93ZXJPZjJJbWdFbCh0aGlzLCBpbWdFbClcbiAgICAgICAgICByZXNvbHZlKHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFBvd2VyT2YySW1nRWwodGhpcywgaW1nRWwpXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtQcm9taXNlPFBvd2VyT2YySW1hZ2U+fVxuICAgICAgICovXG4gICAgICB0aGlzLmNvbXBsZXRlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiB0aGF0IGlzIGB0cnVlYCBpZiB0aGUgaW1hZ2UgaGFzIGxvYWRlZCBhbmQgcG9zc2libGUgY29udmVydGVkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0NvbXBsZXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWdFbCAhPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpbWFnZSB3aWR0aCBvciBgMGAgaWYgaW1hZ2UgbG9hZGluZyBpcyBub3QgZmluaXNoZWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGggKCkge1xuICAgIHJldHVybiAodGhpcy5pbWdFbCAmJiB0aGlzLmltZ0VsLndpZHRoKSB8fCAwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpbWFnZSBoZWlnaHQgb3IgYDBgIGlmIGltYWdlIGxvYWRpbmcgaXMgbm90IGZpbmlzaGVkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmltZ0VsICYmIHRoaXMuaW1nRWwuaGVpZ2h0KSB8fCAwXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UG93ZXJPZjJJbWdFbCAocDJpbWcsIGltZ0VsKSB7XG4gIHAyaW1nLmltZ0VsID0gaXNQb3dlck9mMihpbWdFbC53aWR0aCkgJiYgaXNQb3dlck9mMihpbWdFbC5oZWlnaHQpID8gaW1nRWwgOiBjb252ZXJ0VG9Qb3dlck9mMihpbWdFbClcbiAgcDJpbWcub3JpZ1dpZHRoID0gaW1nRWwud2lkdGhcbiAgcDJpbWcub3JpZ0hlaWdodCA9IGltZ0VsLmhlaWdodFxufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3dlck9mMiAoaW1hZ2UpIHtcbiAgY29uc3QgdyA9IGZpbmROZXh0UG93ZXJPZjIoaW1hZ2Uud2lkdGgpXG4gIGNvbnN0IGggPSBmaW5kTmV4dFBvd2VyT2YyKGltYWdlLmhlaWdodClcblxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICBjYW52YXMud2lkdGggPSB3XG4gIGNhbnZhcy5oZWlnaHQgPSBoXG4gIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMClcblxuICByZXR1cm4gY2FudmFzXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS9wb3dlcl9vZl8yX2ltYWdlLmpzIiwiaW1wb3J0IFRleHR1cmUgZnJvbSAnLi90ZXh0dXJlJ1xuaW1wb3J0IFRleHR1cmVBdGxhc1NwZWMgZnJvbSAnLi90ZXh0dXJlX2F0bGFzX3NwZWMuanMnXG5pbXBvcnQgc2FtcGxlIGZyb20gJy4uL3V0aWxzL3NhbXBsZS5qcydcblxuLyoqXG4gICogQGV4YW1wbGVcbiAgKiBUZXh0dXJlQXRsYXMubG9hZCgnbm9iaW5nZXIuanNvbicpLnRoZW4oYXRsYXMgPT4ge1xuICAqICAgY29uc3QgYmxhdSA9IGF0bGFzLmdldEZyYW1lKCdub2Jpbmdlci1ibGF1LnBuZycpXG4gICogICBibGF1LndpZHRoICAgIyA9PiA1NVxuICAqICAgYmxhdS5oZWlnaHQgICMgPT4gNjFcbiAgKiB9KVxuICAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZUF0bGFzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gcm9vdFRleHR1cmVcbiAgICogQHBhcmFtIHtUZXh0dXJlQXRsYXNTcGVjfSBbc3BlYz1udWxsXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb3RUZXh0dXJlLCBzcGVjID0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMucm9vdFRleHR1cmUgPSByb290VGV4dHVyZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUZXh0dXJlQXRsYXNTcGVjfVxuICAgICAqL1xuICAgIHRoaXMuc3BlYyA9IHNwZWNcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxUZXh0dXJlPn1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lcyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqL1xuICBhZGRGcmFtZSAobmFtZSwgd2lkdGgsIGhlaWdodCwgeCwgeSkge1xuICAgIHRoaXMuZnJhbWVzLnNldChuYW1lLCBuZXcgVGV4dHVyZSh0aGlzLnJvb3RUZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCB4LCB5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJucyB7VGV4dHVyZX1cbiAgICovXG4gIGdldEZyYW1lIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVzLmdldChuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0UmFuZG9tRnJhbWUgKCkge1xuICAgIHJldHVybiBzYW1wbGUoQXJyYXkuZnJvbSh0aGlzLmZyYW1lcy52YWx1ZXMoKSkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldFJhbmRvbUZyYW1lTmFtZSAoKSB7XG4gICAgcmV0dXJuIHNhbXBsZSh0aGlzLmZyYW1lTmFtZXMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAgICovXG4gIGZyYW1lTmFtZXMgKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZnJhbWVzLmtleXMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIFRleHR1cmVBdGxhcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHNob3VsZCBwb2ludCB0byB0aGUgKnRleHR1cmUgYXRsYXMganNvbiBzcGVjKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW2ZldGNoT3B0aW9ucz11bmRlZmluZWRdIC0gb3B0aW9ucyBmb3IgdGhlIGBmZXRjaCgpYCBjYWxsXG4gICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufFBvd2VyT2YySW1hZ2V8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gW2ltYWdlPW51bGxdIC0gcGVyIGRlZmF1bHQgdGhlIGltYWdlIHdpbGwgYmUgbG9hZGVkIGZyb20gYG1ldGEuaW1hZ2VgIHVybCBmcm9tIHRoZSAqdGV4dHVyZSBhdGxhcyBzcGVjKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW3RleHR1cmVIaW50cz11bmRlZmluZWRdIC0gdGV4dHVyZSBoaW50c1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUZXh0dXJlQXRsYXM+fVxuICAgKi9cbiAgc3RhdGljIGxvYWQgKHVybCwgZmV0Y2hPcHRpb25zID0gbnVsbCwgaW1hZ2UgPSBudWxsLCB0ZXh0dXJlSGludHMgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gVGV4dHVyZUF0bGFzU3BlYy5sb2FkKHVybCwgZmV0Y2hPcHRpb25zIHx8IHt9KS50aGVuKGF0bGFzU3BlYyA9PiBhdGxhc1NwZWMuY3JlYXRlVGV4dHVyZUF0bGFzKGltYWdlIHx8IGF0bGFzU3BlYy5pbWFnZVVybCwgdGV4dHVyZUhpbnRzKSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvdGV4dHVyZV9hdGxhcy5qcyIsImltcG9ydCBTaGFkZXJWYXJpYWJsZSBmcm9tICcuL3NoYWRlcl92YXJpYWJsZSdcblxuLyoqXG4gKiBTaGFkZXIgdGV4dHVyZSAyZCB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyVGV4dHVyZTJkVmFyaWFibGUgZXh0ZW5kcyBTaGFkZXJWYXJpYWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgdmFsdWUpIHtcbiAgICBzdXBlcihuYW1lLCBTaGFkZXJWYXJpYWJsZS5UWVBFLlRFWFRVUkVfMkQsIHZhbHVlKVxuICAgIHRoaXMudGV4dHVyZSA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jIHRleHR1cmUgdG8gZ3B1IGFuZCB1cGRhdGUgYC52YWx1ZWAgdG8gdGhlIGdsIHRleHR1cmUgdW5pdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHbFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgc3luY1RleHR1cmVBbmRWYWx1ZSAocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGdsVGV4ID0gcmVuZGVyZXIuc3luY1RleHR1cmUodGhpcy50ZXh0dXJlKVxuICAgICAgdGhpcy52YWx1ZSA9IGdsVGV4LmJpbmQoKVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc2hhZGVyX3RleHR1cmVfMmRfdmFyaWFibGUuanMiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFsIGN1c3RvbUVsZW1lbnRzICovXG5pbXBvcnQgZGVmaW5lQ3VzdG9tRWxlbWVudHMgZnJvbSAnLi9kb20vZGVmaW5lQ3VzdG9tRWxlbWVudHMuanMnXG5pbXBvcnQgcHVibGljQXBpIGZyb20gJy4vYXBpJ1xuaW1wb3J0IHsgRE9NX0VMRU1fQ0FOVkFTIH0gZnJvbSAnLi9kb20vY29uc3RhbnRzJ1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZy5qcydcblxuaWYgKGN1c3RvbUVsZW1lbnRzLmdldChET01fRUxFTV9DQU5WQVMpKSB7XG4gIGxvZygnPGJsaXRwdW5rPiBjdXN0b20gZWxlbWVudHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVmaW5lZCcpXG59IGVsc2Uge1xuICBsb2coJzxibGl0cHVuaz4gY3VzdG9tIGVsZW1lbnRzIGFyZSBub3cgZGVmaW5lZCcpXG4gIGRlZmluZUN1c3RvbUVsZW1lbnRzKClcbn1cblxuY29uc3Qgd2hlblJlYWR5ID0gY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoRE9NX0VMRU1fQ0FOVkFTKS50aGVuKCgpID0+IHB1YmxpY0FwaSlcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4gd2hlblJlYWR5XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmxpdHB1bmsuanMiLCJpbXBvcnQgQ29tcG9uZW50UmVnaXN0cnkgZnJvbSAnLi9lY3MvY29tcG9uZW50X3JlZ2lzdHJ5J1xuaW1wb3J0IEVudGl0eU1hbmFnZXIgZnJvbSAnLi9lY3MvZW50aXR5X21hbmFnZXInXG5pbXBvcnQgUmVzb3VyY2VMaWJyYXJ5IGZyb20gJy4vY29yZS9yZXNvdXJjZV9saWJyYXJ5J1xuaW1wb3J0IFRleHR1cmVMaWJyYXJ5IGZyb20gJy4vY29yZS90ZXh0dXJlX2xpYnJhcnknXG5pbXBvcnQgV2ViR2xDb250ZXh0IGZyb20gJy4vcmVuZGVyL3dlYl9nbF9jb250ZXh0J1xuaW1wb3J0IFdlYkdsUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXIvd2ViX2dsX3JlbmRlcmVyJ1xuXG5pbXBvcnQgcmVnaXN0ZXJEZWZhdWx0Q29tcG9uZW50cyBmcm9tICcuL2RvbS9yZWdpc3RlckRlZmF1bHRDb21wb25lbnRzJ1xuaW1wb3J0IGRlc3Ryb3kgZnJvbSAnLi91dGlscy9kZXN0cm95J1xuaW1wb3J0IHsgZXJyb3IgfSBmcm9tICcuL2xvZydcblxuY29uc3QgZXZlbnRpemUgPSByZXF1aXJlKCdAc3BlYXJ3b2xmL2V2ZW50aXplJylcbmNvbnN0IHRpbnljb2xvciA9IHJlcXVpcmUoJ3Rpbnljb2xvcjInKVxuXG5jb25zdCBub3cgPSAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwXG5cbmNvbnN0IGRlZmF1bHRPcHRpb24gPSAob3B0aW9ucywga2V5LCBkZWZhdWx0VmFsdWVGbikgPT4ge1xuICBpZiAob3B0aW9ucyAmJiBrZXkgaW4gb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zW2tleV1cbiAgfVxuICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZUZuID09PSAnZnVuY3Rpb24nID8gZGVmYXVsdFZhbHVlRm4oKSA6IGRlZmF1bHRWYWx1ZUZuXG59XG5cbmNsYXNzIEFwcCB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgZXZlbnRpemUodGhpcylcblxuICAgIGNvbnN0IGdldE9wdGlvbiA9IGRlZmF1bHRPcHRpb24uYmluZChudWxsLCBvcHRpb25zKVxuXG4gICAgdGhpcy5jb21wb25lbnRSZWdpc3RyeSA9IGdldE9wdGlvbignY29tcG9uZW50UmVnaXN0cnknLCAoKSA9PiBuZXcgQ29tcG9uZW50UmVnaXN0cnkoKSlcbiAgICB0aGlzLmVudGl0eU1hbmFnZXIgPSBnZXRPcHRpb24oJ2VudGl0eU1hbmFnZXInLCAoKSA9PiBuZXcgRW50aXR5TWFuYWdlcigpKVxuICAgIHRoaXMucmVzb3VyY2VMaWJyYXJ5ID0gZ2V0T3B0aW9uKCdyZXNvdXJjZUxpYnJhcnknLCAoKSA9PiBuZXcgUmVzb3VyY2VMaWJyYXJ5KCkpXG4gICAgdGhpcy50ZXh0dXJlTGlicmFyeSA9IGdldE9wdGlvbigndGV4dHVyZUxpYnJhcnknLCAoKSA9PiBuZXcgVGV4dHVyZUxpYnJhcnkoKSlcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDYW52YXNIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyA9IGdldE9wdGlvbignY2FudmFzJywgKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbCBhdHRyaWJ1dGVzIHVzZWQgdG8gY3JlYXRlIHRoZSB3ZWJnbCBjb250ZXh0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICAgIGFscGhhOiBnZXRPcHRpb24oJ2FscGhhJywgZmFsc2UpLFxuICAgICAgZGVwdGg6IGdldE9wdGlvbignZGVwdGgnLCBmYWxzZSksXG4gICAgICBzdGVuY2lsOiBnZXRPcHRpb24oJ3N0ZW5jaWwnLCBmYWxzZSksXG4gICAgICBhbnRpYWxpYXM6IGdldE9wdGlvbignYW50aWFsaWFzJywgZmFsc2UpLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBnZXRPcHRpb24oJ3ByZW11bHRpcGxpZWRBbHBoYScsIGZhbHNlKSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZ2V0T3B0aW9uKCdwcmVzZXJ2ZURyYXdpbmdCdWZmZXInLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmRzIHNpbmNlIEFwcCBzdGFydHVwXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSBnZXRPcHRpb24oJ3RpbWUnLCAwKVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogU2Vjb25kcyBzaW5jZSBsYXN0IGZyYW1lXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVGcmFtZU9mZnNldCA9IDBcblxuICAgIC8qKlxuICAgICAqIEZyYW1lIGNvdW50ZXIgc2luY2UgYXBwbGljYXRpb24gc3RhcnR1cFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZU5vID0gZ2V0T3B0aW9uKCdmcmFtZU5vJywgMClcblxuICAgIHRoaXMuY2xlYXJDb2xvciA9IGdldE9wdGlvbignY2xlYXJDb2xvcicpXG5cbiAgICB0aGlzLmNyZWF0ZUdsQ29udGV4dCA9IGdldE9wdGlvbignY3JlYXRlR2xDb250ZXh0JywgKCkgPT4gKCkgPT4gY3JlYXRlR2xDb250ZXh0KHRoaXMuY2FudmFzLCB0aGlzLmNvbnRleHRBdHRyaWJ1dGVzKSlcblxuICAgIHJlZ2lzdGVyRGVmYXVsdENvbXBvbmVudHModGhpcy5jb21wb25lbnRSZWdpc3RyeSlcblxuICAgIHRoaXMuZW50aXR5ID0gdGhpcy5lbnRpdHlNYW5hZ2VyLmNyZWF0ZUVudGl0eSgpXG4gICAgdGhpcy5lbnRpdHkuc2V0Q29tcG9uZW50KCdibGl0cHVuaycsIHRoaXMpXG4gICAgdGhpcy5lbnRpdHkuc2V0Q29tcG9uZW50KCdyZXNvdXJjZUxpYnJhcnknLCB0aGlzLnJlc291cmNlTGlicmFyeSlcbiAgICB0aGlzLmVudGl0eS5zZXRDb21wb25lbnQoJ3RleHR1cmVMaWJyYXJ5JywgdGhpcy50ZXh0dXJlTGlicmFyeSlcbiAgICB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5LmNyZWF0ZUNvbXBvbmVudCh0aGlzLmVudGl0eSwgJ2NoaWxkcmVuJylcblxuICAgIHRoaXMuZWwgPSBudWxsXG5cbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZVxuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICB9XG5cbiAgZ2V0IGNsZWFyQ29sb3IgKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyID8gdGhpcy5yZW5kZXJlci5jbGVhckNvbG9yIDogdGhpcy5fY2xlYXJDb2xvclxuICB9XG5cbiAgc2V0IGNsZWFyQ29sb3IgKGNvbG9yKSB7XG4gICAgdGhpcy5fY2xlYXJDb2xvciA9IGNvbG9yID09IG51bGwgPyBjb2xvciA6IHRpbnljb2xvcihjb2xvcilcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMuX2NsZWFyQ29sb3IpXG4gICAgfVxuICB9XG5cbiAgZ2V0IGNhblN0YXJ0ICgpIHtcbiAgICByZXR1cm4gKCF0aGlzLnN0YXJ0ZWQgfHwgKHRoaXMuc3RhcnRlZCAmJiB0aGlzLnN0b3BwZWQpKSAmJiAhdGhpcy5kZXN0cm95ZWRcbiAgfVxuXG4gIHN0YXJ0IChlbCA9IHRoaXMpIHtcbiAgICBpZiAoIXRoaXMuY2FuU3RhcnQpIHJldHVyblxuXG4gICAgaWYgKHRoaXMuc3RvcHBlZCkge1xuICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2VcbiAgICAgIHRoaXMucmVzaXplKClcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYkdsQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdseCA9IG5ldyBXZWJHbENvbnRleHQodGhpcy5jcmVhdGVHbENvbnRleHQoKSlcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJHbFJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgV2ViR2xSZW5kZXJlcih0aGlzLmdseClcblxuICAgIGlmICh0aGlzLl9jbGVhckNvbG9yKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5fY2xlYXJDb2xvcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHVwIHRpbWUgaW4gc2Vjb25kcy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbm93KClcblxuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpXG4gICAgdGhpcy5yZXNpemUoKVxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGUoKVxuICB9XG5cbiAgcmVxdWVzdEFuaW1hdGUgKCkge1xuICAgIHRoaXMucmFmU3Vic2NyaXB0aW9uID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGUoKSlcbiAgfVxuXG4gIGNhbmNlbEFuaW1hdGUgKCkge1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZlN1YnNjcmlwdGlvbilcbiAgfVxuXG4gIGdldCBjYW5TdG9wICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydGVkICYmICF0aGlzLnN0b3BwZWQgJiYgIXRoaXMuZGVzdHJveWVkXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBpZiAoIXRoaXMuY2FuU3RvcCkgcmV0dXJuXG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZVxuICAgIHRoaXMuY2FuY2VsQW5pbWF0ZSgpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIHRoaXMuY2FuY2VsQW5pbWF0ZSgpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2x4LmRlc3Ryb3koKVxuICAgIH0gY2F0Y2ggKGVycjApIHtcbiAgICAgIGVycm9yKCdibGl0cHVuay0+ZGVzdHJveShXZWJHbENvbnRleHQpIHBhbmljIScsIGVycjApXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKVxuICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgIGVycm9yKCdibGl0cHVuay0+ZGVzdHJveShXZWJHbFJlbmRlcmVyKSBwYW5pYyEnLCBlcnIxKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy50ZXh0dXJlTGlicmFyeS5kZXN0cm95KClcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBlcnJvcignYmxpdHB1bmstPmRlc3Ryb3koVGV4dHVyZUxpYnJhcnkpIHBhbmljIScsIGVycjIpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlc291cmNlTGlicmFyeS5kZXN0cm95KClcbiAgICB9IGNhdGNoIChlcnIzKSB7XG4gICAgICBlcnJvcignYmxpdHB1bmstPmRlc3Ryb3koUmVzb3VyY2VMaWJyYXJ5KSBwYW5pYyEnLCBlcnIzKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLmRlc3Ryb3koKVxuICAgIH0gY2F0Y2ggKGVycjQpIHtcbiAgICAgIGVycm9yKCdibGl0cHVuay0+ZGVzdHJveShFbnRpdHlNYW5hZ2VyKSBwYW5pYyEnLCBlcnI0KVxuICAgIH1cbiAgICAvLyB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5IChDb21wb25lbnRSZWdpc3RyeSlcbiAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKVxuICAgIGRlc3Ryb3kodGhpcylcbiAgfVxuXG4gIGdldCBjYW5BbmltYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydGVkICYmICF0aGlzLnN0b3BwZWQgJiYgIXRoaXMuZGVzdHJveWVkXG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIG1haW4gYW5pbWF0aW9uIGxvb3AuXG4gICAqL1xuICBhbmltYXRlICgpIHtcbiAgICBpZiAoIXRoaXMuY2FuQW5pbWF0ZSkgcmV0dXJuXG4gICAgdGhpcy5yZW5kZXJGcmFtZSgpXG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBmcmFtZS5cbiAgICovXG4gIHJlbmRlckZyYW1lICgpIHtcbiAgICArK3RoaXMuZnJhbWVOb1xuICAgIHRoaXMudGltZSA9IG5vdygpIC0gdGhpcy5zdGFydFRpbWVcbiAgICBpZiAodGhpcy5sYXN0RnJhbWVUaW1lKSB7XG4gICAgICB0aGlzLnRpbWVGcmFtZU9mZnNldCA9IHRoaXMudGltZSAtIHRoaXMubGFzdEZyYW1lVGltZVxuICAgIH1cbiAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aGlzLnRpbWVcbiAgICB0aGlzLnJlc2l6ZSgpXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJGcmFtZSh0aGlzLmVudGl0eSwgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcyBkb20gZWxlbWVudCB0byB0aGUgc2FtZSBzaXplIGFzIHRoZSBgPGJsaXRwdW5rLWNhbnZhcz4ucGFyZW50Tm9kZWBcbiAgICovXG4gIHJlc2l6ZSAoKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsLCBudWxsKVxuICAgIGNvbnN0IGVsID0gc3R5bGUuZGlzcGxheSA9PT0gJ2lubGluZScgPyB0aGlzLmVsLnBhcmVudE5vZGUgOiB0aGlzLmVsXG5cbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gdGhpc1xuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDFcblxuICAgIGxldCB3UHggPSBlbC5jbGllbnRXaWR0aFxuICAgIGxldCBoUHggPSBlbC5jbGllbnRIZWlnaHRcblxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdQeCArICdweCdcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaFB4ICsgJ3B4J1xuXG4gICAgY29uc3QgdyA9IE1hdGgucm91bmQod1B4ICogZHByKVxuICAgIGNvbnN0IGggPSBNYXRoLnJvdW5kKGhQeCAqIGRwcilcblxuICAgIGlmICh3ICE9PSBjYW52YXMud2lkdGggfHwgaCAhPT0gY2FudmFzLmhlaWdodCkge1xuICAgICAgY2FudmFzLndpZHRoID0gd1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhcbiAgICB9XG5cbiAgICBpZiAodyAhPT0gdGhpcy53aWR0aCB8fCBoICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgLyoqXG4gICAgICAgKiBDYW52YXMgc2l6ZSBpbiBfZGV2aWNlXyBwaXhlbHMuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLndpZHRoID0gd1xuICAgICAgLyoqXG4gICAgICAgKiBDYW52YXMgc2l6ZSBpbiBfZGV2aWNlXyBwaXhlbHMuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLmhlaWdodCA9IGhcblxuICAgICAgdGhpcy5nbHguZ2wudmlld3BvcnQoMCwgMCwgdywgaCkgIC8vIFRPRE8gbW92ZSB0aGlzIGludG8gV2ViR2xSZW5kZXJlclxuICAgIH1cbiAgfVxufVxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGNyZWF0ZUdsQ29udGV4dCAoY2FudmFzLCBjdHhBdHRycykge1xuICBsZXQgZ2xcblxuICB0cnkge1xuICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY3R4QXR0cnMpXG4gIH0gY2F0Y2ggKGVycjApIHtcbiAgICBlcnJvcihlcnIwKVxuICB9XG5cbiAgaWYgKCFnbCkge1xuICAgIHRyeSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjdHhBdHRycylcbiAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICBlcnJvcihlcnIxKVxuICAgIH1cbiAgfVxuXG4gIGlmICghZ2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgd2ViZ2wxIGNvbnRleHQnKVxuICB9XG5cbiAgcmV0dXJuIGdsXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFwcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50UmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gY29tcG9uZW50IG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudEZhY3RvcnkgLSB0aGUgY29tcG9uZW50IGZhY3RvcnkgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlIC0gY3JlYXRlIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wb25lbnRGYWN0b3J5LnVwZGF0ZSAtIHVwZGF0ZSBhIGNvbXBvbmVudFxuICAgKi9cbiAgcmVnaXN0ZXJDb21wb25lbnQgKG5hbWUsIGNvbXBvbmVudEZhY3RvcnkpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5LnNldChuYW1lLCBjb21wb25lbnRGYWN0b3J5KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjcmVhdGVDb21wb25lbnQgKGVudGl0eSwgbmFtZSwgZGF0YSkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlZ2lzdHJ5LmdldChuYW1lKVxuICAgIGNvbnN0IGNvbXBvbmVudCA9IGZhY3RvcnkuY3JlYXRlKGVudGl0eSwgZGF0YSlcbiAgICBlbnRpdHkuc2V0Q29tcG9uZW50KG5hbWUsIGNvbXBvbmVudClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdXBkYXRlQ29tcG9uZW50IChlbnRpdHksIG5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBlbnRpdHlbbmFtZV1cbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5yZWdpc3RyeS5nZXQobmFtZSlcbiAgICBmYWN0b3J5LnVwZGF0ZShjb21wb25lbnQsIGRhdGEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNyZWF0ZU9yVXBkYXRlQ29tcG9uZW50IChlbnRpdHksIG5hbWUsIGRhdGEpIHtcbiAgICBpZiAoZW50aXR5W25hbWVdICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KGVudGl0eSwgbmFtZSwgZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVDb21wb25lbnQoZW50aXR5LCBuYW1lLCBkYXRhKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWNzL2NvbXBvbmVudF9yZWdpc3RyeS5qcyIsImltcG9ydCBFbnRpdHkgZnJvbSAnLi9lbnRpdHknXG5pbXBvcnQgZGVzdHJveSBmcm9tICcuLi91dGlscy9kZXN0cm95J1xuXG4vKipcbiAqIFRoZSBlbnRpdHkgbWFuYWdlciBob2xkcyByZWZlcmVuY2VzIHRvIGFsbCBlbnRpdGllcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVudGl0aWVzID0gbmV3IE1hcCgpXG4gIH1cblxuICBjcmVhdGVFbnRpdHkgKCkge1xuICAgIGNvbnN0IGVudGl0eSA9IG5ldyBFbnRpdHkoKVxuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KVxuICAgIHJldHVybiBlbnRpdHlcbiAgfVxuXG4gIGdldEVudGl0eSAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRpdGllcy5nZXQoaWQpXG4gIH1cblxuICBkZXN0cm95RW50aXR5IChpZCkge1xuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGlkKVxuICAgIGlmIChlbnRpdHkpIHtcbiAgICAgIGVudGl0eS5kZXN0cm95KClcbiAgICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGlkKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBkZXN0cm95QWxsRW50aXRpZXMgKCkge1xuICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5lbnRpdGllcy5rZXlzKCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveUVudGl0eShpZClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lBbGxFbnRpdGllcygpXG4gICAgdGhpcy5lbnRpdGllcy5jbGVhcigpXG4gICAgZGVzdHJveSh0aGlzKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWNzL2VudGl0eV9tYW5hZ2VyLmpzIiwiaW1wb3J0IGdlbmVyYXRlVVVJRCBmcm9tICcuLi91dGlscy9nZW5lcmF0ZV91dWlkJ1xuXG5jb25zdCBldmVudGl6ZSA9IHJlcXVpcmUoJ0BzcGVhcndvbGYvZXZlbnRpemUnKVxuXG5jb25zdCBkZXN0cm95QWxsQ29tcG9uZW50cyA9IChlbnRpdHkpID0+IHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGVudGl0eS5jb21wb25lbnRzLmtleXMoKSkge1xuICAgIGVudGl0eS5kZXN0cm95Q29tcG9uZW50KG5hbWUpXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBFbnRpdHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlVVVJRCgpXG5cbiAgICBldmVudGl6ZSh0aGlzKVxuICB9XG5cbiAgaGFzQ29tcG9uZW50IChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5oYXMobmFtZSlcbiAgfVxuXG4gIHNldENvbXBvbmVudCAobmFtZSwgY29tcG9uZW50KSB7XG4gICAgaWYgKHRoaXNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IG5hbWUgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBhc3NpZ25lZCFgKVxuICAgIH1cbiAgICB0aGlzLmNvbXBvbmVudHMuc2V0KG5hbWUsIGNvbXBvbmVudClcbiAgICB0aGlzW25hbWVdID0gY29tcG9uZW50XG4gICAgaWYgKGNvbXBvbmVudC5jb25uZWN0ZWRFbnRpdHkpIHtcbiAgICAgIGNvbXBvbmVudC5jb25uZWN0ZWRFbnRpdHkodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRlc3Ryb3lDb21wb25lbnQgKG5hbWUpIHtcbiAgICBpZiAodGhpcy5jb21wb25lbnRzLmRlbGV0ZShuYW1lKSkge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpc1tuYW1lXVxuICAgICAgZGVsZXRlIHRoaXNbbmFtZV1cbiAgICAgIGlmIChjb21wb25lbnQuZGlzY29ubmVjdGVkRW50aXR5KSB7XG4gICAgICAgIGNvbXBvbmVudC5kaXNjb25uZWN0ZWRFbnRpdHkodGhpcylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIHRoaXMpXG4gICAgZGVzdHJveUFsbENvbXBvbmVudHModGhpcylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Vjcy9lbnRpdHkuanMiLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XG59IGNhdGNoKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcblx0XHRnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBWT0Rlc2NyaXB0b3IgZnJvbSAnLi92X29fZGVzY3JpcHRvcidcbmltcG9ydCBTaGFkZXJTb3VyY2UgZnJvbSAnLi9zaGFkZXJfc291cmNlJ1xuXG5pbXBvcnQgZGVzdHJveSBmcm9tICcuLi91dGlscy9kZXN0cm95J1xuXG5pbXBvcnQgYWRkQ29tbW9uU3ByaXRlcyBmcm9tICcuL3Nwcml0ZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlTGlicmFyeSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmRlc2NyaXB0b3JzID0gbmV3IE1hcCgpXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXJzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlcnMgPSBuZXcgTWFwKClcblxuICAgIGFkZENvbW1vblNwcml0ZXModGhpcylcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZGVzY3JpcHRvcnMuY2xlYXIoKVxuICAgIHRoaXMudmVydGV4U2hhZGVycy5jbGVhcigpXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlcnMuY2xlYXIoKVxuICAgIGRlc3Ryb3kodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRpb24gLSBzZWUgYFZPRGVzY3JpcHRvcmAgZm9yIG1vcmUgZGV0YWlsc1xuICAgKi9cbiAgYWRkRGVzY3JpcHRvciAobmFtZSwgZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLmRlc2NyaXB0b3JzLnNldChuYW1lLCBuZXcgVk9EZXNjcmlwdG9yKGRlc2NyaXB0aW9uKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufHN0cmluZ1tdfSBzb3VyY2UgLSBzZWUgYFNoYWRlclNvdXJjZWAgZm9yIG1vcmUgZGV0YWlsc1xuICAgKi9cbiAgYWRkVmVydGV4U2hhZGVyIChuYW1lLCBzb3VyY2UpIHtcbiAgICB0aGlzLnZlcnRleFNoYWRlcnMuc2V0KG5hbWUsIG5ldyBTaGFkZXJTb3VyY2UoU2hhZGVyU291cmNlLlZFUlRFWF9TSEFERVIsIHNvdXJjZSkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxzdHJpbmdbXX0gc291cmNlIC0gc2VlIGBTaGFkZXJTb3VyY2VgIGZvciBtb3JlIGRldGFpbHNcbiAgICovXG4gIGFkZEZyYWdtZW50U2hhZGVyIChuYW1lLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVycy5zZXQobmFtZSwgbmV3IFNoYWRlclNvdXJjZShTaGFkZXJTb3VyY2UuRlJBR01FTlRfU0hBREVSLCBzb3VyY2UpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge1ZPRGVzY3JpcHRvcn1cbiAgICovXG4gIGZpbmREZXNjcmlwdG9yIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRvcnMuZ2V0KG5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge1NoYWRlclNvdXJjZX1cbiAgICovXG4gIGZpbmRWZXJ0ZXhTaGFkZXIgKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhTaGFkZXJzLmdldChuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm5zIHtTaGFkZXJTb3VyY2V9XG4gICAqL1xuICBmaW5kRnJhZ21lbnRTaGFkZXIgKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFNoYWRlcnMuZ2V0KG5hbWUpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3Jlc291cmNlX2xpYnJhcnkuanMiLCJpbXBvcnQgeyBjcmVhdGVWTyB9IGZyb20gJy4uL3Zfb19oZWxwZXInXG5pbXBvcnQgVk9BcnJheSBmcm9tICcuLi92X29fYXJyYXknXG5pbXBvcnQgY3JlYXRlVk9Qcm90b3R5cGUgZnJvbSAnLi9jcmVhdGVfdl9vX3Byb3RvdHlwZSdcbmltcG9ydCBjcmVhdGVUeXBlZEFycmF5cyBmcm9tICcuL2NyZWF0ZV90eXBlZF9hcnJheXMnXG5pbXBvcnQgY3JlYXRlQXR0cmlidXRlcyBmcm9tICcuL2NyZWF0ZV9hdHRyaWJ1dGVzJ1xuaW1wb3J0IGNyZWF0ZUFsaWFzZXMgZnJvbSAnLi9jcmVhdGVfYWxpYXNlcydcblxuLyoqXG4gKiBWZXJ0ZXggb2JqZWN0IGRlc2NyaXB0b3IuXG4gKlxuICogQGNsYXNzIFZPRGVzY3JpcHRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy52ZXJ0ZXhDb3VudCAtIG51bWJlciBvZiB2ZXJ0aWNlc1xuICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucy5hdHRyaWJ1dGVzIC0gbGlzdCBvZiB2ZXJ0ZXggYXR0cmlidXRlIGRlc2NyaXB0aW9ucyAoc2VlIGV4YW1wbGUpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYWxpYXNlc10gLSAqb3B0aW9uYWwqIGxpc3Qgb2YgYXR0cmlidXRlIGFsaWFzZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm90b11cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGVzY3JpcHRvciA9IG5ldyBWT0Rlc2NyaXB0b3Ioe1xuICpcbiAqICAgICBwcm90bzoge1xuICogICAgICAgICBmb28oKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gdGhpcy52b0FycmF5LmZsb2F0MzJBcnJheVswXTtcbiAqICAgICAgICAgfVxuICogICAgIH0sXG4gKlxuICogICAgIC8vIHZlcnRleCBidWZmZXIgbGF5b3V0XG4gKiAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICAgICAvL1xuICogICAgIC8vIHYwOiAoeDApKHkwKSh6MCkocm90YXRlXShzMCkodDApKHR4KSh0eSkoc2NhbGUpKG9wYWNpdHkpXG4gKiAgICAgLy8gdjE6ICh4MSkoeTEpKHoxKShyb3RhdGVdKHMxKSh0MSkodHgpKHR5KShzY2FsZSkob3BhY2l0eSlcbiAqICAgICAvLyB2MjogKHgyKSh5MikoejIpKHJvdGF0ZV0oczIpKHQyKSh0eCkodHkpKHNjYWxlKShvcGFjaXR5KVxuICogICAgIC8vIHYzOiAoeDMpKHkzKSh6Mykocm90YXRlXShzMykodDMpKHR4KSh0eSkoc2NhbGUpKG9wYWNpdHkpXG4gKiAgICAgLy9cbiAqICAgICB2ZXJ0ZXhDb3VudDogNCxcbiAqXG4gKiAgICAgYXR0cmlidXRlczogW1xuICpcbiAqICAgICAgICAgeyBuYW1lOiAncG9zaXRpb24nLCAgdHlwZTogJ2Zsb2F0MzInLCBzaXplOiAzLCBhdHRyTmFtZXM6IFsgJ3gnLCAneScsICd6JyBdIH0sXG4gKiAgICAgICAgIHsgbmFtZTogJ3JvdGF0ZScsICAgIHR5cGU6ICdmbG9hdDMyJywgc2l6ZTogMSwgdW5pZm9ybTogdHJ1ZSB9LFxuICogICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZHMnLCB0eXBlOiAnZmxvYXQzMicsIHNpemU6IDIsIGF0dHJOYW1lczogWyAncycsICd0JyBdIH0sXG4gKiAgICAgICAgIHsgbmFtZTogJ3RyYW5zbGF0ZScsIHR5cGU6ICdmbG9hdDMyJywgc2l6ZTogMiwgYXR0ck5hbWVzOiBbICd0eCcsICd0eScgXSwgdW5pZm9ybTogdHJ1ZSB9LFxuICogICAgICAgICB7IG5hbWU6ICdzY2FsZScsICAgICB0eXBlOiAnZmxvYXQzMicsIHNpemU6IDEsIHVuaWZvcm06IHRydWUgfSxcbiAqICAgICAgICAgeyBuYW1lOiAnb3BhY2l0eScsICAgdHlwZTogJ2Zsb2F0MzInLCBzaXplOiAxLCB1bmlmb3JtOiB0cnVlIH1cbiAqXG4gKiAgICAgXSxcbiAqXG4gKiAgICAgYWxpYXNlczoge1xuICpcbiAqICAgICAgICAgcG9zMmQ6IHsgc2l6ZTogMiwgdHlwZTogJ2Zsb2F0MzInLCBvZmZzZXQ6IDAgfSxcbiAqICAgICAgICAgcG9zWjogIHsgc2l6ZTogMSwgdHlwZTogJ2Zsb2F0MzInLCBvZmZzZXQ6IDIsIHVuaWZvcm06IHRydWUgfSxcbiAqICAgICAgICAgcjogICAgIHsgc2l6ZTogMSwgdHlwZTogJ2Zsb2F0MzInLCBvZmZzZXQ6IDMgfSxcbiAqICAgICAgICAgdXY6ICAgICd0ZXhDb29yZHMnLFxuICpcbiAqICAgICB9XG4gKlxuICogfSk7XG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZPRGVzY3JpcHRvciB7XG4gIGNvbnN0cnVjdG9yICh7IHZlcnRleENvdW50LCBhdHRyaWJ1dGVzLCBhbGlhc2VzLCBwcm90byB9KSB7XG4gICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHBhcnNlSW50KHZlcnRleENvdW50LCAxMClcblxuICAgIGNyZWF0ZUF0dHJpYnV0ZXModGhpcywgYXR0cmlidXRlcylcbiAgICBjcmVhdGVBbGlhc2VzKHRoaXMsIGFsaWFzZXMpXG4gICAgY3JlYXRlVk9Qcm90b3R5cGUodGhpcywgcHJvdG8pXG4gICAgY3JlYXRlVHlwZWRBcnJheXModGhpcylcblxuICAgIC8vID09PSB3aW50ZXJrw6RsdGUgamV0enRcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cikuZm9yRWFjaChuYW1lID0+IE9iamVjdC5mcmVlemUodGhpcy5hdHRyW25hbWVdKSlcbiAgICBPYmplY3QuZnJlZXplKHRoaXMuYXR0cilcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNhZ2VdXG4gICAqIEByZXR1cm5zIHtWT0FycmF5fVxuICAgKi9cbiAgY3JlYXRlVk9BcnJheSAoc2l6ZSA9IDEsIHVzYWdlID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBWT0FycmF5KHRoaXMsIHNpemUsIG51bGwsIHVzYWdlKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyAqdmVydGV4IG9iamVjdCpcbiAgICpcbiAgICogQHBhcmFtIHtWT0FycmF5fSBbdm9BcnJheV1cbiAgICogQHJldHVybnMge09iamVjdH0gdGhlICp2ZXJ0ZXggb2JqZWN0KlxuICAgKi9cbiAgY3JlYXRlVk8gKHZvQXJyYXkpIHtcbiAgICByZXR1cm4gY3JlYXRlVk8oT2JqZWN0LmNyZWF0ZSh0aGlzLnZvUHJvdG90eXBlKSwgdGhpcywgdm9BcnJheSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIGF0dHJpYnV0ZSBpdGVtIGNvdW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzQXR0cmlidXRlIChuYW1lLCBzaXplKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuYXR0clsgbmFtZSBdXG4gICAgcmV0dXJuIGF0dHIgJiYgYXR0ci5zaXplID09PSBzaXplXG4gIH1cblxuICAvKipcbiAgICogTWF4IG51bWJlciBvZiB2ZXJ0ZXggb2JqZWN0cyB3aGVuIGEgdmVydGV4IGJ1ZmZlciBpcyB1c2VkIHRvZ2V0aGVyXG4gICAqIHdpdGggYSBpbmRleGVkIGVsZW1lbnQgYXJyYXkgdG8gZHJhdyBwcmltaXRpdmVzLiB0aGUgcmVhc29uIGZvclxuICAgKiBzdWNoIGEgbGltaXQgaXMgdGhhdCB3ZWJnbCByZXN0cmljdHMgZWxlbWVudCBhcnJheSBpbmRpY2VzXG4gICAqIHRvIGFuIHVpbjE2IGRhdGEgdHlwZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgZ2V0IG1heEluZGV4ZWRWT1Bvb2xTaXplICgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcig2NTUzNiAvIHRoaXMudmVydGV4Q291bnQpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3Zfb19kZXNjcmlwdG9yL2luZGV4LmpzIiwiaW1wb3J0IFRleHR1cmUgZnJvbSAnLi90ZXh0dXJlJ1xuaW1wb3J0IFRleHR1cmVTdGF0ZSBmcm9tICcuL3RleHR1cmVfc3RhdGUnXG5pbXBvcnQgVGV4dHVyZUF0bGFzIGZyb20gJy4vdGV4dHVyZV9hdGxhcydcbmltcG9ydCBTaGFkZXJUZXh0dXJlMmRWYXJpYWJsZSBmcm9tICcuL3NoYWRlcl90ZXh0dXJlXzJkX3ZhcmlhYmxlJ1xuaW1wb3J0IGRlc3Ryb3kgZnJvbSAnLi4vdXRpbHMvZGVzdHJveSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZUxpYnJhcnkge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKClcbiAgICB0aGlzLnNoYWRlclZhcnMgPSBuZXcgTWFwKClcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuc3RhdGVzLmNsZWFyKClcbiAgICB0aGlzLnNoYWRlclZhcnMuY2xlYXIoKVxuICAgIGRlc3Ryb3kodGhpcylcbiAgfVxuXG4gIGxvYWRUZXh0dXJlIChpZCwgdXJsID0gaWQsIHRleHR1cmVIaW50cyA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFRleHR1cmVTdGF0ZShUZXh0dXJlLmxvYWQodXJsLCB0ZXh0dXJlSGludHMpKVxuICAgIHRoaXMuc3RhdGVzLnNldChpZCwgc3RhdGUpXG4gICAgcmV0dXJuIHN0YXRlLnByb21pc2VcbiAgfVxuXG4gIGxvYWRUZXh0dXJlQXRsYXMgKGlkLCB1cmwgPSBpZCwgdGV4dHVyZUhpbnRzID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYXRsYXMgPSBUZXh0dXJlQXRsYXMubG9hZCh1cmwsIG51bGwsIG51bGwsIHRleHR1cmVIaW50cylcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBUZXh0dXJlU3RhdGUoYXRsYXMudGhlbigoYXRsYXMpID0+IHtcbiAgICAgIHN0YXRlLmF0bGFzID0gYXRsYXNcbiAgICAgIHJldHVybiBhdGxhcy5yb290VGV4dHVyZVxuICAgIH0pKVxuICAgIHRoaXMuc3RhdGVzLnNldChpZCwgc3RhdGUpXG4gICAgcmV0dXJuIGF0bGFzXG4gIH1cblxuICBnZXRUZXh0dXJlQXRsYXMgKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldChpZCkuYXRsYXNcbiAgfVxuXG4gIHdoZW5Mb2FkZWQgKHRleHR1cmVJZCwgc2hhZGVyVmFyS2V5LCBvbkxvYWRlZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KHRleHR1cmVJZClcbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCB8fCAhc3RhdGUuaXNSZWFkeSkgcmV0dXJuXG5cbiAgICBsZXQgc2hhZGVyVmFyID0gdGhpcy5zaGFkZXJWYXJzLmdldChzaGFkZXJWYXJLZXkpXG4gICAgaWYgKHNoYWRlclZhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaGFkZXJWYXIgPSBuZXcgU2hhZGVyVGV4dHVyZTJkVmFyaWFibGUoc2hhZGVyVmFyS2V5KVxuICAgICAgdGhpcy5zaGFkZXJWYXJzLnNldChzaGFkZXJWYXJLZXksIHNoYWRlclZhcilcbiAgICB9XG5cbiAgICBzaGFkZXJWYXIudGV4dHVyZSA9IHN0YXRlLnRleHR1cmVcbiAgICBvbkxvYWRlZChzaGFkZXJWYXIpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3RleHR1cmVfbGlicmFyeS5qcyIsIlxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgbWF4T2YgPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYlxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmROZXh0UG93ZXJPZjIgKHgpIHtcbiAgbGV0IHAgPSAxXG4gIHdoaWxlICh4ID4gcCkgcCA8PD0gMVxuICByZXR1cm4gcFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1Bvd2VyT2YyID0gbiA9PiBuICE9PSAwICYmIChuICYgKG4gLSAxKSkgPT09IDBcblxuZXhwb3J0IHtcbiAgbWF4T2YsXG4gIGZpbmROZXh0UG93ZXJPZjIsXG4gIGlzUG93ZXJPZjJcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9tYXRoX2hlbHBlcnMuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yICh0ZXh0dXJlLCBhdGxhcykge1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGxcbiAgICB0aGlzLmF0bGFzID0gbnVsbFxuICAgIHRoaXMucHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0ZXh0dXJlKVxuICAgICAgLnRoZW4odGV4ID0+IHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4XG4gICAgICAgIHJldHVybiB0ZXhcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGV4dHVyZVN0YXRlIGVycm9yOicsIGVycilcbiAgICAgIH0pXG4gICAgUHJvbWlzZS5yZXNvbHZlKGF0bGFzKS50aGVuKChhdGxhcykgPT4ge1xuICAgICAgdGhpcy5hdGxhcyA9IGF0bGFzXG4gICAgfSlcbiAgfVxuXG4gIGdldCBpc1JlYWR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlICE9IG51bGxcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvdGV4dHVyZV9zdGF0ZS5qcyIsImltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSdcbmltcG9ydCBUZXh0dXJlQXRsYXMgZnJvbSAnLi90ZXh0dXJlX2F0bGFzJ1xuaW1wb3J0IFBvd2VyT2YySW1hZ2UgZnJvbSAnLi9wb3dlcl9vZl8yX2ltYWdlJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlQXRsYXNTcGVjIHtcbiAgY29uc3RydWN0b3IgKGpzb25EZWYpIHtcbiAgICB0aGlzLmpzb25EZWYgPSBqc29uRGVmXG4gICAgdGhpcy5mcmFtZU5hbWVzID0gT2JqZWN0LmtleXMoanNvbkRlZi5mcmFtZXMpXG4gIH1cblxuICBnZXQgZnJhbWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5qc29uRGVmLmZyYW1lc1xuICB9XG5cbiAgZ2V0IG1ldGEgKCkge1xuICAgIHJldHVybiB0aGlzLmpzb25EZWYubWV0YVxuICB9XG5cbiAgZ2V0IGltYWdlVXJsICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhLmltYWdlXG4gIH1cblxuICBjcmVhdGVUZXh0dXJlQXRsYXMgKGltYWdlID0gbnVsbCwgdGV4dHVyZUhpbnRzID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFByb21pc2UucmVzb2x2ZShpbWFnZSlcbiAgICAgIC50aGVuKGltYWdlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW1hZ2UodGhpcykpLnRoZW4oaW1nID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW1nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gKG5ldyBQb3dlck9mMkltYWdlKGltZykpLmNvbXBsZXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW1nXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIChuZXcgUG93ZXJPZjJJbWFnZShpbWFnZSkpLmNvbXBsZXRlXG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVBdGxhc1NwZWMuY3JlYXRlVGV4dHVyZUF0bGFzKCk6IG5vIGltYWdlIGZvdW5kIScpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAudGhlbihpbWFnZSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3RUZXh0dXJlID0gbmV3IFRleHR1cmUoaW1hZ2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwLCAwLCB0ZXh0dXJlSGludHMpXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbmV3IFRleHR1cmVBdGxhcyhyb290VGV4dHVyZSwgdGhpcylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmZyYW1lcykpIHtcbiAgICAgICAgICBjb25zdCB7IGZyYW1lIH0gPSB0aGlzLmZyYW1lc1tuYW1lXVxuICAgICAgICAgIGF0bGFzLmFkZEZyYW1lKG5hbWUsIGZyYW1lLncsIGZyYW1lLmgsIGZyYW1lLngsIGZyYW1lLnkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0bGFzXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBsb2FkICh1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gd2luZG93LmZldGNoKHVybCwgb3B0aW9ucykudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpLnRoZW4oanNvbiA9PiBuZXcgVGV4dHVyZUF0bGFzU3BlYyhqc29uKSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvdGV4dHVyZV9hdGxhc19zcGVjLmpzIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW1wbGUgKGFycikge1xuICByZXR1cm4gYXJyWyhNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCkgfCAwXVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL3NhbXBsZS5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR2xCdWZmZXIge1xuICBjb25zdHJ1Y3RvciAoZ2x4LCB0YXJnZXQgPSBXZWJHbEJ1ZmZlci5BUlJBWV9CVUZGRVIsIHVzYWdlID0gV2ViR2xCdWZmZXIuU1RBVElDX0RSQVcpIHtcbiAgICB0aGlzLmdseCA9IGdseFxuXG4gICAgY29uc3QgeyBnbCB9ID0gZ2x4XG4gICAgdGhpcy50YXJnZXQgPSBnbFt0YXJnZXRdXG4gICAgdGhpcy51c2FnZSA9IGdsW3VzYWdlXVxuXG4gICAgdGhpcy5nbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gIH1cblxuICBiaW5kQnVmZmVyICgpIHtcbiAgICB0aGlzLmdseC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmdsQnVmZmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZCBhcnJheSBidWZmZXIgY29udGVudCB0byBncHUgdmlhIGBnLmJ1ZmZlckRhdGEoLi4pYC5cbiAgICovXG4gIGJ1ZmZlckRhdGEgKHR5cGVkQXJyYXkpIHtcbiAgICB0aGlzLmJpbmRCdWZmZXIoKVxuICAgIHRoaXMuZ2x4LmdsLmJ1ZmZlckRhdGEodGhpcy50YXJnZXQsIHR5cGVkQXJyYXksIHRoaXMudXNhZ2UpXG4gIH1cbn1cblxuV2ViR2xCdWZmZXIuQVJSQVlfQlVGRkVSID0gJ0FSUkFZX0JVRkZFUidcbldlYkdsQnVmZmVyLkVMRU1FTlRfQVJSQVlfQlVGRkVSID0gJ0VMRU1FTlRfQVJSQVlfQlVGRkVSJ1xuXG5XZWJHbEJ1ZmZlci5TVEFUSUNfRFJBVyA9ICdTVEFUSUNfRFJBVydcbldlYkdsQnVmZmVyLkRZTkFNSUNfRFJBVyA9ICdEWU5BTUlDX0RSQVcnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL3dlYl9nbF9idWZmZXIuanMiLCJpbXBvcnQgU2hhZGVyVmFyaWFibGUgZnJvbSAnLi9zaGFkZXJfdmFyaWFibGUnXG5pbXBvcnQgU2hhZGVyVmFyaWFibGVHcm91cCBmcm9tICcuL3NoYWRlcl92YXJpYWJsZV9ncm91cCdcblxuaW1wb3J0IGRlc3Ryb3kgZnJvbSAnLi4vdXRpbHMvZGVzdHJveSdcblxuLyoqXG4gKiBBIFNoYWRlckNvbnRleHQga2VlcHMgbmFtZWQgcmVmZXJlbmNlcyB0byBhbGwgc2hhZGVyIF92YXJpYWJsZXNfXG4gKiB0byBtYWtlIHRoZW0gYXZhaWxhYmxlIGZvciBzaGFkZXIgX3Byb2dyYW1zXy5cbiAqIEVhY2ggbmFtZWQgcmVmZXJlbmNlIGlzIG9yZ2FuaXplZCBhcyBhIF9zdGFja18gd2hlcmUgeW91IGNhbiBwdXNoXG4gKiBvciBwb3Agc2hhZGVyIHZhcmlhYmxlIF92YWx1ZXNfLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJDb250ZXh0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMudW5pZm9ybSA9IG5ldyBNYXAoKVxuICAgIHRoaXMuYXR0cmliID0gbmV3IE1hcCgpXG4gICAgdGhpcy50ZXgyZCA9IG5ldyBNYXAoKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMudW5pZm9ybS5jbGVhcigpXG4gICAgdGhpcy5hdHRyaWIuY2xlYXIoKVxuICAgIHRoaXMudGV4MmQuY2xlYXIoKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5jbGVhcigpXG4gICAgZGVzdHJveSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2hhZGVyVmFyaWFibGV8U2hhZGVyVmFyaWFibGVHcm91cH0gc2hhZGVyVmFyaWFibGVcbiAgICovXG4gIHB1c2hWYXIgKHNoYWRlclZhcmlhYmxlKSB7XG4gICAgaWYgKHNoYWRlclZhcmlhYmxlIGluc3RhbmNlb2YgU2hhZGVyVmFyaWFibGVHcm91cCkge1xuICAgICAgc2hhZGVyVmFyaWFibGUucHVzaFZhcih0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYW5lID0gc2hhZGVyVmFyTGFuZSh0aGlzLCBzaGFkZXJWYXJpYWJsZS50eXBlLCBzaGFkZXJWYXJpYWJsZS5uYW1lKVxuICAgICAgbGFuZS5wdXNoKHNoYWRlclZhcmlhYmxlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY3VycmVudCBzaGFkZXIgdmFyaWFibGUgcGx1cyBhbGwgbGF0ZXIgc2V0IHZhcmlhYmxlcyBmcm9tIG5hbWVkIHNoYWRlciB2YXJpYWJsZSBzdGFjay5cbiAgICogQHBhcmFtIHtTaGFkZXJWYXJpYWJsZXxTaGFkZXJWYXJpYWJsZUdyb3VwfSBzaGFkZXJWYXJpYWJsZVxuICAgKi9cbiAgcG9wVmFyIChzaGFkZXJWYXJpYWJsZSkge1xuICAgIGlmIChzaGFkZXJWYXJpYWJsZSBpbnN0YW5jZW9mIFNoYWRlclZhcmlhYmxlR3JvdXApIHtcbiAgICAgIHNoYWRlclZhcmlhYmxlLnBvcFZhcih0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYW5lID0gc2hhZGVyVmFyTGFuZSh0aGlzLCBzaGFkZXJWYXJpYWJsZS50eXBlLCBzaGFkZXJWYXJpYWJsZS5uYW1lKVxuICAgICAgY29uc3QgbGVuID0gbGFuZS5sZW5ndGhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGxhbmVbaV0gPT09IHNoYWRlclZhcmlhYmxlKSB7XG4gICAgICAgICAgbGFuZS5sZW5ndGggPSBpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGN1cnJlbnQgc2hhZGVyIHZhcmlhYmxlIGJ5IG5hbWUgYW5kIHR5cGUuXG4gICAqIEBwYXJhbSB7U2hhZGVyVmFyaWFibGV9IHNoYWRlclZhcmlhYmxlXG4gICAqIEByZXR1cm4ge1NoYWRlclZhcmlhYmxlfSBvciBgbnVsbGBcbiAgICovXG4gIGN1clZhciAoc2hhZGVyVmFyaWFibGUpIHtcbiAgICBjb25zdCBsYW5lID0gc2hhZGVyVmFyTWFwKHRoaXMsIHNoYWRlclZhcmlhYmxlLnR5cGUpLmdldChzaGFkZXJWYXJpYWJsZS5uYW1lKVxuICAgIHJldHVybiBsYW5lICYmIGxhbmUubGVuZ3RoID8gbGFuZVtsYW5lLmxlbmd0aCAtIDFdIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBjdXJyZW50IF91bmlmb3JtXyBzaGFkZXIgdmFyaWFibGUgYnkgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7U2hhZGVyVW5pZm9ybVZhcmlhYmxlfSBvciBgbnVsbGBcbiAgICovXG4gIGN1clVuaWZvcm0gKG5hbWUpIHtcbiAgICBjb25zdCBsYW5lID0gdGhpcy51bmlmb3JtLmdldChuYW1lKVxuICAgIHJldHVybiBsYW5lICYmIGxhbmUubGVuZ3RoID8gbGFuZVtsYW5lLmxlbmd0aCAtIDFdIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBjdXJyZW50IF9hdHRyaWJ1dGVfIHNoYWRlciB2YXJpYWJsZSBieSBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtTaGFkZXJBdHRyaWJWYXJpYWJsZX0gb3IgYG51bGxgXG4gICAqL1xuICBjdXJBdHRyaWIgKG5hbWUpIHtcbiAgICBjb25zdCBsYW5lID0gdGhpcy5hdHRyaWIuZ2V0KG5hbWUpXG4gICAgcmV0dXJuIGxhbmUgJiYgbGFuZS5sZW5ndGggPyBsYW5lW2xhbmUubGVuZ3RoIC0gMV0gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGN1cnJlbnQgX3RleHR1cmUyZF8gc2hhZGVyIHZhcmlhYmxlIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge1NoYWRlclRleHR1cmUyZFZhcmlhYmxlfSBvciBgbnVsbGBcbiAgICovXG4gIGN1clRleDJkIChuYW1lKSB7XG4gICAgY29uc3QgbGFuZSA9IHRoaXMudGV4MmQuZ2V0KG5hbWUpXG4gICAgcmV0dXJuIGxhbmUgJiYgbGFuZS5sZW5ndGggPyBsYW5lW2xhbmUubGVuZ3RoIC0gMV0gOiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhZGVyVmFyTWFwIChzaGFkZXJDb250ZXh0LCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2hhZGVyVmFyaWFibGUuVFlQRS5VTklGT1JNOiByZXR1cm4gc2hhZGVyQ29udGV4dC51bmlmb3JtXG4gICAgY2FzZSBTaGFkZXJWYXJpYWJsZS5UWVBFLkFUVFJJQjogcmV0dXJuIHNoYWRlckNvbnRleHQuYXR0cmliXG4gICAgY2FzZSBTaGFkZXJWYXJpYWJsZS5UWVBFLlRFWFRVUkVfMkQ6IHJldHVybiBzaGFkZXJDb250ZXh0LnRleDJkXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhZGVyVmFyTGFuZSAoc2hhZGVyQ29udGV4dCwgdHlwZSwgbmFtZSkge1xuICBjb25zdCBtYXAgPSBzaGFkZXJWYXJNYXAoc2hhZGVyQ29udGV4dCwgdHlwZSlcbiAgbGV0IGxhbmUgPSBtYXAuZ2V0KG5hbWUpXG5cbiAgaWYgKCFsYW5lKSB7XG4gICAgbGFuZSA9IFtdXG4gICAgbWFwLnNldChuYW1lLCBsYW5lKVxuICB9XG5cbiAgcmV0dXJuIGxhbmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3NoYWRlcl9jb250ZXh0LmpzIiwiLy8gVGlueUNvbG9yIHYxLjQuMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9UaW55Q29sb3Jcbi8vIEJyaWFuIEdyaW5zdGVhZCwgTUlUIExpY2Vuc2VcblxuKGZ1bmN0aW9uKE1hdGgpIHtcblxudmFyIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICB0cmltUmlnaHQgPSAvXFxzKyQvLFxuICAgIHRpbnlDb3VudGVyID0gMCxcbiAgICBtYXRoUm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIG1hdGhNaW4gPSBNYXRoLm1pbixcbiAgICBtYXRoTWF4ID0gTWF0aC5tYXgsXG4gICAgbWF0aFJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG5mdW5jdGlvbiB0aW55Y29sb3IgKGNvbG9yLCBvcHRzKSB7XG5cbiAgICBjb2xvciA9IChjb2xvcikgPyBjb2xvciA6ICcnO1xuICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgIC8vIElmIGlucHV0IGlzIGFscmVhZHkgYSB0aW55Y29sb3IsIHJldHVybiBpdHNlbGZcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiB0aW55Y29sb3IpIHtcbiAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgY2FsbCB1c2luZyBuZXcgaW5zdGVhZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgcmdiID0gaW5wdXRUb1JHQihjb2xvcik7XG4gICAgdGhpcy5fb3JpZ2luYWxJbnB1dCA9IGNvbG9yLFxuICAgIHRoaXMuX3IgPSByZ2IucixcbiAgICB0aGlzLl9nID0gcmdiLmcsXG4gICAgdGhpcy5fYiA9IHJnYi5iLFxuICAgIHRoaXMuX2EgPSByZ2IuYSxcbiAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwLFxuICAgIHRoaXMuX2Zvcm1hdCA9IG9wdHMuZm9ybWF0IHx8IHJnYi5mb3JtYXQ7XG4gICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG5cbiAgICAvLyBEb24ndCBsZXQgdGhlIHJhbmdlIG9mIFswLDI1NV0gY29tZSBiYWNrIGluIFswLDFdLlxuICAgIC8vIFBvdGVudGlhbGx5IGxvc2UgYSBsaXR0bGUgYml0IG9mIHByZWNpc2lvbiBoZXJlLCBidXQgd2lsbCBmaXggaXNzdWVzIHdoZXJlXG4gICAgLy8gLjUgZ2V0cyBpbnRlcnByZXRlZCBhcyBoYWxmIG9mIHRoZSB0b3RhbCwgaW5zdGVhZCBvZiBoYWxmIG9mIDFcbiAgICAvLyBJZiBpdCB3YXMgc3VwcG9zZWQgdG8gYmUgMTI4LCB0aGlzIHdhcyBhbHJlYWR5IHRha2VuIGNhcmUgb2YgYnkgYGlucHV0VG9SZ2JgXG4gICAgaWYgKHRoaXMuX3IgPCAxKSB7IHRoaXMuX3IgPSBtYXRoUm91bmQodGhpcy5fcik7IH1cbiAgICBpZiAodGhpcy5fZyA8IDEpIHsgdGhpcy5fZyA9IG1hdGhSb3VuZCh0aGlzLl9nKTsgfVxuICAgIGlmICh0aGlzLl9iIDwgMSkgeyB0aGlzLl9iID0gbWF0aFJvdW5kKHRoaXMuX2IpOyB9XG5cbiAgICB0aGlzLl9vayA9IHJnYi5vaztcbiAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XG59XG5cbnRpbnljb2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXNEYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnJpZ2h0bmVzcygpIDwgMTI4O1xuICAgIH0sXG4gICAgaXNMaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2s7XG4gICAgfSxcbiAgICBnZXRPcmlnaW5hbElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbElucHV0O1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgICB9LFxuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfSxcbiAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9BRVJUI2NvbG9yLWNvbnRyYXN0XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHJldHVybiAocmdiLnIgKiAyOTkgKyByZ2IuZyAqIDU4NyArIHJnYi5iICogMTE0KSAvIDEwMDA7XG4gICAgfSxcbiAgICBnZXRMdW1pbmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICAgICAgdmFyIFJzUkdCLCBHc1JHQiwgQnNSR0IsIFIsIEcsIEI7XG4gICAgICAgIFJzUkdCID0gcmdiLnIvMjU1O1xuICAgICAgICBHc1JHQiA9IHJnYi5nLzI1NTtcbiAgICAgICAgQnNSR0IgPSByZ2IuYi8yNTU7XG5cbiAgICAgICAgaWYgKFJzUkdCIDw9IDAuMDM5MjgpIHtSID0gUnNSR0IgLyAxMi45Mjt9IGVsc2Uge1IgPSBNYXRoLnBvdygoKFJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEdzUkdCIDw9IDAuMDM5MjgpIHtHID0gR3NSR0IgLyAxMi45Mjt9IGVsc2Uge0cgPSBNYXRoLnBvdygoKEdzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEJzUkdCIDw9IDAuMDM5MjgpIHtCID0gQnNSR0IgLyAxMi45Mjt9IGVsc2Uge0IgPSBNYXRoLnBvdygoKEJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgcmV0dXJuICgwLjIxMjYgKiBSKSArICgwLjcxNTIgKiBHKSArICgwLjA3MjIgKiBCKTtcbiAgICB9LFxuICAgIHNldEFscGhhOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hID0gYm91bmRBbHBoYSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzdi5oICogMzYwLCBzOiBoc3YucywgdjogaHN2LnYsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHN2U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzdihcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgcmV0dXJuIHsgaDogaHNsLmggKiAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHZhciBoID0gbWF0aFJvdW5kKGhzbC5oICogMzYwKSwgcyA9IG1hdGhSb3VuZChoc2wucyAqIDEwMCksIGwgPSBtYXRoUm91bmQoaHNsLmwgKiAxMDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwiaHNsKFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUpXCIgOlxuICAgICAgICAgIFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUsIFwiKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSGV4OiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCBhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4KGFsbG93M0NoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4OiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JhVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSwgYWxsb3c0Q2hhcik7XG4gICAgfSxcbiAgICB0b0hleDhTdHJpbmc6IGZ1bmN0aW9uKGFsbG93NENoYXIpIHtcbiAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXg4KGFsbG93NENoYXIpO1xuICAgIH0sXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRoUm91bmQodGhpcy5fciksIGc6IG1hdGhSb3VuZCh0aGlzLl9nKSwgYjogbWF0aFJvdW5kKHRoaXMuX2IpLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b1JnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgZzogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcInJnYihcIiAgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJSlcIiA6XG4gICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvRmlsdGVyOiBmdW5jdGlvbihzZWNvbmRDb2xvcikge1xuICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgICAgIHZhciBzZWNvbmRIZXg4U3RyaW5nID0gaGV4OFN0cmluZztcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZSA9IHRoaXMuX2dyYWRpZW50VHlwZSA/IFwiR3JhZGllbnRUeXBlID0gMSwgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChzZWNvbmRDb2xvcikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aW55Y29sb3Ioc2Vjb25kQ29sb3IpO1xuICAgICAgICAgICAgc2Vjb25kSGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgocy5fciwgcy5fZywgcy5fYiwgcy5fYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoXCIrZ3JhZGllbnRUeXBlK1wic3RhcnRDb2xvcnN0cj1cIitoZXg4U3RyaW5nK1wiLGVuZENvbG9yc3RyPVwiK3NlY29uZEhleDhTdHJpbmcrXCIpXCI7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuX2Zvcm1hdDtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBbHBoYSA9IHRoaXMuX2EgPCAxICYmIHRoaXMuX2EgPj0gMDtcbiAgICAgICAgdmFyIG5lZWRzQWxwaGFGb3JtYXQgPSAhZm9ybWF0U2V0ICYmIGhhc0FscGhhICYmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIiB8fCBmb3JtYXQgPT09IFwiaGV4M1wiIHx8IGZvcm1hdCA9PT0gXCJoZXg0XCIgfHwgZm9ybWF0ID09PSBcImhleDhcIiB8fCBmb3JtYXQgPT09IFwibmFtZVwiKTtcblxuICAgICAgICBpZiAobmVlZHNBbHBoYUZvcm1hdCkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBcInRyYW5zcGFyZW50XCIsIGFsbCBvdGhlciBub24tYWxwaGEgZm9ybWF0c1xuICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gcmdiYSB3aGVuIHRoZXJlIGlzIHRyYW5zcGFyZW5jeS5cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwibmFtZVwiICYmIHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b05hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicHJnYlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUGVyY2VudGFnZVJnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4M1wiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4NFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4OFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDhcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzbFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc3ZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZyB8fCB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5TW9kaWZpY2F0aW9uOiBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICB2YXIgY29sb3IgPSBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICAgICAgdGhpcy5fciA9IGNvbG9yLl9yO1xuICAgICAgICB0aGlzLl9nID0gY29sb3IuX2c7XG4gICAgICAgIHRoaXMuX2IgPSBjb2xvci5fYjtcbiAgICAgICAgdGhpcy5zZXRBbHBoYShjb2xvci5fYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbGlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihsaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYnJpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oYnJpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGFya2VuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkZXNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBncmV5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZ3JleXNjYWxlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzcGluLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlDb21iaW5hdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgIH0sXG4gICAgYW5hbG9nb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oYW5hbG9nb3VzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtb25vY2hyb21hdGljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24obW9ub2Nocm9tYXRpYywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwbGl0Y29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHNwbGl0Y29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRyaWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odHJpYWQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0ZXRyYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0ZXRyYWQsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxuLy8gSWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBmb3JjZSAxIGludG8gXCIxLjBcIiB0byBoYW5kbGUgcmF0aW9zIHByb3Blcmx5XG4vLyBTdHJpbmcgaW5wdXQgcmVxdWlyZXMgXCIxLjBcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxudGlueWNvbG9yLmZyb21SYXRpbyA9IGZ1bmN0aW9uKGNvbG9yLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBuZXdDb2xvciA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb2xvcltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gbmV3Q29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG59O1xuXG4vLyBHaXZlbiBhIHN0cmluZyBvciBvYmplY3QsIGNvbnZlcnQgdGhhdCBpbnB1dCB0byBSR0Jcbi8vIFBvc3NpYmxlIHN0cmluZyBpbnB1dHM6XG4vL1xuLy8gICAgIFwicmVkXCJcbi8vICAgICBcIiNmMDBcIiBvciBcImYwMFwiXG4vLyAgICAgXCIjZmYwMDAwXCIgb3IgXCJmZjAwMDBcIlxuLy8gICAgIFwiI2ZmMDAwMDAwXCIgb3IgXCJmZjAwMDAwMFwiXG4vLyAgICAgXCJyZ2IgMjU1IDAgMFwiIG9yIFwicmdiICgyNTUsIDAsIDApXCJcbi8vICAgICBcInJnYiAxLjAgMCAwXCIgb3IgXCJyZ2IgKDEsIDAsIDApXCJcbi8vICAgICBcInJnYmEgKDI1NSwgMCwgMCwgMSlcIiBvciBcInJnYmEgMjU1LCAwLCAwLCAxXCJcbi8vICAgICBcInJnYmEgKDEuMCwgMCwgMCwgMSlcIiBvciBcInJnYmEgMS4wLCAwLCAwLCAxXCJcbi8vICAgICBcImhzbCgwLCAxMDAlLCA1MCUpXCIgb3IgXCJoc2wgMCAxMDAlIDUwJVwiXG4vLyAgICAgXCJoc2xhKDAsIDEwMCUsIDUwJSwgMSlcIiBvciBcImhzbGEgMCAxMDAlIDUwJSwgMVwiXG4vLyAgICAgXCJoc3YoMCwgMTAwJSwgMTAwJSlcIiBvciBcImhzdiAwIDEwMCUgMTAwJVwiXG4vL1xuZnVuY3Rpb24gaW5wdXRUb1JHQihjb2xvcikge1xuXG4gICAgdmFyIHJnYiA9IHsgcjogMCwgZzogMCwgYjogMCB9O1xuICAgIHZhciBhID0gMTtcbiAgICB2YXIgcyA9IG51bGw7XG4gICAgdmFyIHYgPSBudWxsO1xuICAgIHZhciBsID0gbnVsbDtcbiAgICB2YXIgb2sgPSBmYWxzZTtcbiAgICB2YXIgZm9ybWF0ID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29sb3IgPSBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLnIpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmcpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmIpKSB7XG4gICAgICAgICAgICByZ2IgPSByZ2JUb1JnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcIiVcIiA/IFwicHJnYlwiIDogXCJyZ2JcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci52KSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICB2ID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci52KTtcbiAgICAgICAgICAgIHJnYiA9IGhzdlRvUmdiKGNvbG9yLmgsIHMsIHYpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc3ZcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5sKSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICBsID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5sKTtcbiAgICAgICAgICAgIHJnYiA9IGhzbFRvUmdiKGNvbG9yLmgsIHMsIGwpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShcImFcIikpIHtcbiAgICAgICAgICAgIGEgPSBjb2xvci5hO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYSA9IGJvdW5kQWxwaGEoYSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvazogb2ssXG4gICAgICAgIGZvcm1hdDogY29sb3IuZm9ybWF0IHx8IGZvcm1hdCxcbiAgICAgICAgcjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLnIsIDApKSxcbiAgICAgICAgZzogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmcsIDApKSxcbiAgICAgICAgYjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmIsIDApKSxcbiAgICAgICAgYTogYVxuICAgIH07XG59XG5cblxuLy8gQ29udmVyc2lvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGByZ2JUb0hzbGAsIGByZ2JUb0hzdmAsIGBoc2xUb1JnYmAsIGBoc3ZUb1JnYmAgbW9kaWZpZWQgZnJvbTpcbi8vIDxodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0PlxuXG4vLyBgcmdiVG9SZ2JgXG4vLyBIYW5kbGUgYm91bmRzIC8gcGVyY2VudGFnZSBjaGVja2luZyB0byBjb25mb3JtIHRvIENTUyBjb2xvciBzcGVjXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8+XG4vLyAqQXNzdW1lczoqIHIsIGcsIGIgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIFswLCAyNTVdXG5mdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiKXtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBib3VuZDAxKHIsIDI1NSkgKiAyNTUsXG4gICAgICAgIGc6IGJvdW5kMDEoZywgMjU1KSAqIDI1NSxcbiAgICAgICAgYjogYm91bmQwMShiLCAyNTUpICogMjU1XG4gICAgfTtcbn1cblxuLy8gYHJnYlRvSHNsYFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC5cbi8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCBsIH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHNsKHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBoIC89IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgbDogbCB9O1xufVxuXG4vLyBgaHNsVG9SZ2JgXG4vLyBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLlxuLy8gKkFzc3VtZXM6KiBoIGlzIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDM2MF0gYW5kIHMgYW5kIGwgYXJlIGNvbnRhaW5lZCBbMCwgMV0gb3IgWzAsIDEwMF1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIGwgPSBib3VuZDAxKGwsIDEwMCk7XG5cbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcbiAgICAgICAgaWYodCA+IDEpIHQgLT0gMTtcbiAgICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xuICAgICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xufVxuXG4vLyBgcmdiVG9Ic3ZgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCB2IH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHN2KHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIHYgPSBtYXg7XG5cbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIHY6IHYgfTtcbn1cblxuLy8gYGhzdlRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCB2IGFyZSBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbiBmdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XG5cbiAgICBoID0gYm91bmQwMShoLCAzNjApICogNjtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIHYgPSBib3VuZDAxKHYsIDEwMCk7XG5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICAgIGYgPSBoIC0gaSxcbiAgICAgICAgcCA9IHYgKiAoMSAtIHMpLFxuICAgICAgICBxID0gdiAqICgxIC0gZiAqIHMpLFxuICAgICAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpLFxuICAgICAgICBtb2QgPSBpICUgNixcbiAgICAgICAgciA9IFt2LCBxLCBwLCBwLCB0LCB2XVttb2RdLFxuICAgICAgICBnID0gW3QsIHYsIHYsIHEsIHAsIHBdW21vZF0sXG4gICAgICAgIGIgPSBbcCwgcCwgdCwgdiwgdiwgcV1bbW9kXTtcblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV1cbi8vIFJldHVybnMgYSAzIG9yIDYgY2hhcmFjdGVyIGhleFxuZnVuY3Rpb24gcmdiVG9IZXgociwgZywgYiwgYWxsb3czQ2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSAzIGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSkge1xuICAgICAgICByZXR1cm4gaGV4WzBdLmNoYXJBdCgwKSArIGhleFsxXS5jaGFyQXQoMCkgKyBoZXhbMl0uY2hhckF0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYHJnYmFUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgcGx1cyBhbHBoYSB0cmFuc3BhcmVuY3kgdG8gaGV4XG4vLyBBc3N1bWVzIHIsIGcsIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxuLy8gYSBpbiBbMCwgMV0uIFJldHVybnMgYSA0IG9yIDggY2hhcmFjdGVyIHJnYmEgaGV4XG5mdW5jdGlvbiByZ2JhVG9IZXgociwgZywgYiwgYSwgYWxsb3c0Q2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSA0IGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3c0Q2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSAmJiBoZXhbM10uY2hhckF0KDApID09IGhleFszXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKSArIGhleFszXS5jaGFyQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgcmdiYVRvQXJnYkhleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgdG8gYW4gQVJHQiBIZXg4IHN0cmluZ1xuLy8gUmFyZWx5IHVzZWQsIGJ1dCByZXF1aXJlZCBmb3IgXCJ0b0ZpbHRlcigpXCJcbmZ1bmN0aW9uIHJnYmFUb0FyZ2JIZXgociwgZywgYiwgYSkge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGBlcXVhbHNgXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxudGlueWNvbG9yLmVxdWFscyA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMikge1xuICAgIGlmICghY29sb3IxIHx8ICFjb2xvcjIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcbn07XG5cbnRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yLmZyb21SYXRpbyh7XG4gICAgICAgIHI6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxuICAgICAgICBiOiBtYXRoUmFuZG9tKClcbiAgICB9KTtcbn07XG5cblxuLy8gTW9kaWZpY2F0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGxlc3MuanMgZm9yIHNvbWUgb2YgdGhlIGJhc2ljcyBoZXJlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaGVhZC9sZXNzLmpzL2Jsb2IvbWFzdGVyL2xpYi9sZXNzL2Z1bmN0aW9ucy5qcz5cblxuZnVuY3Rpb24gZGVzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gZ3JleXNjYWxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZSgxMDApO1xufVxuXG5mdW5jdGlvbiBsaWdodGVuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgcmdiID0gdGlueWNvbG9yKGNvbG9yKS50b1JnYigpO1xuICAgIHJnYi5yID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLnIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5nIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuYiAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJldHVybiB0aW55Y29sb3IocmdiKTtcbn1cblxuZnVuY3Rpb24gZGFya2VuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIFNwaW4gdGFrZXMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBhbW91bnQgd2l0aGluIFstMzYwLCAzNjBdIGluZGljYXRpbmcgdGhlIGNoYW5nZSBvZiBodWUuXG4vLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXG5mdW5jdGlvbiBzcGluKGNvbG9yLCBhbW91bnQpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQpICUgMzYwO1xuICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIENvbWJpbmF0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGFua3MgdG8galF1ZXJ5IHhDb2xvciBmb3Igc29tZSBvZiB0aGUgaWRlYXMgYmVoaW5kIHRoZXNlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2luZnVzaW9uL2pRdWVyeS14Y29sb3IvYmxvYi9tYXN0ZXIvanF1ZXJ5Lnhjb2xvci5qcz5cblxuZnVuY3Rpb24gY29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gdHJpYWQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxMjApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjQwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdGV0cmFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgOTApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTgwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI3MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHNwbGl0Y29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjE2KSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBhbmFsb2dvdXMoY29sb3IsIHJlc3VsdHMsIHNsaWNlcykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgc2xpY2VzID0gc2xpY2VzIHx8IDMwO1xuXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgcGFydCA9IDM2MCAvIHNsaWNlcztcbiAgICB2YXIgcmV0ID0gW3Rpbnljb2xvcihjb2xvcildO1xuXG4gICAgZm9yIChoc2wuaCA9ICgoaHNsLmggLSAocGFydCAqIHJlc3VsdHMgPj4gMSkpICsgNzIwKSAlIDM2MDsgLS1yZXN1bHRzOyApIHtcbiAgICAgICAgaHNsLmggPSAoaHNsLmggKyBwYXJ0KSAlIDM2MDtcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKGhzbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBtb25vY2hyb21hdGljKGNvbG9yLCByZXN1bHRzKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICB2YXIgaHN2ID0gdGlueWNvbG9yKGNvbG9yKS50b0hzdigpO1xuICAgIHZhciBoID0gaHN2LmgsIHMgPSBoc3YucywgdiA9IGhzdi52O1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgbW9kaWZpY2F0aW9uID0gMSAvIHJlc3VsdHM7XG5cbiAgICB3aGlsZSAocmVzdWx0cy0tKSB7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcih7IGg6IGgsIHM6IHMsIHY6IHZ9KSk7XG4gICAgICAgIHYgPSAodiArIG1vZGlmaWNhdGlvbikgJSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIFV0aWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudGlueWNvbG9yLm1peCA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDUwKTtcblxuICAgIHZhciByZ2IxID0gdGlueWNvbG9yKGNvbG9yMSkudG9SZ2IoKTtcbiAgICB2YXIgcmdiMiA9IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiKCk7XG5cbiAgICB2YXIgcCA9IGFtb3VudCAvIDEwMDtcblxuICAgIHZhciByZ2JhID0ge1xuICAgICAgICByOiAoKHJnYjIuciAtIHJnYjEucikgKiBwKSArIHJnYjEucixcbiAgICAgICAgZzogKChyZ2IyLmcgLSByZ2IxLmcpICogcCkgKyByZ2IxLmcsXG4gICAgICAgIGI6ICgocmdiMi5iIC0gcmdiMS5iKSAqIHApICsgcmdiMS5iLFxuICAgICAgICBhOiAoKHJnYjIuYSAtIHJnYjEuYSkgKiBwKSArIHJnYjEuYVxuICAgIH07XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYmEpO1xufTtcblxuXG4vLyBSZWFkYWJpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWYgKFdDQUcgVmVyc2lvbiAyKVxuXG4vLyBgY29udHJhc3RgXG4vLyBBbmFseXplIHRoZSAyIGNvbG9ycyBhbmQgcmV0dXJucyB0aGUgY29sb3IgY29udHJhc3QgZGVmaW5lZCBieSAoV0NBRyBWZXJzaW9uIDIpXG50aW55Y29sb3IucmVhZGFiaWxpdHkgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuICAgIHZhciBjMSA9IHRpbnljb2xvcihjb2xvcjEpO1xuICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xuICAgIHJldHVybiAoTWF0aC5tYXgoYzEuZ2V0THVtaW5hbmNlKCksYzIuZ2V0THVtaW5hbmNlKCkpKzAuMDUpIC8gKE1hdGgubWluKGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KTtcbn07XG5cbi8vIGBpc1JlYWRhYmxlYFxuLy8gRW5zdXJlIHRoYXQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBjb21iaW5hdGlvbnMgbWVldCBXQ0FHMiBndWlkZWxpbmVzLlxuLy8gVGhlIHRoaXJkIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIE9iamVjdC5cbi8vICAgICAgdGhlICdsZXZlbCcgcHJvcGVydHkgc3RhdGVzICdBQScgb3IgJ0FBQScgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdBQSc7XG4vLyAgICAgIHRoZSAnc2l6ZScgcHJvcGVydHkgc3RhdGVzICdsYXJnZScgb3IgJ3NtYWxsJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ3NtYWxsJy5cbi8vIElmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIGFic2VudCwgaXNSZWFkYWJsZSBkZWZhdWx0cyB0byB7bGV2ZWw6XCJBQVwiLHNpemU6XCJzbWFsbFwifS5cblxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIpID0+IGZhbHNlXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIse2xldmVsOlwiQUFcIixzaXplOlwibGFyZ2VcIn0pID0+IGZhbHNlXG50aW55Y29sb3IuaXNSZWFkYWJsZSA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCB3Y2FnMikge1xuICAgIHZhciByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShjb2xvcjEsIGNvbG9yMik7XG4gICAgdmFyIHdjYWcyUGFybXMsIG91dDtcblxuICAgIG91dCA9IGZhbHNlO1xuXG4gICAgd2NhZzJQYXJtcyA9IHZhbGlkYXRlV0NBRzJQYXJtcyh3Y2FnMik7XG4gICAgc3dpdGNoICh3Y2FnMlBhcm1zLmxldmVsICsgd2NhZzJQYXJtcy5zaXplKSB7XG4gICAgICAgIGNhc2UgXCJBQXNtYWxsXCI6XG4gICAgICAgIGNhc2UgXCJBQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQWxhcmdlXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQUFzbWFsbFwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuXG59O1xuXG4vLyBgbW9zdFJlYWRhYmxlYFxuLy8gR2l2ZW4gYSBiYXNlIGNvbG9yIGFuZCBhIGxpc3Qgb2YgcG9zc2libGUgZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kXG4vLyBjb2xvcnMgZm9yIHRoYXQgYmFzZSwgcmV0dXJucyB0aGUgbW9zdCByZWFkYWJsZSBjb2xvci5cbi8vIE9wdGlvbmFsbHkgcmV0dXJucyBCbGFjayBvciBXaGl0ZSBpZiB0aGUgbW9zdCByZWFkYWJsZSBjb2xvciBpcyB1bnJlYWRhYmxlLlxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjMTIzXCIsIFtcIiMxMjRcIiwgXCIjMTI1XCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6ZmFsc2V9KS50b0hleFN0cmluZygpOyAvLyBcIiMxMTIyNTVcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWV9KS50b0hleFN0cmluZygpOyAgLy8gXCIjZmZmZmZmXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcImxhcmdlXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmYWYzZjNcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiNhODAxNWFcIiwgW1wiI2ZhZjNmM1wiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XCJBQUFcIixzaXplOlwic21hbGxcIn0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiI2ZmZmZmZlwiXG50aW55Y29sb3IubW9zdFJlYWRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9yLCBjb2xvckxpc3QsIGFyZ3MpIHtcbiAgICB2YXIgYmVzdENvbG9yID0gbnVsbDtcbiAgICB2YXIgYmVzdFNjb3JlID0gMDtcbiAgICB2YXIgcmVhZGFiaWxpdHk7XG4gICAgdmFyIGluY2x1ZGVGYWxsYmFja0NvbG9ycywgbGV2ZWwsIHNpemUgO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGluY2x1ZGVGYWxsYmFja0NvbG9ycyA9IGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzIDtcbiAgICBsZXZlbCA9IGFyZ3MubGV2ZWw7XG4gICAgc2l6ZSA9IGFyZ3Muc2l6ZTtcblxuICAgIGZvciAodmFyIGk9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGJhc2VDb2xvciwgY29sb3JMaXN0W2ldKTtcbiAgICAgICAgaWYgKHJlYWRhYmlsaXR5ID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSByZWFkYWJpbGl0eTtcbiAgICAgICAgICAgIGJlc3RDb2xvciA9IHRpbnljb2xvcihjb2xvckxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbnljb2xvci5pc1JlYWRhYmxlKGJhc2VDb2xvciwgYmVzdENvbG9yLCB7XCJsZXZlbFwiOmxldmVsLFwic2l6ZVwiOnNpemV9KSB8fCAhaW5jbHVkZUZhbGxiYWNrQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBiZXN0Q29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycz1mYWxzZTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvci5tb3N0UmVhZGFibGUoYmFzZUNvbG9yLFtcIiNmZmZcIiwgXCIjMDAwXCJdLGFyZ3MpO1xuICAgIH1cbn07XG5cblxuLy8gQmlnIExpc3Qgb2YgQ29sb3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3I+XG52YXIgbmFtZXMgPSB0aW55Y29sb3IubmFtZXMgPSB7XG4gICAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICAgIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcbiAgICBhcXVhOiBcIjBmZlwiLFxuICAgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gICAgYXp1cmU6IFwiZjBmZmZmXCIsXG4gICAgYmVpZ2U6IFwiZjVmNWRjXCIsXG4gICAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICAgIGJsYWNrOiBcIjAwMFwiLFxuICAgIGJsYW5jaGVkYWxtb25kOiBcImZmZWJjZFwiLFxuICAgIGJsdWU6IFwiMDBmXCIsXG4gICAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcbiAgICBicm93bjogXCJhNTJhMmFcIixcbiAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG4gICAgY2FkZXRibHVlOiBcIjVmOWVhMFwiLFxuICAgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gICAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuICAgIGNvcmFsOiBcImZmN2Y1MFwiLFxuICAgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICAgIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuICAgIGNyaW1zb246IFwiZGMxNDNjXCIsXG4gICAgY3lhbjogXCIwZmZcIixcbiAgICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcbiAgICBkYXJrY3lhbjogXCIwMDhiOGJcIixcbiAgICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICAgIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuICAgIGRhcmtncmVlbjogXCIwMDY0MDBcIixcbiAgICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG4gICAgZGFya21hZ2VudGE6IFwiOGIwMDhiXCIsXG4gICAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gICAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcbiAgICBkYXJrb3JjaGlkOiBcIjk5MzJjY1wiLFxuICAgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gICAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcbiAgICBkYXJrc2VhZ3JlZW46IFwiOGZiYzhmXCIsXG4gICAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFwiMmY0ZjRmXCIsXG4gICAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuICAgIGRlZXBwaW5rOiBcImZmMTQ5M1wiLFxuICAgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICAgIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG4gICAgZGltZ3JleTogXCI2OTY5NjlcIixcbiAgICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICAgIGZpcmVicmljazogXCJiMjIyMjJcIixcbiAgICBmbG9yYWx3aGl0ZTogXCJmZmZhZjBcIixcbiAgICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgICBmdWNoc2lhOiBcImYwZlwiLFxuICAgIGdhaW5zYm9ybzogXCJkY2RjZGNcIixcbiAgICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICAgIGdvbGQ6IFwiZmZkNzAwXCIsXG4gICAgZ29sZGVucm9kOiBcImRhYTUyMFwiLFxuICAgIGdyYXk6IFwiODA4MDgwXCIsXG4gICAgZ3JlZW46IFwiMDA4MDAwXCIsXG4gICAgZ3JlZW55ZWxsb3c6IFwiYWRmZjJmXCIsXG4gICAgZ3JleTogXCI4MDgwODBcIixcbiAgICBob25leWRldzogXCJmMGZmZjBcIixcbiAgICBob3RwaW5rOiBcImZmNjliNFwiLFxuICAgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgICBpbmRpZ286IFwiNGIwMDgyXCIsXG4gICAgaXZvcnk6IFwiZmZmZmYwXCIsXG4gICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG4gICAgbGF2ZW5kZXJibHVzaDogXCJmZmYwZjVcIixcbiAgICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gICAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuICAgIGxpZ2h0Ymx1ZTogXCJhZGQ4ZTZcIixcbiAgICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICAgIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCJmYWZhZDJcIixcbiAgICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcbiAgICBsaWdodGdyZXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICAgIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFwiMjBiMmFhXCIsXG4gICAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICAgIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuICAgIGxpbWU6IFwiMGYwXCIsXG4gICAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICAgIGxpbmVuOiBcImZhZjBlNlwiLFxuICAgIG1hZ2VudGE6IFwiZjBmXCIsXG4gICAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG4gICAgbWVkaXVtYmx1ZTogXCIwMDAwY2RcIixcbiAgICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gICAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBcIjNjYjM3MVwiLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcbiAgICBtZWRpdW10dXJxdW9pc2U6IFwiNDhkMWNjXCIsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICAgIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcbiAgICBtaW50Y3JlYW06IFwiZjVmZmZhXCIsXG4gICAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICAgIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuICAgIG5hdmFqb3doaXRlOiBcImZmZGVhZFwiLFxuICAgIG5hdnk6IFwiMDAwMDgwXCIsXG4gICAgb2xkbGFjZTogXCJmZGY1ZTZcIixcbiAgICBvbGl2ZTogXCI4MDgwMDBcIixcbiAgICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gICAgb3JhbmdlOiBcImZmYTUwMFwiLFxuICAgIG9yYW5nZXJlZDogXCJmZjQ1MDBcIixcbiAgICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gICAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcbiAgICBwYWxlZ3JlZW46IFwiOThmYjk4XCIsXG4gICAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuICAgIHBhcGF5YXdoaXA6IFwiZmZlZmQ1XCIsXG4gICAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICAgIHBlcnU6IFwiY2Q4NTNmXCIsXG4gICAgcGluazogXCJmZmMwY2JcIixcbiAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG4gICAgcHVycGxlOiBcIjgwMDA4MFwiLFxuICAgIHJlYmVjY2FwdXJwbGU6IFwiNjYzMzk5XCIsXG4gICAgcmVkOiBcImYwMFwiLFxuICAgIHJvc3licm93bjogXCJiYzhmOGZcIixcbiAgICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gICAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG4gICAgc2FsbW9uOiBcImZhODA3MlwiLFxuICAgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gICAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG4gICAgc2Vhc2hlbGw6IFwiZmZmNWVlXCIsXG4gICAgc2llbm5hOiBcImEwNTIyZFwiLFxuICAgIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgICBza3libHVlOiBcIjg3Y2VlYlwiLFxuICAgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG4gICAgc2xhdGVncmV5OiBcIjcwODA5MFwiLFxuICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG4gICAgc3RlZWxibHVlOiBcIjQ2ODJiNFwiLFxuICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICB0ZWFsOiBcIjAwODA4MFwiLFxuICAgIHRoaXN0bGU6IFwiZDhiZmQ4XCIsXG4gICAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICAgIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcbiAgICB2aW9sZXQ6IFwiZWU4MmVlXCIsXG4gICAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gICAgd2hpdGU6IFwiZmZmXCIsXG4gICAgd2hpdGVzbW9rZTogXCJmNWY1ZjVcIixcbiAgICB5ZWxsb3c6IFwiZmYwXCIsXG4gICAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcbn07XG5cbi8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBgaGV4TmFtZXNbaGV4XWBcbnZhciBoZXhOYW1lcyA9IHRpbnljb2xvci5oZXhOYW1lcyA9IGZsaXAobmFtZXMpO1xuXG5cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tXG5cbi8vIGB7ICduYW1lMSc6ICd2YWwxJyB9YCBiZWNvbWVzIGB7ICd2YWwxJzogJ25hbWUxJyB9YFxuZnVuY3Rpb24gZmxpcChvKSB7XG4gICAgdmFyIGZsaXBwZWQgPSB7IH07XG4gICAgZm9yICh2YXIgaSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZDtcbn1cblxuLy8gUmV0dXJuIGEgdmFsaWQgYWxwaGEgdmFsdWUgWzAsMV0gd2l0aCBhbGwgaW52YWxpZCB2YWx1ZXMgYmVpbmcgc2V0IHRvIDFcbmZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG4vLyBUYWtlIGlucHV0IGZyb20gWzAsIG5dIGFuZCByZXR1cm4gaXQgYXMgWzAsIDFdXG5mdW5jdGlvbiBib3VuZDAxKG4sIG1heCkge1xuICAgIGlmIChpc09uZVBvaW50WmVybyhuKSkgeyBuID0gXCIxMDAlXCI7IH1cblxuICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcbiAgICBuID0gbWF0aE1pbihtYXgsIG1hdGhNYXgoMCwgcGFyc2VGbG9hdChuKSkpO1xuXG4gICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IHBlcmNlbnRhZ2UgaW50byBudW1iZXJcbiAgICBpZiAocHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgbiA9IHBhcnNlSW50KG4gKiBtYXgsIDEwKSAvIDEwMDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgaWYgKChNYXRoLmFicyhuIC0gbWF4KSA8IDAuMDAwMDAxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gWzAsIDFdIHJhbmdlIGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xufVxuXG4vLyBGb3JjZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbmZ1bmN0aW9uIGNsYW1wMDEodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhNaW4oMSwgbWF0aE1heCgwLCB2YWwpKTtcbn1cblxuLy8gUGFyc2UgYSBiYXNlLTE2IGhleCB2YWx1ZSBpbnRvIGEgYmFzZS0xMCBpbnRlZ2VyXG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTYpO1xufVxuXG4vLyBOZWVkIHRvIGhhbmRsZSAxLjAgYXMgMTAwJSwgc2luY2Ugb25jZSBpdCBpcyBhIG51bWJlciwgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGl0IGFuZCAxXG4vLyA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDIyMDcyL2phdmFzY3JpcHQtaG93LXRvLWRldGVjdC1udW1iZXItYXMtYS1kZWNpbWFsLWluY2x1ZGluZy0xLTA+XG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCcuJykgIT0gLTEgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHN0cmluZyBwYXNzZWQgaW4gaXMgYSBwZXJjZW50YWdlXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2Uobikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiAmJiBuLmluZGV4T2YoJyUnKSAhPSAtMTtcbn1cblxuLy8gRm9yY2UgYSBoZXggdmFsdWUgdG8gaGF2ZSAyIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBhZDIoYykge1xuICAgIHJldHVybiBjLmxlbmd0aCA9PSAxID8gJzAnICsgYyA6ICcnICsgYztcbn1cblxuLy8gUmVwbGFjZSBhIGRlY2ltYWwgd2l0aCBpdCdzIHBlcmNlbnRhZ2UgdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnRUb1BlcmNlbnRhZ2Uobikge1xuICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgbiA9IChuICogMTAwKSArIFwiJVwiO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG4vLyBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBoZXggdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnREZWNpbWFsVG9IZXgoZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZCkgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIGEgZGVjaW1hbFxuZnVuY3Rpb24gY29udmVydEhleFRvRGVjaW1hbChoKSB7XG4gICAgcmV0dXJuIChwYXJzZUludEZyb21IZXgoaCkgLyAyNTUpO1xufVxuXG52YXIgbWF0Y2hlcnMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzPlxuICAgIHZhciBDU1NfSU5URUdFUiA9IFwiWy1cXFxcK10/XFxcXGQrJT9cIjtcblxuICAgIC8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jbnVtYmVyLXZhbHVlPlxuICAgIHZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbiAgICAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gIERvbid0IGNhcHR1cmUgdGhlIGVpdGhlci9vciwganVzdCB0aGUgZW50aXJlIG91dGNvbWUuXG4gICAgdmFyIENTU19VTklUID0gXCIoPzpcIiArIENTU19OVU1CRVIgKyBcIil8KD86XCIgKyBDU1NfSU5URUdFUiArIFwiKVwiO1xuXG4gICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxuICAgIC8vIFBhcmVudGhlc2VzIGFuZCBjb21tYXMgYXJlIG9wdGlvbmFsLCBidXQgbm90IHJlcXVpcmVkLlxuICAgIC8vIFdoaXRlc3BhY2UgY2FuIHRha2UgdGhlIHBsYWNlIG9mIGNvbW1hcyBvciBvcGVuaW5nIHBhcmVuXG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0g0ID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBDU1NfVU5JVDogbmV3IFJlZ0V4cChDU1NfVU5JVCksXG4gICAgICAgIHJnYjogbmV3IFJlZ0V4cChcInJnYlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICByZ2JhOiBuZXcgUmVnRXhwKFwicmdiYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgaHNsYTogbmV3IFJlZ0V4cChcImhzbGFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHN2OiBuZXcgUmVnRXhwKFwiaHN2XCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzdmE6IG5ldyBSZWdFeHAoXCJoc3ZhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhleDM6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4NjogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICAgICAgICBoZXg0OiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXG4gICAgfTtcbn0pKCk7XG5cbi8vIGBpc1ZhbGlkQ1NTVW5pdGBcbi8vIFRha2UgaW4gYSBzaW5nbGUgc3RyaW5nIC8gbnVtYmVyIGFuZCBjaGVjayB0byBzZWUgaWYgaXQgbG9va3MgbGlrZSBhIENTUyB1bml0XG4vLyAoc2VlIGBtYXRjaGVyc2AgYWJvdmUgZm9yIGRlZmluaXRpb24pLlxuZnVuY3Rpb24gaXNWYWxpZENTU1VuaXQoY29sb3IpIHtcbiAgICByZXR1cm4gISFtYXRjaGVycy5DU1NfVU5JVC5leGVjKGNvbG9yKTtcbn1cblxuLy8gYHN0cmluZ0lucHV0VG9PYmplY3RgXG4vLyBQZXJtaXNzaXZlIHN0cmluZyBwYXJzaW5nLiAgVGFrZSBpbiBhIG51bWJlciBvZiBmb3JtYXRzLCBhbmQgb3V0cHV0IGFuIG9iamVjdFxuLy8gYmFzZWQgb24gZGV0ZWN0ZWQgZm9ybWF0LiAgUmV0dXJucyBgeyByLCBnLCBiIH1gIG9yIGB7IGgsIHMsIGwgfWAgb3IgYHsgaCwgcywgdn1gXG5mdW5jdGlvbiBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKSB7XG5cbiAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UodHJpbUxlZnQsJycpLnJlcGxhY2UodHJpbVJpZ2h0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZWQgPSBmYWxzZTtcbiAgICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZXNbY29sb3JdO1xuICAgICAgICBuYW1lZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yID09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogMCwgZzogMCwgYjogMCwgYTogMCwgZm9ybWF0OiBcIm5hbWVcIiB9O1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtYXRjaCBzdHJpbmcgaW5wdXQgdXNpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAvLyBLZWVwIG1vc3Qgb2YgdGhlIG51bWJlciBib3VuZGluZyBvdXQgb2YgdGhpcyBmdW5jdGlvbiAtIGRvbid0IHdvcnJ5IGFib3V0IFswLDFdIG9yIFswLDEwMF0gb3IgWzAsMzYwXVxuICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cbiAgICAvLyBUaGlzIHdheSB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIHNhbWUgd2hldGhlciB0aGUgdGlueWNvbG9yIGlzIGluaXRpYWxpemVkIHdpdGggc3RyaW5nIG9yIG9iamVjdC5cbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2YS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0gKyAnJyArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0gKyAnJyArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXQ0FHMlBhcm1zKHBhcm1zKSB7XG4gICAgLy8gcmV0dXJuIHZhbGlkIFdDQUcyIHBhcm1zIGZvciBpc1JlYWRhYmxlLlxuICAgIC8vIElmIGlucHV0IHBhcm1zIGFyZSBpbnZhbGlkLCByZXR1cm4ge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn1cbiAgICB2YXIgbGV2ZWwsIHNpemU7XG4gICAgcGFybXMgPSBwYXJtcyB8fCB7XCJsZXZlbFwiOlwiQUFcIiwgXCJzaXplXCI6XCJzbWFsbFwifTtcbiAgICBsZXZlbCA9IChwYXJtcy5sZXZlbCB8fCBcIkFBXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgc2l6ZSA9IChwYXJtcy5zaXplIHx8IFwic21hbGxcIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGV2ZWwgIT09IFwiQUFcIiAmJiBsZXZlbCAhPT0gXCJBQUFcIikge1xuICAgICAgICBsZXZlbCA9IFwiQUFcIjtcbiAgICB9XG4gICAgaWYgKHNpemUgIT09IFwic21hbGxcIiAmJiBzaXplICE9PSBcImxhcmdlXCIpIHtcbiAgICAgICAgc2l6ZSA9IFwic21hbGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcImxldmVsXCI6bGV2ZWwsIFwic2l6ZVwiOnNpemV9O1xufVxuXG4vLyBOb2RlOiBFeHBvcnQgZnVuY3Rpb25cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55Y29sb3I7XG59XG4vLyBBTUQvcmVxdWlyZWpzOiBEZWZpbmUgdGhlIG1vZHVsZVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtyZXR1cm4gdGlueWNvbG9yO30pO1xufVxuLy8gQnJvd3NlcjogRXhwb3NlIHRvIHdpbmRvd1xuZWxzZSB7XG4gICAgd2luZG93LnRpbnljb2xvciA9IHRpbnljb2xvcjtcbn1cblxufSkoTWF0aCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW55Y29sb3IyL3Rpbnljb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IE1hdDQgZnJvbSAnLi4vdXRpbHMvbWF0NCdcbmltcG9ydCBTaGFkZXJVbmlmb3JtVmFyaWFibGUgZnJvbSAnLi4vY29yZS9zaGFkZXJfdW5pZm9ybV92YXJpYWJsZSdcblxuY29uc3QgVU5JRk9STV9OQU1FID0gJ3ZpZXdNYXRyaXgnXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kZXNpcmVkV2lkdGhdIC0gZGVzaXJlZCB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlc2lyZWRIZWlnaHRdIC0gZGVzaXJlZCBoZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5waXhlbFJhdGlvXSAtIHBpeGVsIHJhdGlvXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2l6ZUZpdF0gLSBgY292ZXJgLCBgY29udGFpbmAgb3IgYGZpbGxgXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudW5pZm9ybU5hbWU9J3ZpZXdNYXRyaXgnXSAtIG5hbWUgb2YgdGhlIHVuaWZvcm0gdmFsdWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yICh7IGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCwgcGl4ZWxSYXRpbywgc2l6ZUZpdCwgdW5pZm9ybU5hbWUgfSkge1xuICAgIHRoaXMuZGVzaXJlZFdpZHRoID0gZGVzaXJlZFdpZHRoXG4gICAgdGhpcy5kZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodFxuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW9cbiAgICB0aGlzLnNpemVGaXQgPSBzaXplRml0XG4gICAgdGhpcy51bmlmb3JtID0gbmV3IFNoYWRlclVuaWZvcm1WYXJpYWJsZSh1bmlmb3JtTmFtZSB8fCBVTklGT1JNX05BTUUsIG5ldyBNYXQ0KCkpXG4gICAgdGhpcy53aWR0aCA9IDBcbiAgICB0aGlzLmhlaWdodCA9IDBcbiAgfVxuXG4gIHVwZGF0ZU9ydGhvICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLndpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aFxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgIC8vIHRoaXMudW5pZm9ybS52YWx1ZS5vcnRobyh3aWR0aCwgaGVpZ2h0KVxuICAgICAgLy8gVE9ETyBlbmFibGUgcGVyc3BlY3RpdmUgd2l0aCBkaXN0YW5jZVxuICAgICAgdGhpcy51bmlmb3JtLnZhbHVlLnBlcnNwZWN0aXZlKHdpZHRoLCBoZWlnaHQsIDEwMClcbiAgICAgIHRoaXMudW5pZm9ybS50b3VjaCgpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlIChjdXJyZW50V2lkdGgsIGN1cnJlbnRIZWlnaHQpIHtcbiAgICAvLyBUT0RPIHBpeGVsUmF0aW8gYW5kIGN1cnJlbnRQaXhlbFJhdGlvXG4gICAgaWYgKHRoaXMuc2l6ZUZpdCA9PT0gJ2ZpbGwnICYmIHRoaXMuZGVzaXJlZFdpZHRoID4gMCAmJiB0aGlzLmRlc2lyZWRIZWlnaHQgPiAwKSB7XG4gICAgICB0aGlzLnVwZGF0ZU9ydGhvKHRoaXMuZGVzaXJlZFdpZHRoLCB0aGlzLmRlc2lyZWRIZWlnaHQpXG4gICAgfSBlbHNlIGlmICgodGhpcy5zaXplRml0ID09PSAnY292ZXInIHx8IHRoaXMuc2l6ZUZpdCA9PT0gJ2NvbnRhaW4nKSAmJlxuICAgICAgdGhpcy5kZXNpcmVkV2lkdGggPj0gMCAmJiB0aGlzLmRlc2lyZWRIZWlnaHQgPj0gMCkge1xuICAgICAgY29uc3QgY3VycmVudFJhdGlvID0gY3VycmVudEhlaWdodCAvIGN1cnJlbnRXaWR0aCAgICAgICAgICAgIC8vIDwxIDogbGFuZHNjYXBlLCA+MSA6IHBvcnRyYWl0XG4gICAgICBjb25zdCBkZXNpcmVkUmF0aW8gPSB0aGlzLmRlc2lyZWRIZWlnaHQgLyB0aGlzLmRlc2lyZWRXaWR0aFxuICAgICAgY29uc3QgaXNDb3ZlciA9IHRoaXMuc2l6ZUZpdCA9PT0gJ2NvdmVyJ1xuXG4gICAgICBsZXQgd2lkdGggPSB0aGlzLmRlc2lyZWRXaWR0aFxuICAgICAgbGV0IGhlaWdodCA9IHRoaXMuZGVzaXJlZEhlaWdodFxuXG4gICAgICBpZiAoKHRoaXMuZGVzaXJlZFdpZHRoID09PSAwICYmIHRoaXMuZGVzaXJlZEhlaWdodCkgfHwgY3VycmVudFJhdGlvIDwgZGVzaXJlZFJhdGlvKSB7XG4gICAgICAgIHdpZHRoID0gKHRoaXMuZGVzaXJlZEhlaWdodCAvIGN1cnJlbnRIZWlnaHQpICogY3VycmVudFdpZHRoXG4gICAgICAgIGlmIChpc0NvdmVyKSB7XG4gICAgICAgICAgY29uc3QgZmFjdG9yID0gdGhpcy5kZXNpcmVkV2lkdGggLyB3aWR0aFxuICAgICAgICAgIHdpZHRoICo9IGZhY3RvclxuICAgICAgICAgIGhlaWdodCAqPSBmYWN0b3JcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgodGhpcy5kZXNpcmVkV2lkdGggJiYgdGhpcy5kZXNpcmVkSGVpZ2h0ID09PSAwKSB8fCBjdXJyZW50UmF0aW8gPiBkZXNpcmVkUmF0aW8pIHtcbiAgICAgICAgaGVpZ2h0ID0gKHRoaXMuZGVzaXJlZFdpZHRoIC8gY3VycmVudFdpZHRoKSAqIGN1cnJlbnRIZWlnaHRcbiAgICAgICAgaWYgKGlzQ292ZXIpIHtcbiAgICAgICAgICBjb25zdCBmYWN0b3IgPSB0aGlzLmRlc2lyZWRIZWlnaHQgLyBoZWlnaHRcbiAgICAgICAgICB3aWR0aCAqPSBmYWN0b3JcbiAgICAgICAgICBoZWlnaHQgKj0gZmFjdG9yXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVPcnRobyh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvcHJvamVjdGlvbi5qcyIsImNvbnN0IHsgbWF0NCB9ID0gcmVxdWlyZSgnZ2wtbWF0cml4JylcblxuY29uc3QgREVHMlJBRCA9IE1hdGguUEkgLyAxODAuMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXQ0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWF0NCA9IG1hdDQuY3JlYXRlKClcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpXG4gIH1cblxuICBpZGVudGl0eSAoKSB7XG4gICAgbWF0NC5pZGVudGl0eSh0aGlzLm1hdDQpXG4gIH1cblxuICBvcnRobyAod2lkdGgsIGhlaWdodCwgelJhbmdlID0gTWF0aC5wb3coMiwgMTYpKSB7XG4gICAgY29uc3QgaHcgPSB3aWR0aCA+PiAxXG4gICAgY29uc3QgaGggPSBoZWlnaHQgPj4gMVxuICAgIGNvbnN0IGh6ID0gelJhbmdlID4+IDFcbiAgICBtYXQ0Lm9ydGhvKHRoaXMubWF0NCwgLWh3LCBodywgLWhoLCBoaCwgLWh6LCBoeilcbiAgfVxuXG4gIHBlcnNwZWN0aXZlICh3aWR0aCwgaGVpZ2h0LCBkaXN0YW5jZSA9IDEwMCkge1xuICAgIC8vIGh0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtM2QtcGVyc3BlY3RpdmUuaHRtbFxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY2NTMwODAvaW4tb3BlbmdsLWhvdy1jYW4taS1kZXRlcm1pbmUtdGhlLWJvdW5kcy1vZi10aGUtdmlldy1hdC1hLWdpdmVuLWRlcHRoXG4gICAgLy8gaHR0cDovL2dsbWF0cml4Lm5ldC9kb2NzL21vZHVsZS1tYXQ0Lmh0bWxcbiAgICBjb25zdCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodFxuICAgIGNvbnN0IG5lYXIgPSAwXG4gICAgY29uc3QgZmFyID0gMjAwMFxuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyLjBcbiAgICBjb25zdCBmb3Z5ID0gMiAqIE1hdGguYXRhbihoYWxmSGVpZ2h0IC8gZGlzdGFuY2UpXG4gICAgbWF0NC5wZXJzcGVjdGl2ZSh0aGlzLm1hdDQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKVxuICAgIC8vIFRPRE8gY2FtZXJhIGZlYXR1cmVcbiAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLm1hdDQsIHRoaXMubWF0NCwgWzAsIDAsIC1kaXN0YW5jZV0pXG4gIH1cblxuICB0cmFuc2xhdGUgKHgsIHksIHogPSAwKSB7XG4gICAgbWF0NC50cmFuc2xhdGUodGhpcy5tYXQ0LCB0aGlzLm1hdDQsIFt4LCB5LCB6XSlcbiAgfVxuXG4gIHNjYWxlICh4LCB5LCB6ID0gMSkge1xuICAgIG1hdDQuc2NhbGUodGhpcy5tYXQ0LCB0aGlzLm1hdDQsIFt4LCB5LCB6XSlcbiAgfVxuXG4gIHJvdGF0ZVggKGRlZykge1xuICAgIG1hdDQucm90YXRlWCh0aGlzLm1hdDQsIHRoaXMubWF0NCwgZGVnICogREVHMlJBRClcbiAgfVxuXG4gIHJvdGF0ZVkgKGRlZykge1xuICAgIG1hdDQucm90YXRlWSh0aGlzLm1hdDQsIHRoaXMubWF0NCwgZGVnICogREVHMlJBRClcbiAgfVxuXG4gIHJvdGF0ZVogKGRlZykge1xuICAgIG1hdDQucm90YXRlWih0aGlzLm1hdDQsIHRoaXMubWF0NCwgZGVnICogREVHMlJBRClcbiAgfVxuXG4gIG11bHRpcGx5IChhLCBiKSB7XG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLm1hdDQsIGEubWF0NCwgYi5tYXQ0KVxuICB9XG5cbiAgY29weSAoc3JjKSB7XG4gICAgbWF0NC5jb3B5KHRoaXMubWF0NCwgc3JjLm1hdDQpXG4gIH1cblxuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZG9sbHkgPSBuZXcgTWF0NCgpXG4gICAgZG9sbHkuY29weSh0aGlzKVxuICAgIHJldHVybiBkb2xseVxuICB9XG5cbiAgZ2V0IHggKCkge1xuICAgIHJldHVybiB0aGlzLm1hdDRbMTJdXG4gIH1cblxuICBzZXQgeCAodmFsKSB7XG4gICAgdGhpcy5tYXQ0WzEyXSA9IHZhbFxuICB9XG5cbiAgZ2V0IHkgKCkge1xuICAgIHJldHVybiB0aGlzLm1hdDRbMTNdXG4gIH1cblxuICBzZXQgeSAodmFsKSB7XG4gICAgdGhpcy5tYXQ0WzEzXSA9IHZhbFxuICB9XG5cbiAgZ2V0IHogKCkge1xuICAgIHJldHVybiB0aGlzLm1hdDRbMTRdXG4gIH1cblxuICBzZXQgeiAodmFsKSB7XG4gICAgdGhpcy5tYXQ0WzE0XSA9IHZhbFxuICB9XG5cbiAgZ2V0IHN4ICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXQ0WzBdXG4gIH1cblxuICBzZXQgc3ggKHZhbCkge1xuICAgIHRoaXMubWF0NFswXSA9IHZhbFxuICB9XG5cbiAgZ2V0IHN5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXQ0WzVdXG4gIH1cblxuICBzZXQgc3kgKHZhbCkge1xuICAgIHRoaXMubWF0NFs1XSA9IHZhbFxuICB9XG5cbiAgZ2V0IHN6ICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXQ0WzEwXVxuICB9XG5cbiAgc2V0IHN6ICh2YWwpIHtcbiAgICB0aGlzLm1hdDRbMTBdID0gdmFsXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9tYXQ0LmpzIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogM3gzIE1hdHJpeFxuICogQG1vZHVsZSBtYXQzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbNF07XG4gIG91dFs0XSA9IGFbNV07XG4gIG91dFs1XSA9IGFbNl07XG4gIG91dFs2XSA9IGFbOF07XG4gIG91dFs3XSA9IGFbOV07XG4gIG91dFs4XSA9IGFbMTBdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGxldCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICBsZXQgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICBsZXQgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDtcbiAgbGV0IGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gYjAxICogZGV0O1xuICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgbGV0IGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl07XG4gIGxldCBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdO1xuICBsZXQgYjIwID0gYls2XSwgYjIxID0gYls3XSwgYjIyID0gYls4XTtcblxuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG4gICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG5cbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcblxuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gIG91dFs2XSA9IGEyMDtcbiAgb3V0WzddID0gYTIxO1xuICBvdXRbOF0gPSBhMjI7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcblxuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuXG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gdlswXTtcbiAgb3V0WzddID0gdlsxXTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcblxuICBvdXRbM10gPSAtcztcbiAgb3V0WzRdID0gYztcbiAgb3V0WzVdID0gMDtcblxuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcblxuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB2WzFdO1xuICBvdXRbNV0gPSAwO1xuXG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuXG4gIG91dFszXSA9IGFbMl07XG4gIG91dFs0XSA9IGFbM107XG4gIG91dFs1XSA9IDA7XG5cbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgbGV0IHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdO1xuICBsZXQgeDIgPSB4ICsgeDtcbiAgbGV0IHkyID0geSArIHk7XG4gIGxldCB6MiA9IHogKyB6O1xuXG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHl4ID0geSAqIHgyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB6eCA9IHogKiB4MjtcbiAgbGV0IHp5ID0geiAqIHkyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG5cbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFszXSA9IHl4IC0gd3o7XG4gIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICBsZXQgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBsZXQgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICBsZXQgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICBsZXQgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IC0yIC8gaGVpZ2h0O1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gLTE7XG4gICAgb3V0WzddID0gMTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICtcbiAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgK1xuICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuXG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gIG91dFs3XSA9IGFbN10gKyAoYls3XSAqIHNjYWxlKTtcbiAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmXG4gICAgICAgICBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sIGE2ID0gYVs2XSwgYTcgPSBhWzddLCBhOCA9IGFbOF07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdLCBiNiA9IGJbNl0sIGI3ID0gYls3XSwgYjggPSBiWzhdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjM1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl07XG4gIGxldCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICBsZXQgYXggPSBhWzBdO1xuICBsZXQgYXkgPSBhWzFdO1xuICBsZXQgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICBsZXQgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIGxldCBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICBsZXQgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICBsZXQgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIGxldCBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG5cbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgbGV0IGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgbGV0IGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICBsZXQgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIGxldCBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgbGV0IGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgbGV0IHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIGxldCB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgbGV0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdO1xuXG4gIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gIGxldCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICBsZXQgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIGxldCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICBsZXQgcCA9IFtdLCByPVtdO1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07XG5cbiAgLy9wZXJmb3JtIHJvdGF0aW9uXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG4gIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCBjKXtcbiAgbGV0IHAgPSBbXSwgcj1bXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG5cbiAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gIGxldCBwID0gW10sIHI9W107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICByWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIHJbMl0gPSBwWzJdO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICBsZXQgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICBsZXQgdGVtcEIgPSBmcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuXG4gIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICBub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcblxuICBsZXQgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgaWYoY29zaW5lID4gMS4wKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSBpZihjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDQgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6LCB3KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICBsZXQgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgbGV0IHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgdyA9IGFbM107XG4gIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgdyA9IGFbM107XG4gIGxldCBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIG91dFswXSA9IHggKiBsZW47XG4gICAgb3V0WzFdID0geSAqIGxlbjtcbiAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgIG91dFszXSA9IHcgKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICBsZXQgYXggPSBhWzBdO1xuICBsZXQgYXkgPSBhWzFdO1xuICBsZXQgYXogPSBhWzJdO1xuICBsZXQgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgdmVjdG9yU2NhbGUpIHtcbiAgdmVjdG9yU2NhbGUgPSB2ZWN0b3JTY2FsZSB8fCAxLjA7XG5cbiAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gIG91dFswXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgb3V0WzJdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG91dFszXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBub3JtYWxpemUob3V0LCBvdXQpO1xuICBzY2FsZShvdXQsIG91dCwgdmVjdG9yU2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdO1xuXG4gIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gIGxldCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICBsZXQgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIGxldCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAndmVjNCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgdmVjID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIGxldCBpLCBsO1xuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDQ7XG4gICAgfVxuXG4gICAgaWYoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZihjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjNC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFNoYWRlclZhcmlhYmxlIGZyb20gJy4vc2hhZGVyX3ZhcmlhYmxlJ1xuXG4vKipcbiAqIFNoYWRlciB1bmlmb3JtIHZhcmlhYmxlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJVbmlmb3JtVmFyaWFibGUgZXh0ZW5kcyBTaGFkZXJWYXJpYWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgdmFsdWUpIHtcbiAgICBzdXBlcihuYW1lLCBTaGFkZXJWYXJpYWJsZS5UWVBFLlVOSUZPUk0sIHZhbHVlKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS9zaGFkZXJfdW5pZm9ybV92YXJpYWJsZS5qcyIsImNvbnN0IHNuYWtlQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC9zbmFrZUNhc2UnKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbGVuZE1vZGUge1xuICBjb25zdHJ1Y3RvciAoZW5hYmxlLCBzZmFjdG9yID0gbnVsbCwgZGZhY3RvciA9IG51bGwpIHtcbiAgICB0aGlzLmVuYWJsZSA9IGVuYWJsZVxuICAgIHRoaXMuc2ZhY3RvciA9IHNmYWN0b3JcbiAgICB0aGlzLmRmYWN0b3IgPSBkZmFjdG9yXG4gIH1cblxuICBzZXQgc2ZhY3RvciAodmFsdWUpIHtcbiAgICB0aGlzLl9zZmFjdG9yID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHNuYWtlQ2FzZSh2YWx1ZSkudG9VcHBlckNhc2UoKSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IHNmYWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9zZmFjdG9yXG4gIH1cblxuICBzZXQgZGZhY3RvciAodmFsdWUpIHtcbiAgICB0aGlzLl9kZmFjdG9yID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHNuYWtlQ2FzZSh2YWx1ZSkudG9VcHBlckNhc2UoKSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IGRmYWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9kZmFjdG9yXG4gIH1cblxuICBpc0VxdWFsIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciAmJiB0aGlzLmVuYWJsZSA9PT0gb3RoZXIuZW5hYmxlICYmIHRoaXMuX3NmYWN0b3IgPT09IG90aGVyLl9zZmFjdG9yICYmIHRoaXMuX2RmYWN0b3IgPT09IG90aGVyLl9kZmFjdG9yXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL2JsZW5kX21vZGUuanMiLCJcbmNvbnN0IGxvZyA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyA/IChcbiAgdHlwZW9mIGNvbnNvbGUuZGVidWcgPT09ICdmdW5jdGlvbidcbiAgPyAoLi4uYXJncykgPT4gY29uc29sZS5kZWJ1ZyguLi5hcmdzKVxuICA6ICguLi5hcmdzKSA9PiBjb25zb2xlLmxvZyguLi5hcmdzKVxuKSA6ICgpID0+IDFcblxuY29uc3QgZXJyb3IgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyAoXG4gIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nXG4gID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncylcbiAgOiAoLi4uYXJncykgPT4gY29uc29sZS5sb2coLi4uYXJncylcbikgOiAoKSA9PiAxXG5cbmV4cG9ydCBkZWZhdWx0IGxvZ1xuZXhwb3J0IHtcbiAgZXJyb3Jcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2cuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlbCwgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghZWwuaGFzQXR0cmlidXRlKG5hbWUpKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIHN3aXRjaCAoZWwuZ2V0QXR0cmlidXRlKG5hbWUpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICd0cnVlJzpcbiAgICBjYXNlICd5ZXMnOlxuICAgIGNhc2UgJ29uJzpcbiAgICBjYXNlICcnOlxuICAgIGNhc2UgbmFtZTpcbiAgICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZG9tL2xpYi9yZWFkQm9vbGVhbkF0dHJpYnV0ZS5qcyIsImNvbnN0IEVYSVRfTk9ERVMgPSBbJ0JPRFknLCAnSFRNTCddXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRQYXJlbnRFbGVtZW50QnlOYW1lIChub2RlLCAuLi5uYW1lcykge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudEVsZW1lbnRcbiAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9PSAxKSByZXR1cm5cbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gcGFyZW50XG4gIGlmIChuYW1lcy5pbmNsdWRlcyhub2RlTmFtZSkpIHJldHVybiBwYXJlbnRcbiAgaWYgKEVYSVRfTk9ERVMuaW5jbHVkZXMobm9kZU5hbWUpKSByZXR1cm5cbiAgcmV0dXJuIHBhcmVudFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RvbS9saWIvZmluZF9wYXJlbnRfZWxlbWVudF9ieV9uYW1lLmpzIiwiaW1wb3J0IGZpbmRCbGl0cHVua0NhbnZhc0VsZW1lbnQgZnJvbSAnLi9maW5kQmxpdHB1bmtDYW52YXNFbGVtZW50LmpzJ1xuaW1wb3J0IGZpbmRQYXJlbnRFbGVtZW50QnlQcm9wZXJ0eSBmcm9tICcuL2ZpbmRQYXJlbnRFbGVtZW50QnlQcm9wZXJ0eS5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVsKSB7XG4gIGVsLmJsaXRwdW5rQ2FudmFzID0gZmluZEJsaXRwdW5rQ2FudmFzRWxlbWVudChlbClcbiAgZWwuYmxpdHB1bmsgPSBlbC5ibGl0cHVua0NhbnZhcy5ibGl0cHVua1xuXG4gIGVsLmVudGl0eU1hbmFnZXIgPSBlbC5ibGl0cHVuay5lbnRpdHlNYW5hZ2VyXG4gIGVsLmVudGl0eSA9IGVsLmVudGl0eU1hbmFnZXIuY3JlYXRlRW50aXR5KClcbiAgZWwuZW50aXR5Lm9uKGVsKVxuXG4gIGVsLnBhcmVudFNjZW5lRWxlbWVudCA9IGZpbmRQYXJlbnRFbGVtZW50QnlQcm9wZXJ0eShlbCwgJ3NjZW5lJylcbiAgZWwucGFyZW50U2NlbmUgPSBlbC5wYXJlbnRTY2VuZUVsZW1lbnQuc2NlbmVcbiAgZWwucGFyZW50U2NlbmUuY2hpbGRyZW4uYXBwZW5kQ2hpbGQoZWwuZW50aXR5KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RvbS9saWIvY29ubmVjdEVsZW1lbnRFbnRpdGllcy5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVsKSB7XG4gIGVsLnBhcmVudFNjZW5lLmNoaWxkcmVuLnJlbW92ZUNoaWxkKGVsLmVudGl0eSlcbiAgZWwucGFyZW50U2NlbmUgPSBudWxsXG4gIGVsLnBhcmVudFNjZW5lRWxlbWVudCA9IG51bGxcbiAgZWwuZW50aXR5Lm9mZihlbClcbiAgZWwuZW50aXR5TWFuYWdlci5kZXN0cm95RW50aXR5KGVsLmVudGl0eSlcbiAgZWwuZW50aXR5ID0gbnVsbFxuICBlbC5ibGl0cHVuayA9IG51bGxcbiAgZWwuYmxpdHB1bmtDYW52YXMgPSBudWxsXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZG9tL2xpYi9kaXNjb25uZWN0RWxlbWVudEVudGl0aWVzLmpzIiwiaW1wb3J0IEVsZW1lbnRJbmRleEFycmF5IGZyb20gJy4vZWxlbWVudF9pbmRleF9hcnJheSdcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vc2hhZGVyX3Byb2dyYW0nXG5pbXBvcnQgU2hhZGVyVGV4dHVyZUdyb3VwIGZyb20gJy4vc2hhZGVyX3RleHR1cmVfZ3JvdXAnXG5pbXBvcnQgU2hhZGVyVmFyaWFibGVCdWZmZXJHcm91cCBmcm9tICcuL3NoYWRlcl92YXJpYWJsZV9idWZmZXJfZ3JvdXAnXG5pbXBvcnQgVk9Qb29sIGZyb20gJy4vdl9vX3Bvb2wnXG5cbmNvbnN0IHBpY2sgPSByZXF1aXJlKCdsb2Rhc2gvcGljaycpXG5cbmNvbnN0IGdldFZPID0gKGRlc2NyaXB0b3IsIG9wdCkgPT4ge1xuICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZvID0gZGVzY3JpcHRvci5jcmVhdGVWTygpXG4gICAgb3B0KHZvKVxuICAgIHJldHVybiB2b1xuICB9XG4gIHJldHVybiBvcHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlR3JvdXAge1xuICBjb25zdHJ1Y3RvciAocmVzb3VyY2VMaWJyYXJ5LCB0ZXh0dXJlTGlicmFyeSwgb3B0aW9ucykge1xuICAgIHRoaXMucmVzb3VyY2VMaWJyYXJ5ID0gcmVzb3VyY2VMaWJyYXJ5XG4gICAgdGhpcy50ZXh0dXJlTGlicmFyeSA9IHRleHR1cmVMaWJyYXJ5XG4gICAgdGhpcy5kZXNjcmlwdG9yID0gcmVzb3VyY2VMaWJyYXJ5LmZpbmREZXNjcmlwdG9yKG9wdGlvbnMuZGVzY3JpcHRvcilcbiAgICB0aGlzLnZvUG9vbCA9IG5ldyBWT1Bvb2wodGhpcy5kZXNjcmlwdG9yLCBPYmplY3QuYXNzaWduKHBpY2sob3B0aW9ucywgW1xuICAgICAgJ2NhcGFjaXR5JyxcbiAgICAgICd1c2FnZScsXG4gICAgICAnbWF4QWxsb2NWT1NpemUnLFxuICAgICAgJ3ZvQXJyYXknXG4gICAgXSksIHtcbiAgICAgIHZvTmV3OiBnZXRWTyh0aGlzLmRlc2NyaXB0b3IsIG9wdGlvbnMudm9OZXcpLFxuICAgICAgdm9aZXJvOiBnZXRWTyh0aGlzLmRlc2NyaXB0b3IsIG9wdGlvbnMudm9aZXJvKVxuICAgIH0pKVxuICAgIHRoaXMudm9Qb29sU2hhZGVyQXR0cmlicyA9IG5ldyBTaGFkZXJWYXJpYWJsZUJ1ZmZlckdyb3VwKHRoaXMudm9Qb29sKVxuICAgIHRoaXMuaW5kaWNlcyA9IG9wdGlvbnMuaW5kaWNlcyB8fCBFbGVtZW50SW5kZXhBcnJheS5HZW5lcmF0ZSh0aGlzLnZvUG9vbC5jYXBhY2l0eSxcbiAgICAgIFswLCAxLCAyLCAwLCAyLCAzXSwgNCAgLy8gcXVhZHNcbiAgICAgIC8vIFRPRE8gY3JlYXRlIEVsZW1lbnRJbmRleEFycmF5IGZhY3RvcmllcyEgY2FwYWNpdHk9TiwgdHlwZT1xdWFkcywgLi4uXG4gICAgKVxuICAgIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgcmVzb3VyY2VMaWJyYXJ5LmZpbmRWZXJ0ZXhTaGFkZXIob3B0aW9ucy52ZXJ0ZXhTaGFkZXIpLFxuICAgICAgcmVzb3VyY2VMaWJyYXJ5LmZpbmRGcmFnbWVudFNoYWRlcihvcHRpb25zLmZyYWdtZW50U2hhZGVyKSlcbiAgICB0aGlzLnByaW1pdGl2ZSA9IG9wdGlvbnMucHJpbWl0aXZlXG4gICAgdGhpcy50ZXh0dXJlcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMudGV4dHVyZXMpXG4gICAgdGhpcy5zaGFkZXJUZXh0dXJlR3JvdXAgPSBudWxsXG4gIH1cblxuICBnZXQgY2FwYWNpdHkgKCkgeyByZXR1cm4gdGhpcy52b1Bvb2wuY2FwYWNpdHkgfVxuXG4gIGdldCB1c2VkQ291bnQgKCkgeyByZXR1cm4gdGhpcy52b1Bvb2wudXNlZENvdW50IH1cbiAgZ2V0IGF2YWlsYWJsZUNvdW50ICgpIHsgcmV0dXJuIHRoaXMudm9Qb29sLmF2YWlsYWJsZUNvdW50IH1cblxuICBzZXRUZXh0dXJlIChzYW1wbGVyLCB0ZXh0dXJlSWQpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlc1tzYW1wbGVyXSAhPT0gdGV4dHVyZUlkKSB7XG4gICAgICB0aGlzLnRleHR1cmVzW3NhbXBsZXJdID0gdGV4dHVyZUlkXG4gICAgICB0aGlzLnNoYWRlclRleHR1cmVHcm91cCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBsb2FkVGV4dHVyZUF0bGFzIChzYW1wbGVyLCB1cmwpIHtcbiAgICB0aGlzLnRleHR1cmVzW3NhbXBsZXJdID0gdXJsXG4gICAgdGhpcy5zaGFkZXJUZXh0dXJlR3JvdXAgPSBudWxsXG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZUxpYnJhcnkubG9hZFRleHR1cmVBdGxhcyh1cmwpXG4gIH1cblxuICBnZXRUZXh0dXJlQXRsYXMgKHNhbXBsZXIpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlTGlicmFyeS5nZXRUZXh0dXJlQXRsYXModGhpcy50ZXh0dXJlc1tzYW1wbGVyXSlcbiAgfVxuXG4gIGNyZWF0ZVNwcml0ZSAodGV4dHVyZSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHZvID0gdGhpcy52b1Bvb2wuYWxsb2MoMSlcbiAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCB3ID0gd2lkdGggfHwgdGV4dHVyZS53aWR0aFxuICAgICAgY29uc3QgaCA9IGhlaWdodCB8fCB0ZXh0dXJlLmhlaWdodFxuICAgICAgdm8uc2V0U2l6ZSh3LCBoKVxuICAgICAgdm8uc2V0VGV4Q29vcmRzQnlUZXh0dXJlKHRleHR1cmUpXG4gICAgfVxuICAgIHJldHVybiB2b1xuICB9XG5cbiAgcmVuZGVyRnJhbWUgKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuc2hhZGVyVGV4dHVyZUdyb3VwID09IG51bGwpIHtcbiAgICAgIHRoaXMuc2hhZGVyVGV4dHVyZUdyb3VwID0gbmV3IFNoYWRlclRleHR1cmVHcm91cCh0aGlzLnRleHR1cmVMaWJyYXJ5LCB0aGlzLnRleHR1cmVzKVxuICAgIH1cbiAgICB0aGlzLnNoYWRlclRleHR1cmVHcm91cC53aGVuTG9hZGVkKHRleFVuaWZvcm1zID0+IHtcbiAgICAgIGNvbnN0IHsgc2hhZGVyQ29udGV4dCB9ID0gcmVuZGVyZXJcblxuICAgICAgc2hhZGVyQ29udGV4dC5wdXNoVmFyKHRleFVuaWZvcm1zKVxuICAgICAgc2hhZGVyQ29udGV4dC5wdXNoVmFyKHRoaXMudm9Qb29sU2hhZGVyQXR0cmlicylcblxuICAgICAgcmVuZGVyZXIudXNlU2hhZGVyUHJvZ3JhbSh0aGlzLnNoYWRlclByb2dyYW0pXG5cbiAgICAgIHJlbmRlcmVyLmRyYXdJbmRleGVkKHRoaXMucHJpbWl0aXZlLCB0aGlzLmluZGljZXMpXG4gICAgfSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc3ByaXRlX2dyb3VwLmpzIiwiaW1wb3J0IFJlc291cmNlUmVmIGZyb20gJy4uL3V0aWxzL3Jlc291cmNlX3JlZidcbmltcG9ydCBXZWJHbEJ1ZmZlciBmcm9tICcuLi9yZW5kZXIvd2ViX2dsX2J1ZmZlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudEluZGV4QXJyYXkge1xuICBjb25zdHJ1Y3RvciAob2JqZWN0Q291bnQsIGl0ZW1Db3VudCA9IDEpIHtcbiAgICB0aGlzLnJlc291cmNlUmVmID0gbmV3IFJlc291cmNlUmVmKHRoaXMsIHtcbiAgICAgIHRhcmdldDogV2ViR2xCdWZmZXIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICB1c2FnZTogJ3N0YXRpYydcbiAgICB9KVxuXG4gICAgdGhpcy5vYmplY3RDb3VudCA9IG9iamVjdENvdW50XG4gICAgdGhpcy5pdGVtQ291bnQgPSBpdGVtQ291bnRcbiAgICB0aGlzLmxlbmd0aCA9IG9iamVjdENvdW50ICogaXRlbUNvdW50XG5cbiAgICB0aGlzLmFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMubGVuZ3RoKVxuXG4gICAgLy8gbmVlZGVkIGJ5IFdlYkdsUmVuZGVyZXIjc3luY0J1ZmZlclxuICAgIHRoaXMucmVzb3VyY2VSZWYuaGludHMudHlwZWRBcnJheSA9IHRoaXMuYXJyYXlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0Q291bnRcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kaWNlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0cmlkZT00XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29iamVjdE9mZnNldD0wXVxuICAgKiBAcmV0dXJuIHtFbGVtZW50SW5kZXhBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgRWxlbWVudEluZGV4QXJyYXkgZm9yIDEwIHF1YWRzIHdoZXJlIGVhY2ggcXVhZCBtYWRlIHVwIG9mIDJ4IHRyaWFuZ2xlcyAoNHggdmVydGljZXMgYW5kIDZ4IGluZGljZXMpXG4gICAqIGNvbnN0IHF1YWRJbmRpY2VzID0gRWxlbWVudEluZGV4QXJyYXkuR2VuZXJhdGUoMTAsIFswLCAxLCAyLCAwLCAyLCAzXSwgNClcbiAgICogcXVhZEluZGljZXMubGVuZ3RoICAgICAgICAvLyA9PiA2MFxuICAgKiBxdWFkSW5kaWNlcy5pdGVtQ291bnQgICAgIC8vID0+IDZcbiAgICovXG4gIHN0YXRpYyBHZW5lcmF0ZSAob2JqZWN0Q291bnQsIGluZGljZXMsIHN0cmlkZSA9IDQsIG9iamVjdE9mZnNldCA9IDApIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgRWxlbWVudEluZGV4QXJyYXkob2JqZWN0Q291bnQsIGluZGljZXMubGVuZ3RoKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RDb3VudDsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGljZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgYXJyLmFycmF5WyhpICogYXJyLml0ZW1Db3VudCkgKyBqXSA9IGluZGljZXNbal0gKyAoKGkgKyBvYmplY3RPZmZzZXQpICogc3RyaWRlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvZWxlbWVudF9pbmRleF9hcnJheS5qcyIsImltcG9ydCBnZW5lcmF0ZVVVSUQgZnJvbSAnLi4vdXRpbHMvZ2VuZXJhdGVfdXVpZCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1NoYWRlclNvdXJjZX0gdmVydGV4U2hhZGVyXG4gICAqIEBwYXJhbSB7U2hhZGVyU291cmNlfSBmcmFnbWVudFNoYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBnZW5lcmF0ZVVVSUQoKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NoYWRlclNvdXJjZX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlclxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NoYWRlclNvdXJjZX1cbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXJcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc2hhZGVyX3Byb2dyYW0uanMiLCJpbXBvcnQgU2hhZGVyVmFyaWFibGVHcm91cCBmcm9tICcuL3NoYWRlcl92YXJpYWJsZV9ncm91cCdcbmltcG9ydCBTaGFkZXJUZXh0dXJlMmRWYXJpYWJsZSBmcm9tICcuL3NoYWRlcl90ZXh0dXJlXzJkX3ZhcmlhYmxlJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJUZXh0dXJlR3JvdXAge1xuICBjb25zdHJ1Y3RvciAoc2hhZGVyTGlicmFyeSwgc2hhZGVyVGV4dHVyZU1hcCkge1xuICAgIHRoaXMuc2hhZGVyTGlicmFyeSA9IHNoYWRlckxpYnJhcnlcbiAgICB0aGlzLndhaXRGb3IgPSBPYmplY3Qua2V5cyhzaGFkZXJUZXh0dXJlTWFwKS5tYXAoc2hhZGVyVmFyS2V5ID0+ICh7XG4gICAgICBzaGFkZXJWYXJLZXksXG4gICAgICB0ZXh0dXJlSWQ6IHNoYWRlclRleHR1cmVNYXBbc2hhZGVyVmFyS2V5XSxcbiAgICAgIGlzTG9hZGVkOiBmYWxzZVxuICAgIH0pKVxuICAgIHRoaXMuc2hhZGVyVmFyR3JvdXAgPSBuZXcgU2hhZGVyVmFyaWFibGVHcm91cChbXSlcbiAgICB0aGlzLnNoYWRlclZhclN0b3JlID0gbmV3IE1hcCgpXG4gIH1cblxuICBnZXQgaXNMb2FkZWQgKCkge1xuICAgIHJldHVybiB0aGlzLndhaXRGb3IubGVuZ3RoID09PSAwICYmIHRoaXMuc2hhZGVyVmFyR3JvdXAuc2hhZGVyVmFycy5sZW5ndGggPiAwXG4gIH1cblxuICB3aGVuTG9hZGVkIChvbkxvYWRlZCkge1xuICAgIGlmICghdGhpcy5pc0xvYWRlZCkge1xuICAgICAgdGhpcy53YWl0Rm9yLmZvckVhY2god2FpdEZvciA9PiB7XG4gICAgICAgIGlmICghd2FpdEZvci5pc0xvYWRlZCkge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zaGFkZXJMaWJyYXJ5LnN0YXRlcy5nZXQod2FpdEZvci50ZXh0dXJlSWQpXG4gICAgICAgICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQgfHwgIXN0YXRlLmlzUmVhZHkpIHJldHVyblxuXG4gICAgICAgICAgY29uc3Qgc2hhZGVyVmFyID0gbmV3IFNoYWRlclRleHR1cmUyZFZhcmlhYmxlKHdhaXRGb3Iuc2hhZGVyVmFyS2V5KVxuICAgICAgICAgIHNoYWRlclZhci50ZXh0dXJlID0gc3RhdGUudGV4dHVyZVxuICAgICAgICAgIHRoaXMuc2hhZGVyVmFyR3JvdXAuc2hhZGVyVmFycy5wdXNoKHNoYWRlclZhcilcblxuICAgICAgICAgIHdhaXRGb3IuaXNMb2FkZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLndhaXRGb3IgPSB0aGlzLndhaXRGb3IuZmlsdGVyKHdhaXRGb3IgPT4gd2FpdEZvci5pc0xvYWRlZCA9PT0gZmFsc2UpXG4gICAgICBpZiAodGhpcy5pc0xvYWRlZCkge1xuICAgICAgICBvbkxvYWRlZCh0aGlzLnNoYWRlclZhckdyb3VwKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbkxvYWRlZCh0aGlzLnNoYWRlclZhckdyb3VwKVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc2hhZGVyX3RleHR1cmVfZ3JvdXAuanMiLCJpbXBvcnQgU2hhZGVyVmFyaWFibGVHcm91cCBmcm9tICcuL3NoYWRlcl92YXJpYWJsZV9ncm91cCdcbmltcG9ydCBTaGFkZXJBdHRyaWJWYXJpYWJsZSBmcm9tICcuL3NoYWRlcl9hdHRyaWJfdmFyaWFibGUnXG5pbXBvcnQgU2hhZGVyQXR0cmliVmFsdWUgZnJvbSAnLi9zaGFkZXJfYXR0cmliX3ZhbHVlJ1xuaW1wb3J0IFNoYWRlclZhcmlhYmxlQWxpYXMgZnJvbSAnLi9zaGFkZXJfdmFyaWFibGVfYWxpYXMnXG5cbi8qKlxuICogR3JvdXAgb2Ygc2hhZGVyIHZhcmlhYmxlcyB3aGljaCBhcmUgcmVmZXJlbmNpbmcgb25lIHNpbmdsZSBidWZmZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclZhcmlhYmxlQnVmZmVyR3JvdXAgZXh0ZW5kcyBTaGFkZXJWYXJpYWJsZUdyb3VwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Vk9Qb29sfSBidWZmZXJTb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yIChidWZmZXJTb3VyY2UpIHtcbiAgICBzdXBlcihbXSlcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gYnVmZmVyU291cmNlLmRlc2NyaXB0b3JcbiAgICBsZXQgZmlyc3RWYXJcbiAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yLmF0dHIpLmZvckVhY2goYXR0ck5hbWUgPT4ge1xuICAgICAgaWYgKCFmaXJzdFZhcikge1xuICAgICAgICBmaXJzdFZhciA9IG5ldyBTaGFkZXJBdHRyaWJWYXJpYWJsZShcbiAgICAgICAgICBhdHRyTmFtZSxcbiAgICAgICAgICBuZXcgU2hhZGVyQXR0cmliVmFsdWUoXG4gICAgICAgICAgICBhdHRyTmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICBidWZmZXJTb3VyY2VcbiAgICAgICAgICApKVxuICAgICAgICB0aGlzLnNoYWRlclZhcnMucHVzaChmaXJzdFZhcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hhZGVyVmFycy5wdXNoKG5ldyBTaGFkZXJWYXJpYWJsZUFsaWFzKGF0dHJOYW1lLCBmaXJzdFZhcikpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldCBidWZmZXJTb3VyY2UgKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlclZhcnNbMF0udmFsdWUuYnVmZmVyU291cmNlXG4gIH1cblxuICBnZXQgc2VyaWFsICgpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXJWYXJzWzBdLnNlcmlhbFxuICB9XG5cbiAgdG91Y2ggKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlclZhcnNbMF0udG91Y2goKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS9zaGFkZXJfdmFyaWFibGVfYnVmZmVyX2dyb3VwLmpzIiwiaW1wb3J0IFNoYWRlclZhcmlhYmxlIGZyb20gJy4vc2hhZGVyX3ZhcmlhYmxlJ1xuXG4vKipcbiAqIFNoYWRlciBhdHRyaWJ1dGUgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlckF0dHJpYlZhcmlhYmxlIGV4dGVuZHMgU2hhZGVyVmFyaWFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHZhbHVlKSB7XG4gICAgc3VwZXIobmFtZSwgU2hhZGVyVmFyaWFibGUuVFlQRS5BVFRSSUIsIHZhbHVlKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS9zaGFkZXJfYXR0cmliX3ZhcmlhYmxlLmpzIiwiaW1wb3J0IFZPQXJyYXkgZnJvbSAnLi92X29fYXJyYXknXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlckF0dHJpYlZhbHVlIHtcbiAgY29uc3RydWN0b3IgKG5hbWUsIGRlc2NyaXB0b3IsIGJ1ZmZlclNvdXJjZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yXG4gICAgdGhpcy5idWZmZXJTb3VyY2UgPSBidWZmZXJTb3VyY2VcbiAgfVxuXG4gIGdldCBhdHRyRGVzY3JpcHRvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRvci5hdHRyW3RoaXMubmFtZV1cbiAgfVxuXG4gIGdldCByZXNvdXJjZVJlZiAoKSB7XG4gICAgY29uc3QgeyBidWZmZXJTb3VyY2UgfSA9IHRoaXNcbiAgICByZXR1cm4gKGJ1ZmZlclNvdXJjZSBpbnN0YW5jZW9mIFZPQXJyYXlcbiAgICAgID8gYnVmZmVyU291cmNlLnJlc291cmNlUmVmXG4gICAgICA6IGJ1ZmZlclNvdXJjZS52b0FycmF5LnJlc291cmNlUmVmKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS9zaGFkZXJfYXR0cmliX3ZhbHVlLmpzIiwiLyoqXG4gKiBTaGFkZXIgYXR0cmlidXRlIHZhcmlhYmxlICphbGlhcyouXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclZhcmlhYmxlQWxpYXMge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIHNoYWRlclZhcikge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnNoYWRlclZhciA9IHNoYWRlclZhclxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlclZhci50eXBlXG4gIH1cblxuICBnZXQgdmFsdWUgKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlclZhci52YWx1ZVxuICB9XG5cbiAgZ2V0IHNlcmlhbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyVmFyLnNlcmlhbFxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS9zaGFkZXJfdmFyaWFibGVfYWxpYXMuanMiLCJpbXBvcnQgY3JlYXRlVmVydGV4T2JqZWN0cyBmcm9tICcuL2NyZWF0ZV92ZXJ0ZXhfb2JqZWN0cydcbmltcG9ydCBnZW5lcmF0ZVVVSUQgZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhdGVfdXVpZCdcbmltcG9ydCBWT0FycmF5IGZyb20gJy4uL3Zfb19hcnJheSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVk9Qb29sIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Vk9EZXNjcmlwdG9yfSBkZXNjcmlwdG9yIC0gdmVydGV4IG9iamVjdCBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZHZhbmNlZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jYXBhY2l0eV0gLSBNYXhpbXVtIG51bWJlciBvZiAqdmVydGV4IG9iamVjdHMqXG4gICAqIEBwYXJhbSB7Vk9BcnJheX0gW29wdGlvbnMudm9BcnJheV0gLSBWZXJ0ZXggb2JqZWN0IGFycmF5XG4gICAqIEBwYXJhbSB7VmVydGV4T2JqZWN0fSBbb3B0aW9ucy52b1plcm9dIC0gKnZlcnRleCBvYmplY3QqICoqcHJvdG90eXBlKipcbiAgICogQHBhcmFtIHtWZXJ0ZXhPYmplY3R9IFtvcHRpb25zLnZvTmV3XSAtICp2ZXJ0ZXggb2JqZWN0KiAqKnByb3RvdHlwZSoqXG4gICAqIEBwYXJhbSB7VmVydGV4T2JqZWN0fSBbb3B0aW9ucy5tYXhBbGxvY1ZPU2l6ZV0gLSBuZXZlciBhbGxvY2F0ZSBtb3JlIHRoYW4gKm1heEFsbG9jVk9TaXplKiB2ZXJ0ZXggb2JqZWN0cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51c2FnZT1WT1Bvb2wuVVNBR0UuRFlOQU1JQ10gLSB2ZXJ0ZXggZGF0YSB1c2FnZSBoaW50XG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yIChkZXNjcmlwdG9yLCBvcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlVVVJRCgpXG5cbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yXG4gICAgdGhpcy5jYXBhY2l0eSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FwYWNpdHkpIHx8IHRoaXMuZGVzY3JpcHRvci5tYXhJbmRleGVkVk9Qb29sU2l6ZVxuICAgIHRoaXMubWF4QWxsb2NWT1NpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLm1heEFsbG9jVk9TaXplKSB8fCAwXG5cbiAgICB0aGlzLnVzYWdlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy51c2FnZSkgfHwgVk9Qb29sLlVTQUdFLkRZTkFNSUNcblxuICAgIGxldCB2b0FycmF5ID0gb3B0aW9ucyAmJiBvcHRpb25zLnZvQXJyYXlcbiAgICBpZiAodm9BcnJheSkge1xuICAgICAgaWYgKHZvQXJyYXkudXNhZ2UgIT09IHRoaXMudXNhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWT1Bvb2wgdXNhZ2UoPSR7dGhpcy51c2FnZX0pIG1pc21hdGNoIHdpdGggZ2l2ZW4gdm9BcnJheSh1c2FnZT0ke3ZvQXJyYXkudXNhZ2V9KWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvQXJyYXkgPSBkZXNjcmlwdG9yLmNyZWF0ZVZPQXJyYXkodGhpcy5jYXBhY2l0eSwgdGhpcy51c2FnZSlcbiAgICB9XG4gICAgdGhpcy52b0FycmF5ID0gdm9BcnJheVxuXG4gICAgdGhpcy52b1plcm8gPSAob3B0aW9ucyAmJiBvcHRpb25zLnZvWmVybykgfHwgZGVzY3JpcHRvci5jcmVhdGVWTygpXG4gICAgdGhpcy52b05ldyA9IChvcHRpb25zICYmIG9wdGlvbnMudm9OZXcpIHx8IGRlc2NyaXB0b3IuY3JlYXRlVk8oKVxuXG4gICAgdGhpcy5hdmFpbGFibGVWT3MgPSBbXVxuICAgIHRoaXMudXNlZFZPcyA9IFtdXG5cbiAgICBjcmVhdGVWZXJ0ZXhPYmplY3RzKHRoaXMsIHRoaXMubWF4QWxsb2NWT1NpemUpXG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGluIHVzZSAqdmVydGV4IG9iamVjdHMqLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICBnZXQgdXNlZENvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VkVk9zLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBmcmVlIGFuZCB1bnVzZWQgKnZlcnRleCBvYmplY3RzKi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgZ2V0IGF2YWlsYWJsZUNvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhY2l0eSAtIHRoaXMudXNlZFZPcy5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgKiphbGxvY2F0ZWQqKiAqdmVydGV4IG9iamVjdHMqLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICBnZXQgYWxsb2NhdGVkQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZVZPcy5sZW5ndGggKyB0aGlzLnVzZWRWT3MubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuICoqc2l6ZSoqICp2ZXJ0ZXggb2JqZWN0cypcbiAgICogQHJldHVybiB7VmVydGV4T2JqZWN0fFZlcnRleE9iamVjdFtdfVxuICAgKi9cblxuICBhbGxvYyAoc2l6ZSA9IDEpIHtcbiAgICBpZiAoc2l6ZSA+IDEpIHtcbiAgICAgIGNvbnN0IGFyciA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICBjb25zdCB2byA9IHRoaXMuYWxsb2MoMSlcbiAgICAgICAgaWYgKHZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhcnIucHVzaCh2bylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgY29uc3Qgdm8gPSB0aGlzLmF2YWlsYWJsZVZPcy5zaGlmdCgpXG5cbiAgICBpZiAodm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCh0aGlzLmNhcGFjaXR5IC0gdGhpcy5hbGxvY2F0ZWRDb3VudCkgPiAwKSB7XG4gICAgICAgIGNyZWF0ZVZlcnRleE9iamVjdHModGhpcywgdGhpcy5tYXhBbGxvY1ZPU2l6ZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb2MoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51c2VkVk9zLnB1c2godm8pXG5cbiAgICB2by52b0FycmF5LmNvcHkodGhpcy52b05ldy52b0FycmF5KVxuXG4gICAgcmV0dXJuIHZvXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtWZXJ0ZXhPYmplY3R8VmVydGV4T2JqZWN0W119IHZvIC0gdmVydGV4IG9iamVjdChzKVxuICAgKi9cblxuICBmcmVlICh2bykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZvKSkge1xuICAgICAgdm8uZm9yRWFjaChfdm8gPT4gX3ZvLmZyZWUoKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlkeCA9IHRoaXMudXNlZFZPcy5pbmRleE9mKHZvKVxuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHJldHVyblxuXG4gICAgY29uc3QgbGFzdElkeCA9IHRoaXMudXNlZFZPcy5sZW5ndGggLSAxXG5cbiAgICBpZiAoaWR4ICE9PSBsYXN0SWR4KSB7XG4gICAgICBjb25zdCBsYXN0ID0gdGhpcy51c2VkVk9zWyBsYXN0SWR4IF1cbiAgICAgIHZvLnZvQXJyYXkuY29weShsYXN0LnZvQXJyYXkpXG5cbiAgICAgIGNvbnN0IHRtcCA9IGxhc3Qudm9BcnJheVxuICAgICAgbGFzdC52b0FycmF5ID0gdm8udm9BcnJheVxuICAgICAgdm8udm9BcnJheSA9IHRtcFxuXG4gICAgICB0aGlzLnVzZWRWT3Muc3BsaWNlKGlkeCwgMSwgbGFzdClcbiAgICB9XG5cbiAgICB0aGlzLnVzZWRWT3MucG9wKClcbiAgICB0aGlzLmF2YWlsYWJsZVZPcy51bnNoaWZ0KHZvKVxuXG4gICAgdm8udm9BcnJheS5jb3B5KHRoaXMudm9aZXJvLnZvQXJyYXkpXG4gIH1cbn1cblxuVk9Qb29sLlVTQUdFID0gVk9BcnJheS5VU0FHRVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvdl9vX3Bvb2wvaW5kZXguanMiLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFJlcHJlc2VudHMgYSAyZCBheGlzIGFsaWduZWQgYm91bmRhcnkgYm94LlxuICpcbiAqIEBjbGFzcyBBQUJCMlxuICogQHBhcmFtIHtudW1iZXJ9IFt4MD0wXSAtIHgwXG4gKiBAcGFyYW0ge251bWJlcn0gW3gxPTBdIC0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeTA9MF0gLSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IFt5MT0wXSAtIHkxXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUFCQjIge1xuICBjb25zdHJ1Y3RvciAoeDAgPSAwLCB4MSA9IDAsIHkwID0gMCwgeTEgPSAwKSB7XG4gICAgaWYgKHgwIDwgeDEpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5taW5YID0geDBcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXhYID0geDFcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLm1pblggPSB4MVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLm1heFggPSB4MFxuICAgIH1cblxuICAgIGlmICh5MCA8IHkxKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMubWluWSA9IHkwXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMubWF4WSA9IHkxXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5taW5ZID0geTFcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXhZID0geTBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWCArIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WSAtIHRoaXMubWluWSArIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNlbnRlclggKCkge1xuICAgIHJldHVybiAodGhpcy5tYXhYIC0gdGhpcy5taW5YKSAvIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNlbnRlclkgKCkge1xuICAgIHJldHVybiAodGhpcy5tYXhZIC0gdGhpcy5taW5ZKSAvIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIGJvdW5kYXJ5IGJveC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geVxuICAgKi9cbiAgYWRkUG9pbnQgKHgsIHkpIHtcbiAgICBpZiAoeCA8IHRoaXMubWluWCkge1xuICAgICAgdGhpcy5taW5YID0geFxuICAgIH0gZWxzZSBpZiAoeCA+IHRoaXMubWF4WCkge1xuICAgICAgdGhpcy5tYXhYID0geFxuICAgIH1cblxuICAgIGlmICh5IDwgdGhpcy5taW5ZKSB7XG4gICAgICB0aGlzLm1pblkgPSB5XG4gICAgfSBlbHNlIGlmICh5ID4gdGhpcy5tYXhZKSB7XG4gICAgICB0aGlzLm1heFkgPSB5XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluYXRlcyB3ZXRoZXIgb3IgdGhlIDJkIHBvaW50IGlzIGluc2lkZSB0aGlzIEFBQkIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGFhYmJcbiAgICovXG4gIGlzSW5zaWRlICh4LCB5KSB7XG4gICAgcmV0dXJuIHggPj0gdGhpcy5taW5YICYmIHggPD0gdGhpcy5tYXhYICYmIHkgPj0gdGhpcy5taW5ZICYmIHkgPD0gdGhpcy5tYXhZXG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5hdGVzIHdldGhlciBvciBub3QgdGhpcyBBQUJCIGludGVyc2VjdHMgKmFhYmIqLlxuICAgKlxuICAgKiBAcGFyYW0ge0FBQkIyfSBhYWJiIC0gYWFiYlxuICAgKiBAcmV0dXJuIHtib29sZWFufSByZXR1cm4gdHJ1ZSB3aGVuIHRoZXJlIGlzIHNvbWUgaW50ZXJzZWN0aW9uIGJldHdlZW4gYm90aFxuICAgKi9cbiAgaXNJbnRlcnNlY3Rpb24gKGFhYmIpIHtcbiAgICByZXR1cm4gIShcbiAgICAgIGFhYmIubWF4WCA8IHRoaXMubWluWCB8fFxuICAgICAgYWFiYi5taW5YID4gdGhpcy5tYXhYIHx8XG4gICAgICBhYWJiLm1heFkgPCB0aGlzLm1pblkgfHxcbiAgICAgIGFhYmIubWluWSA+IHRoaXMubWF4WVxuICAgIClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvYWFiYjIuanMiLCJpbXBvcnQgQ2FudmFzRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL0NhbnZhc0VsZW1lbnQuanMnXG5pbXBvcnQgU2NlbmVFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvU2NlbmVFbGVtZW50LmpzJ1xuaW1wb3J0IFRleHR1cmVBdGxhc0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9UZXh0dXJlQXRsYXNFbGVtZW50LmpzJ1xuaW1wb3J0IFNwcml0ZUdyb3VwRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL1Nwcml0ZUdyb3VwRWxlbWVudC5qcydcblxuaW1wb3J0IHtcbiAgRE9NX0VMRU1fQ0FOVkFTLFxuICBET01fRUxFTV9TQ0VORSxcbiAgRE9NX0VMRU1fVEVYVFVSRV9BVExBUyxcbiAgRE9NX0VMRU1fU1BSSVRFX0dST1VQXG59IGZyb20gJy4vY29uc3RhbnRzJ1xuXG5pbXBvcnQgJy4vYmxpdHB1bmsuc2NzcydcblxuLyoqXG4gKiBEZWZpbmUgYWxsIGA8YmxpdHB1bmstKj5gIGN1c3RvbSBodG1sIGVsZW1lbnRzLlxuICogU2hvdWxkIGJlIGNhbGxlZCBvbmNlIGF0IHN0YXJ0dXAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnRzICgpIHtcbiAgLy8gZGVmaW5lIGVsZW1lbnQgaW4gdGhlIEN1c3RvbUVsZW1lbnRSZWdpc3RyeVxuICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKERPTV9FTEVNX0NBTlZBUywgQ2FudmFzRWxlbWVudClcbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZShET01fRUxFTV9TQ0VORSwgU2NlbmVFbGVtZW50KVxuICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKERPTV9FTEVNX1RFWFRVUkVfQVRMQVMsIFRleHR1cmVBdGxhc0VsZW1lbnQpXG4gIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoRE9NX0VMRU1fU1BSSVRFX0dST1VQLCBTcHJpdGVHcm91cEVsZW1lbnQpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZG9tL2RlZmluZUN1c3RvbUVsZW1lbnRzLmpzIiwiLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG5pbXBvcnQgQXBwIGZyb20gJy4uLy4uL2FwcC5qcydcbmltcG9ydCBCbGl0cHVuayBmcm9tICcuLi8uLi9ibGl0cHVuay5qcydcblxuaW1wb3J0IHJlYWRCb29sZWFuQXR0cmlidXRlIGZyb20gJy4uL2xpYi9yZWFkQm9vbGVhbkF0dHJpYnV0ZS5qcydcblxuaW1wb3J0IHtcbiAgTk9ERV9OQU1FX0NBTlZBUyxcbiAgQVRUUl9BTFBIQSxcbiAgQVRUUl9BTlRJQUxJQVMsXG4gIEFUVFJfQkxFTkRfTU9ERSxcbiAgQVRUUl9DTEVBUl9DT0xPUixcbiAgQVRUUl9ERVBUSCxcbiAgQVRUUl9QUkVNVUxUSVBMSUVEX0FMUEhBLFxuICBBVFRSX1BSRVNFUlZFX0RSQVcsXG4gIEFUVFJfUFJPSkVDVElPTixcbiAgQVRUUl9TVEVOQ0lMXG59IGZyb20gJy4uL2NvbnN0YW50cydcblxuY29uc3QgZXZlbnRpemUgPSByZXF1aXJlKCdAc3BlYXJ3b2xmL2V2ZW50aXplJylcblxuY29uc3QgY3JlYXRlQ29udGV4dEF0dHJpYnV0ZXMgPSAoZWwpID0+ICh7XG4gIGFscGhhOiByZWFkQm9vbGVhbkF0dHJpYnV0ZShlbCwgQVRUUl9BTFBIQSwgZmFsc2UpLFxuICBkZXB0aDogcmVhZEJvb2xlYW5BdHRyaWJ1dGUoZWwsIEFUVFJfREVQVEgsIHRydWUpLCAgLy8gaWUgMTEgaGFzIG5vIHN1cHBvcnQgZm9yIGZhbHNlXG4gIHN0ZW5jaWw6IHJlYWRCb29sZWFuQXR0cmlidXRlKGVsLCBBVFRSX1NURU5DSUwsIGZhbHNlKSxcbiAgYW50aWFsaWFzOiByZWFkQm9vbGVhbkF0dHJpYnV0ZShlbCwgQVRUUl9BTlRJQUxJQVMsIGZhbHNlKSxcbiAgcHJlbXVsdGlwbGllZEFscGhhOiByZWFkQm9vbGVhbkF0dHJpYnV0ZShlbCwgQVRUUl9QUkVNVUxUSVBMSUVEX0FMUEhBLCBmYWxzZSksXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogcmVhZEJvb2xlYW5BdHRyaWJ1dGUoZWwsIEFUVFJfUFJFU0VSVkVfRFJBVywgZmFsc2UpXG59KVxuXG4vKipcbiAqIFRoZSAqKmN1c3RvbSBIVE1MIGA8YmxpdHB1bmstY2FudmFzPjwvYmxpdHB1bmstY2FudmFzPmAgZWxlbWVudCoqIHJlcHJlc2VudHMgdGhlICp3ZWJnbCogY2FudmFzLFxuICogd2hpY2ggYWN0cyBhbHNvIGFzIHRoZSBtYWluIEFQSSBlbnRyeXBvaW50IGZvciBldmVyeSAqYmxpdHB1bmsqIGFwcGxpY2F0aW9uLlxuICpcbiAqIFRoZSBzaXplIG9mIHRoZSBodG1sIGVsZW1lbnQgc2hvdWxkIGJlIGRlZmluZWQgYnkgY3NzIHN0eWxlcyAoZWcuIGBkaXNwbGF5OiBibG9jazsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJWApICZtZGFzaDsgd2l0aG91dFxuICogYW55IHN0eWxlcyAob3IgYGRpc3BsYXk6IGlubGluZWApIHRoZSBjYW52YXMgd2lsbCBtaW1pYyB0aGUgc2l6ZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gKlxuICogWW91IGNhbiBjdXN0b21pemUgdGhlIHdlZ2wgY29udGV4dCBieSBzcGVjaWZ5aW5nIGh0bWwgYXR0cmlidXRlczpcbiAqIC0gYGFscGhhYFxuICogLSBgZGVwdGhgXG4gKiAtIGBzdGVuY2lsYFxuICogLSBgYW50aWFsaWFzYFxuICogLSBgcHJlbXVsdGlwbGllZC1hbHBoYWBcbiAqIC0gYHByZXNlcnZlLWRyYXdpbmctYnVmZmVyYFxuICpcbiAqIF9BVFRFTlRJT046XyBjaGFuZ2luZyB0aGVzZSBodG1sIGF0dHJpYnV0ZXMgaGFzIG5vIGVmZmVjdCAqYWZ0ZXIqIHRoZSB3ZWJnbCBjb250ZXh0IGlzIGluaXRpYWxpemVkIVxuICpcbiAqIEBleGFtcGxlXG4gKiA8IURPQ1RZUEUgaHRtbD5cbiAqIDxodG1sPlxuICogPGhlYWQ+XG4gKiAgIDx0aXRsZT5mdWxsc2NyZWVuIGJsaXRwdW5rIGNhbnZhcyBleGFtcGxlPC90aXRsZT5cbiAqICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEuMFwiPlxuICogICA8c3R5bGU+XG4gKiAgICAgaHRtbCwgYm9keSB7XG4gKiAgICAgICBtYXJnaW46IDA7XG4gKiAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICogICAgICAgd2lkdGg6IDEwMCU7XG4gKiAgICAgICBoZWlnaHQ6IDEwMCU7XG4gKiAgICAgfVxuICogICA8L3N0eWxlPlxuICogPC9oZWFkPlxuICogPGJvZHk+XG4gKiAgIDxibGl0cHVuay1jYW52YXMgYWxwaGEgYW50aWFsaWFzPlxuICogICAgIC4uLlxuICogICA8L2JsaXRwdW5rLWNhbnZhcz5cbiAqICAgLi4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yIChfKSB7XG4gICAgY29uc3Qgc2VsZiA9IHN1cGVyKF8pXG4gICAgZXZlbnRpemUoc2VsZilcbiAgICBzZWxmLmJsaXRwdW5rID0gbmV3IEFwcCgpXG4gICAgc2VsZi5ibGl0cHVuay5lbnRpdHkub24oc2VsZilcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgZ2V0IGJsaXRwdW5rQXBpICgpIHsgcmV0dXJuIEJsaXRwdW5rIH1cbiAgZ2V0IGJsaXRwdW5rTm9kZU5hbWUgKCkgeyByZXR1cm4gTk9ERV9OQU1FX0NBTlZBUyB9XG5cbiAgZ2V0IGNhbnZhcyAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLmNhbnZhcyB9XG4gIGdldCB3aWR0aCAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLndpZHRoIH1cbiAgZ2V0IGhlaWdodCAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLmhlaWdodCB9XG5cbiAgZ2V0IGdseCAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLmdseCB9XG4gIGdldCByZW5kZXJlciAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLnJlbmRlcmVyIH1cbiAgZ2V0IHRpbWUgKCkgeyByZXR1cm4gdGhpcy5ibGl0cHVuay50aW1lIH1cbiAgZ2V0IHN0YXJ0VGltZSAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLnN0YXJ0VGltZSB9XG4gIGdldCBmcmFtZU5vICgpIHsgcmV0dXJuIHRoaXMuYmxpdHB1bmsuZnJhbWVObyB9XG5cbiAgZ2V0IGNvbXBvbmVudFJlZ2lzdHJ5ICgpIHsgcmV0dXJuIHRoaXMuYmxpdHB1bmsuY29tcG9uZW50UmVnaXN0cnkgfVxuICBnZXQgZW50aXR5TWFuYWdlciAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLmVudGl0eU1hbmFnZXIgfVxuICBnZXQgcmVzb3VyY2VMaWJyYXJ5ICgpIHsgcmV0dXJuIHRoaXMuYmxpdHB1bmsucmVzb3VyY2VMaWJyYXJ5IH1cbiAgZ2V0IHRleHR1cmVMaWJyYXJ5ICgpIHsgcmV0dXJuIHRoaXMuYmxpdHB1bmsudGV4dHVyZUxpYnJhcnkgfVxuXG4gIGdldCBzY2VuZSAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rLmVudGl0eSB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgQVRUUl9CTEVORF9NT0RFLFxuICAgICAgQVRUUl9DTEVBUl9DT0xPUixcbiAgICAgIEFUVFJfUFJPSkVDVElPTlxuICAgIF1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvbktleWRvd24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5ID09PSAnZCcpIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXAoJzxibGl0cHVuay8+JywgJ2ZyYW1lTm8nLCB0aGlzLmZyYW1lTm8pXG4gICAgICBjb25zb2xlLmxvZyh0aGlzKVxuICAgICAgY29uc29sZS5sb2codGhpcy5ibGl0cHVuaylcbiAgICAgIHRoaXMuYmxpdHB1bmsuZW50aXR5LmVtaXQoJ2RlYnVnJywgdGhpcylcbiAgICAgIHRoaXMucmVuZGVyZXIuZW1pdCgnZGVidWcnLCB0aGlzLnJlbmRlcmVyKVxuICAgICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgfVxuICB9XG5cbiAgc2V0IGNsZWFyQ29sb3IgKGNvbG9yKSB7XG4gICAgdGhpcy5ibGl0cHVuay5jbGVhckNvbG9yID0gY29sb3JcbiAgfVxuXG4gIGdldCBjbGVhckNvbG9yICgpIHtcbiAgICBjb25zdCBjb2wgPSB0aGlzLmJsaXRwdW5rLmNsZWFyQ29sb3JcbiAgICBpZiAoY29sKSB7XG4gICAgICByZXR1cm4gY29sLmdldEFscGhhKCkgPT09IDEgPyBjb2wudG9IZXhTdHJpbmcoKSA6IGNvbC50b1JnYlN0cmluZygpXG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGNvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgICB0aGlzLmJsaXRwdW5rLmNvbnRleHRBdHRyaWJ1dGVzID0gT2JqZWN0LmZyZWV6ZShjcmVhdGVDb250ZXh0QXR0cmlidXRlcyh0aGlzKSlcblxuICAgIHRoaXMub25LZXlkb3duID0gdGhpcy5vbktleWRvd24uYmluZCh0aGlzKVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlkb3duKVxuXG4gICAgdGhpcy5ibGl0cHVuay5zdGFydCh0aGlzKVxuXG4gICAgLy8gVE9ETyBjaGVjayBmb3Igb25Jbml0PSBhdHRyaWJ1dGU/XG4gICAgLy8gY29uc3Qgc3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoQVRUUl9NT0RVTEVfU1JDKVxuICAgIC8vIGlmIChzcmMpIHtcbiAgICAgIC8vIFN5c3RlbUpTLmltcG9ydChzcmMpLnRoZW4oKGFwcE1vZHVsZSkgPT4ge1xuICAgICAgICAvLyBhcHBNb2R1bGUuZGVmYXVsdCh0aGlzLCBCbGl0cHVuaylcbiAgICAgICAgLy8gVE9ETyBjb25maWd1cmUgYmxpdHB1bmsgZHluYW1pYyBwYWNrYWdlXG4gICAgICAgIC8vIFRPRE8gY2hlY2sgZm9yIC5pbml0KCkgbWV0aG9kP1xuICAgICAgLy8gfSlcbiAgICAvLyB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgIHRoaXMuYmxpdHB1bmsuZGVzdHJveSgpXG5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bilcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgKGF0dHIsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgY2FzZSBBVFRSX0NMRUFSX0NPTE9SOlxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBuZXdWYWx1ZVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBVFRSX0JMRU5EX01PREU6XG4gICAgICBjYXNlIEFUVFJfUFJPSkVDVElPTjpcbiAgICAgICAgdGhpcy5ibGl0cHVuay5jb21wb25lbnRSZWdpc3RyeS5jcmVhdGVPclVwZGF0ZUNvbXBvbmVudCh0aGlzLmJsaXRwdW5rLmVudGl0eSwgYXR0ciwgbmV3VmFsdWUpXG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZG9tL2VsZW1lbnRzL0NhbnZhc0VsZW1lbnQuanMiLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxudmFyIHJuZztcblxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvOyAvLyBmb3IgSUUgMTFcbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIHJuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59XG5cbmlmICghcm5nKSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICBybmcgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBybmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIHJldHVybiBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTyAob2JqLCBkZXNjcmlwdG9yLCB2b0FycmF5KSB7XG4gIC8vIHNldCBWT0Rlc2NyaXB0b3JcbiAgLy9cbiAgb2JqLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yIHx8ICh2b0FycmF5ID8gdm9BcnJheS5kZXNjcmlwdG9yIDogbnVsbClcblxuICBpZiAoIW9iai5kZXNjcmlwdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZGV0ZWN0IFZPRGVzY3JpcHRvciEnKVxuICB9XG5cbiAgLy8gc2V0IFZPQXJyYXlcbiAgLy9cbiAgb2JqLnZvQXJyYXkgPSB2b0FycmF5IHx8IG9iai5kZXNjcmlwdG9yLmNyZWF0ZVZPQXJyYXkoKVxuXG4gIGlmIChvYmouZGVzY3JpcHRvciAhPT0gb2JqLnZvQXJyYXkuZGVzY3JpcHRvciAmJlxuICAgIChvYmouZGVzY3JpcHRvci52ZXJ0ZXhDb3VudCAhPT0gb2JqLnZvQXJyYXkuZGVzY3JpcHRvci52ZXJ0ZXhDb3VudCB8fFxuICAgICAgb2JqLmRlc2NyaXB0b3IudmVydGV4QXR0ckNvdW50ICE9PSBvYmoudm9BcnJheS5kZXNjcmlwdG9yLnZlcnRleEF0dHJDb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSB2ZXJ0ZXggb2JqZWN0IGRlc2NyaXB0b3JzIScpXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS92X29faGVscGVyLmpzIiwiXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWwge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbml0aWFsVmFsdWU9MV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChpbml0aWFsVmFsdWUgPSAxKSB7XG4gICAgdGhpcy52YWx1ZSA9IGluaXRpYWxWYWx1ZVxuICB9XG5cbiAgdG91Y2ggKCkge1xuICAgICsrdGhpcy52YWx1ZVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvc2VyaWFsLmpzIiwiaW1wb3J0IFZPQXR0ckRlc2NyaXB0b3IgZnJvbSAnLi4vdl9vX2F0dHJfZGVzY3JpcHRvcidcblxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZGVzY3JpcHRvciwgcHJvdG8pIHtcbiAgY29uc3QgcHJvcGVydGllc09iamVjdCA9IHtcblxuICAgIHRvQXJyYXk6IHtcblxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChhdHRyTmFtZXMpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW11cbiAgICAgICAgY29uc3QgYXR0ckxpc3QgPSBBcnJheS5pc0FycmF5KGF0dHJOYW1lcylcbiAgICAgICAgICA/IGF0dHJOYW1lcy5tYXAobmFtZSA9PiBkZXNjcmlwdG9yLmF0dHJbbmFtZV0pXG4gICAgICAgICAgOiBkZXNjcmlwdG9yLmF0dHJMaXN0XG4gICAgICAgIGNvbnN0IGxlbiA9IGF0dHJMaXN0Lmxlbmd0aFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NyaXB0b3IudmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyTGlzdFtqXVxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBhdHRyLnNpemU7ICsraykge1xuICAgICAgICAgICAgICBhcnIucHVzaChhdHRyLmdldFZhbHVlKHRoaXMsIGksIGspKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IuYXR0cikuZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBhdHRyID0gZGVzY3JpcHRvci5hdHRyWyBuYW1lIF1cblxuICAgIFZPQXR0ckRlc2NyaXB0b3IuZGVmaW5lUHJvcGVydGllcyhhdHRyLCBwcm9wZXJ0aWVzT2JqZWN0LCBkZXNjcmlwdG9yKVxuICB9KVxuXG4gIGRlc2NyaXB0b3Iudm9Qcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgcHJvdG8gPT09ICdvYmplY3QnID8gcHJvdG8gOiB7fSksIHByb3BlcnRpZXNPYmplY3QpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS92X29fZGVzY3JpcHRvci9jcmVhdGVfdl9vX3Byb3RvdHlwZS5qcyIsIlxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICBkZXNjcmlwdG9yLnR5cGVkQXJyYXlzID0ge1xuICAgIGZsb2F0MzI6IGZhbHNlLFxuICAgIGludDE2OiBmYWxzZSxcbiAgICBpbnQzMjogZmFsc2UsXG4gICAgaW50ODogZmFsc2UsXG4gICAgdWludDE2OiBmYWxzZSxcbiAgICB1aW50MzI6IGZhbHNlLFxuICAgIHVpbnQ4OiBmYWxzZVxuICB9XG5cbiAgT2JqZWN0LmtleXMoZGVzY3JpcHRvci5hdHRyKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGRlc2NyaXB0b3IudHlwZWRBcnJheXNbZGVzY3JpcHRvci5hdHRyW25hbWVdLnR5cGVdID0gdHJ1ZVxuICB9KVxuXG4gIE9iamVjdC5mcmVlemUoZGVzY3JpcHRvci50eXBlZEFycmF5cylcblxuICBkZXNjcmlwdG9yLnR5cGVMaXN0ID0gT2JqZWN0LmtleXMoZGVzY3JpcHRvci50eXBlZEFycmF5cykuZmlsdGVyKHR5cGUgPT4gZGVzY3JpcHRvci50eXBlZEFycmF5c1t0eXBlXSkuc29ydCgpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS92X29fZGVzY3JpcHRvci9jcmVhdGVfdHlwZWRfYXJyYXlzLmpzIiwiaW1wb3J0IHsgQllURVNfUEVSX0VMRU1FTlQgfSBmcm9tICcuLi8uLi91dGlscy90eXBlZF9hcnJheV9oZWxwZXJzJ1xuaW1wb3J0IFZPQXR0ckRlc2NyaXB0b3IgZnJvbSAnLi4vdl9vX2F0dHJfZGVzY3JpcHRvcidcblxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZGVzY3JpcHRvciwgYXR0cmlidXRlcykge1xuICBkZXNjcmlwdG9yLmF0dHIgPSB7fVxuICBkZXNjcmlwdG9yLmF0dHJOYW1lcyA9IFtdXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMFxuICAgIGxldCBieXRlT2Zmc2V0ID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1sgaSBdXG5cbiAgICAgIGlmIChhdHRyLnNpemUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggb2JqZWN0IGF0dHJpYnV0ZSBkZXNjcmlwdG9yIGhhcyBubyBzaXplIScpXG5cbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRyLnR5cGUgfHwgJ2Zsb2F0MzInXG5cbiAgICAgIGlmIChhdHRyLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXNjcmlwdG9yLmF0dHJOYW1lcy5wdXNoKGF0dHIubmFtZSlcbiAgICAgICAgZGVzY3JpcHRvci5hdHRyWyBhdHRyLm5hbWUgXSA9IG5ldyBWT0F0dHJEZXNjcmlwdG9yKGF0dHIubmFtZSwgdHlwZSwgYXR0ci5zaXplLCBvZmZzZXQsIGJ5dGVPZmZzZXQsICEhYXR0ci51bmlmb3JtLCBhdHRyLmF0dHJOYW1lcylcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IGF0dHIuc2l6ZVxuICAgICAgYnl0ZU9mZnNldCArPSBCWVRFU19QRVJfRUxFTUVOVFsgdHlwZSBdICogYXR0ci5zaXplXG4gICAgfVxuXG4gICAgLy8gYnl0ZXMgcGVyIHZlcnRleCBpcyBhbHdheXMgYWxpZ25lZCB0byA0LWJ5dGVzIVxuICAgIGRlc2NyaXB0b3IucmlnaHRQYWRCeXRlc1BlclZlcnRleCA9IGJ5dGVPZmZzZXQgJSA0ID4gMCA/IDQgLSAoYnl0ZU9mZnNldCAlIDQpIDogMFxuICAgIGRlc2NyaXB0b3IuYnl0ZXNQZXJWZXJ0ZXggPSBieXRlT2Zmc2V0ICsgZGVzY3JpcHRvci5yaWdodFBhZEJ5dGVzUGVyVmVydGV4XG4gICAgZGVzY3JpcHRvci5ieXRlc1BlclZPID0gZGVzY3JpcHRvci5ieXRlc1BlclZlcnRleCAqIGRlc2NyaXB0b3IudmVydGV4Q291bnRcbiAgICBkZXNjcmlwdG9yLnZlcnRleEF0dHJDb3VudCA9IG9mZnNldFxuICB9XG5cbiAgZGVzY3JpcHRvci5hdHRyTGlzdCA9IGRlc2NyaXB0b3IuYXR0ck5hbWVzLm1hcChuYW1lID0+IGRlc2NyaXB0b3IuYXR0cltuYW1lXSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3Zfb19kZXNjcmlwdG9yL2NyZWF0ZV9hdHRyaWJ1dGVzLmpzIiwiaW1wb3J0IFZPQXR0ckRlc2NyaXB0b3IgZnJvbSAnLi4vdl9vX2F0dHJfZGVzY3JpcHRvcidcblxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZGVzY3JpcHRvciwgYWxpYXNlcykge1xuICBpZiAodHlwZW9mIGFsaWFzZXMgIT09ICdvYmplY3QnKSByZXR1cm5cblxuICBPYmplY3Qua2V5cyhhbGlhc2VzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGxldCBhdHRyID0gYWxpYXNlc1sgbmFtZSBdXG5cbiAgICBpZiAodHlwZW9mIGF0dHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRyID0gZGVzY3JpcHRvci5hdHRyWyBhdHRyIF1cblxuICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXNjcmlwdG9yLmF0dHJbIG5hbWUgXSA9IGF0dHJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRvci5hdHRyWyBuYW1lIF0gPSBuZXcgVk9BdHRyRGVzY3JpcHRvcihuYW1lLCBhdHRyLnR5cGUsIGF0dHIuc2l6ZSwgYXR0ci5vZmZzZXQsIGF0dHIuYnl0ZU9mZnNldCwgISFhdHRyLnVuaWZvcm0sIGF0dHIuYXR0ck5hbWVzKVxuICAgIH1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3Zfb19kZXNjcmlwdG9yL2NyZWF0ZV9hbGlhc2VzLmpzIiwiaW1wb3J0ICogYXMgc2ltcGxlIGZyb20gJy4vc2ltcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3ByaXRlTGlicmFyeSkge1xuICBzcHJpdGVMaWJyYXJ5XG4gICAgLmFkZERlc2NyaXB0b3IoJ3NpbXBsZScsIHNpbXBsZS5kZXNjcmlwdGlvbilcbiAgICAuYWRkVmVydGV4U2hhZGVyKCdzaW1wbGUnLCBzaW1wbGUudmVydGV4U2hhZGVyKVxuICAgIC5hZGRGcmFnbWVudFNoYWRlcignc2ltcGxlJywgc2ltcGxlLmZyYWdtZW50U2hhZGVyKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvc3ByaXRlcy9pbmRleC5qcyIsImltcG9ydCByb3RhdGUgZnJvbSAnLi4vLi4vdXRpbHMvc2hhZGVyX2hlbHBlcnMvcm90YXRlJ1xuXG5leHBvcnQgY29uc3QgdmVydGV4U2hhZGVyID0gW2BcblxuICBhdHRyaWJ1dGUgdmVjMiBwb3MyZDtcbiAgYXR0cmlidXRlIGZsb2F0IHBvc1o7XG4gIGF0dHJpYnV0ZSB2ZWMyIHV2O1xuICBhdHRyaWJ1dGUgdmVjMiB0cmFuc2xhdGU7XG4gIGF0dHJpYnV0ZSBmbG9hdCByb3RhdGU7XG4gIGF0dHJpYnV0ZSBmbG9hdCBzY2FsZTtcbiAgYXR0cmlidXRlIGZsb2F0IG9wYWNpdHk7XG5cbiAgdW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XG5cbiAgdmFyeWluZyB2ZWM0IHZUZXh0dXJlQ29vcmRTY2FsZU9wYWNpdHk7XG5cbiAgYCwgcm90YXRlKCdyb3RhdGVaJywgMC4wLCAwLjAsIDEuMCksIGBcblxuICB2b2lkIG1haW4odm9pZClcbiAge1xuICAgIG1hdDQgcm90YXRpb25NYXRyaXggPSByb3RhdGVaKHJvdGF0ZSk7XG4gICAgZ2xfUG9zaXRpb24gPSB2aWV3TWF0cml4ICogKChyb3RhdGlvbk1hdHJpeCAqICh2ZWM0KHNjYWxlLCBzY2FsZSwgc2NhbGUsIDEuMCkgKiB2ZWM0KHBvczJkLnh5LCBwb3NaLCAxLjApKSkgKyB2ZWM0KHRyYW5zbGF0ZS54eSwgMC4wLCAwLjApKTtcbiAgICB2VGV4dHVyZUNvb3JkU2NhbGVPcGFjaXR5ID0gdmVjNCh1di54eSwgb3BhY2l0eSwgMC4wKTtcbiAgfVxuYF1cblxuZXhwb3J0IGNvbnN0IGZyYWdtZW50U2hhZGVyID0gYFxuXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gIHZhcnlpbmcgdmVjNCB2VGV4dHVyZUNvb3JkU2NhbGVPcGFjaXR5O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XG5cbiAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICBnbF9GcmFnQ29sb3IgPSB2VGV4dHVyZUNvb3JkU2NhbGVPcGFjaXR5LnogKiB0ZXh0dXJlMkQodGV4LCB2ZWMyKHZUZXh0dXJlQ29vcmRTY2FsZU9wYWNpdHkucywgdlRleHR1cmVDb29yZFNjYWxlT3BhY2l0eS50KSk7XG4gIH1cblxuYFxuXG5leHBvcnQgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gIHZlcnRleENvdW50OiA0LFxuXG4gIC8vICstKy0rLSstKyArLSstKy0rLSsgKy0rLStcbiAgLy8gfDB8MXwyfDN8IHw0fDV8Nnw3fCB8OHw5fFxuICAvLyArLSstKy0rLSsgKy0rLSstKy0rICstKy0rXG4gIC8vXG4gIC8vIHxvLW8tb3wgICAgICAgICAgICAgICAgICAgICAgICgzKSBwb3NpdGlvbjogeCx5LHpcbiAgLy8gICAgICAgfG98ICAgICAgICAgICAgICAgICAgICAgKDEpIHJvdGF0ZVxuICAvLyAgICAgICAgICAgfG8tb3wgICAgICAgICAgICAgICAoMikgdGV4LWNvb3JkczogcywgdFxuICAvLyAgICAgICAgICAgICAgIHxvLW98ICAgICAgICAgICAoMykgdHJhbnNsYXRlOiB0eCwgdHlcbiAgLy8gICAgICAgICAgICAgICAgICAgICB8b3wgICAgICAgKDEpIHNjYWxlXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICB8b3wgICAgICgxKSBvcGFjaXR5XG4gIC8vXG5cbiAgYXR0cmlidXRlczogW1xuICAgIHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogJ2Zsb2F0MzInLCBzaXplOiAzLCBhdHRyTmFtZXM6IFsgJ3gnLCAneScsICd6JyBdIH0sXG4gICAgeyBuYW1lOiAncm90YXRlJywgdHlwZTogJ2Zsb2F0MzInLCBzaXplOiAxLCB1bmlmb3JtOiB0cnVlIH0sXG4gICAgeyBuYW1lOiAndGV4Q29vcmRzJywgdHlwZTogJ2Zsb2F0MzInLCBzaXplOiAyLCBhdHRyTmFtZXM6IFsgJ3MnLCAndCcgXSB9LFxuICAgIHsgbmFtZTogJ3RyYW5zbGF0ZScsIHR5cGU6ICdmbG9hdDMyJywgc2l6ZTogMiwgYXR0ck5hbWVzOiBbICd0eCcsICd0eScgXSwgdW5pZm9ybTogdHJ1ZSB9LFxuICAgIHsgbmFtZTogJ3NjYWxlJywgdHlwZTogJ2Zsb2F0MzInLCBzaXplOiAxLCB1bmlmb3JtOiB0cnVlIH0sXG4gICAgeyBuYW1lOiAnb3BhY2l0eScsIHR5cGU6ICdmbG9hdDMyJywgc2l6ZTogMSwgdW5pZm9ybTogdHJ1ZSB9XG4gIF0sXG5cbiAgYWxpYXNlczoge1xuICAgIHBvczJkOiB7IHNpemU6IDIsIHR5cGU6ICdmbG9hdDMyJywgb2Zmc2V0OiAwIH0sXG4gICAgcG9zWjogeyBzaXplOiAxLCB0eXBlOiAnZmxvYXQzMicsIG9mZnNldDogMiwgdW5pZm9ybTogdHJ1ZSB9LFxuICAgIHV2OiAndGV4Q29vcmRzJ1xuICB9LFxuXG4gIHByb3RvOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWaWV3cG9ydH0gdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGV4dHVyZVdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVIZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JlcGVhdF0gLSB0ZXh0dXJlIHJlcGVhdCBmYWN0b3JcbiAgICAgKi9cbiAgICBzZXRUZXhDb29yZHNCeVZpZXdwb3J0ICh2aWV3cG9ydCwgdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0LCByZXBlYXQpIHtcbiAgICAgIGxldCB4MCA9IHZpZXdwb3J0LnggPT09IDAgPyAwIDogKHZpZXdwb3J0LnggLyB0ZXh0dXJlV2lkdGgpXG4gICAgICBsZXQgeDEgPSAodmlld3BvcnQueCArIHZpZXdwb3J0LndpZHRoKSAvIHRleHR1cmVXaWR0aFxuICAgICAgbGV0IHkwID0gMSAtICh2aWV3cG9ydC55ICsgdmlld3BvcnQuaGVpZ2h0KSAvIHRleHR1cmVIZWlnaHRcbiAgICAgIGxldCB5MSA9IHZpZXdwb3J0LnkgPT09IDAgPyAxIDogMSAtICh2aWV3cG9ydC55IC8gdGV4dHVyZUhlaWdodClcblxuICAgICAgaWYgKHJlcGVhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHgwICo9IHJlcGVhdFxuICAgICAgICB4MSAqPSByZXBlYXRcbiAgICAgICAgeTAgKj0gcmVwZWF0XG4gICAgICAgIHkxICo9IHJlcGVhdFxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFRleENvb3Jkcyh4MCwgeTAsIHgxLCB5MCwgeDEsIHkxLCB4MCwgeTEpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZVxuICAgICAqL1xuICAgIHNldFRleENvb3Jkc0J5VGV4dHVyZSAodGV4dHVyZSkge1xuICAgICAgY29uc3QgeDAgPSB0ZXh0dXJlLm1pblNcbiAgICAgIGNvbnN0IHkwID0gdGV4dHVyZS5taW5UXG4gICAgICBjb25zdCB4MSA9IHRleHR1cmUubWF4U1xuICAgICAgY29uc3QgeTEgPSB0ZXh0dXJlLm1heFRcblxuICAgICAgdGhpcy5zZXRUZXhDb29yZHMoeDAsIHkwLCB4MSwgeTAsIHgxLCB5MSwgeDAsIHkxKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgc2V0U2l6ZSAod2lkdGgsIGhlaWdodCkge1xuICAgICAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggKiAwLjVcbiAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSAoaGVpZ2h0ID09IG51bGwgPyB3aWR0aCA6IGhlaWdodCkgKiAwLjVcblxuICAgICAgdGhpcy5zZXRQb3MyZChcbiAgICAgICAgLWhhbGZXaWR0aCwgaGFsZkhlaWdodCxcbiAgICAgICAgaGFsZldpZHRoLCBoYWxmSGVpZ2h0LFxuICAgICAgICBoYWxmV2lkdGgsIC1oYWxmSGVpZ2h0LFxuICAgICAgICAtaGFsZldpZHRoLCAtaGFsZkhlaWdodFxuICAgICAgKVxuICAgIH0sXG5cbiAgICBnZXQgd2lkdGggKCkge1xuICAgICAgcmV0dXJuIHRoaXMueDEgLSB0aGlzLngzXG4gICAgfSxcblxuICAgIGdldCBoZWlnaHQgKCkge1xuICAgICAgcmV0dXJuIHRoaXMueTAgLSB0aGlzLnkyXG4gICAgfSxcblxuICAgIGdldCByb3RhdGVEZWdyZWUgKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm90YXRlICogMTgwLjAgLyBNYXRoLlBJXG4gICAgfSxcblxuICAgIHNldCByb3RhdGVEZWdyZWUgKGRlZ3JlZSkge1xuICAgICAgdGhpcy5yb3RhdGUgPSBkZWdyZWUgKiAoTWF0aC5QSSAvIDE4MC4wKVxuICAgIH0sXG5cbiAgICBnZXQgeiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy56MFxuICAgIH0sXG5cbiAgICBzZXQgeiAoeikge1xuICAgICAgdGhpcy56MCA9IHpcbiAgICAgIHRoaXMuejEgPSB6XG4gICAgICB0aGlzLnoyID0gelxuICAgICAgdGhpcy56MyA9IHpcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb3JlL3Nwcml0ZXMvc2ltcGxlLmpzIiwiaW1wb3J0IHJldCBmcm9tICcuL3JldCdcbmltcG9ydCBtYXQ0IGZyb20gJy4vbWF0NCdcbmltcG9ydCBtdWwgZnJvbSAnLi9tdWwnXG5pbXBvcnQgc3ViIGZyb20gJy4vc3ViJ1xuaW1wb3J0IGFkZCBmcm9tICcuL2FkZCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGZ1bmNOYW1lID0gJ3JvdGF0ZScsIHggPSAwLjAsIHkgPSAwLjAsIHogPSAxLjApIHtcbiAgcmV0dXJuIFtcblxuICAgIGBtYXQ0ICR7ZnVuY05hbWV9KGZsb2F0IGFuZ2xlKSB7YCxcblxuICAgICdmbG9hdCBzID0gc2luKGFuZ2xlKTsnLFxuICAgICdmbG9hdCBjID0gY29zKGFuZ2xlKTsnLFxuICAgICdmbG9hdCBvYyA9IDEuMCAtIGM7JyxcblxuICAgIHJldChcbiAgICAgIG1hdDQoXG4gICAgICAgIGFkZChtdWwoJ29jJywgeCAqIHgpLCAnYycpLCBzdWIobXVsKCdvYycsIHggKiB5KSwgbXVsKHosICdzJykpLCBhZGQobXVsKCdvYycsIHogKiB4KSwgbXVsKHksICdzJykpLCAwLFxuICAgICAgICBhZGQobXVsKCdvYycsIHggKiB5KSwgbXVsKHosICdzJykpLCBhZGQobXVsKCdvYycsIHkgKiB5KSwgJ2MnKSwgc3ViKG11bCgnb2MnLCB5ICogeiksIG11bCh4LCAncycpKSwgMCxcbiAgICAgICAgc3ViKG11bCgnb2MnLCB6ICogeCksIG11bCh5LCAncycpKSwgYWRkKG11bCgnb2MnLCB5ICogeiksIG11bCh4LCAncycpKSwgYWRkKG11bCgnb2MnLCB6ICogeiksICdjJylcbiAgICAgIClcbiAgICApLFxuXG4gICAgJ30nXG5cbiAgXVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL3JvdGF0ZS5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmV0IChyZXMpIHtcbiAgcmV0dXJuIGByZXR1cm4gJHtyZXN9O2Bcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9zaGFkZXJfaGVscGVycy9yZXQuanMiLCJpbXBvcnQgYXNGbG9hdCBmcm9tICcuL2FzX2Zsb2F0J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXQ0IChtMDAgPSAwLCBtMDEgPSAwLCBtMDIgPSAwLCBtMDMgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTEwID0gMCwgbTExID0gMCwgbTEyID0gMCwgbTEzID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0yMCA9IDAsIG0yMSA9IDAsIG0yMiA9IDAsIG0yMyA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMzAgPSAwLCBtMzEgPSAwLCBtMzIgPSAwLCBtMzMgPSAxLCBhcyA9IGFzRmxvYXQpIHtcbiAgY29uc3QgdG9TdHIgPSBhcyB8fCAoKHgpID0+IHggKyAnJylcbiAgcmV0dXJuIGBtYXQ0KCR7dG9TdHIobTAwKX0sICR7dG9TdHIobTAxKX0sICR7dG9TdHIobTAyKX0sICR7dG9TdHIobTAzKX0sICR7dG9TdHIobTEwKX0sICR7dG9TdHIobTExKX0sICR7dG9TdHIobTEyKX0sICR7dG9TdHIobTEzKX0sICR7dG9TdHIobTIwKX0sICR7dG9TdHIobTIxKX0sICR7dG9TdHIobTIyKX0sICR7dG9TdHIobTIzKX0sICR7dG9TdHIobTMwKX0sICR7dG9TdHIobTMxKX0sICR7dG9TdHIobTMyKX0sICR7dG9TdHIobTMzKX0pYFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL21hdDQuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgY29uc3Qgc3RyID0gKG51bWJlciArICcnKS50cmltKClcbiAgaWYgKHN0ci5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgIHJldHVybiBzdHIgKyAnLjAnXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL2FzX2Zsb2F0LmpzIiwiXG5mdW5jdGlvbiBpc051bWJlciAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInXG59XG5cbmV4cG9ydCBkZWZhdWx0IChhLCBiKSA9PiB7XG4gIGlmIChpc051bWJlcihiKSAmJiBpc051bWJlcihhKSkge1xuICAgIHJldHVybiBhICogYlxuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGEpKSB7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiAwXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBiXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYCR7YX0gKiAke2J9YFxuICAgIH1cbiAgfSBlbHNlIGlmIChpc051bWJlcihiKSkge1xuICAgIHN3aXRjaCAoYikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gMFxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gYVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke2F9ICogJHtifWBcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke2F9ICogJHtifWBcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL211bC5qcyIsIlxuZnVuY3Rpb24gaXNOdW1iZXIgKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJ1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgaWYgKGlzTnVtYmVyKGEpICYmIGlzTnVtYmVyKGIpKSB7XG4gICAgcmV0dXJuIGEgLSBiXG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoYSkpIHtcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGAtJHtifWBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgJHthfSAtICR7Yn1gXG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGIpKSB7XG4gICAgc3dpdGNoIChiKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBhXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYCR7YX0gLSAke2J9YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7YX0gLSAke2J9YFxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvc2hhZGVyX2hlbHBlcnMvc3ViLmpzIiwiXG5mdW5jdGlvbiBpc051bWJlciAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICBpZiAoaXNOdW1iZXIoYSkgJiYgaXNOdW1iZXIoYikpIHtcbiAgICByZXR1cm4gYSArIGJcbiAgfSBlbHNlIGlmIChpc051bWJlcihhKSkge1xuICAgIHN3aXRjaCAoYSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gYlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke2F9ICsgJHtifWBcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoYikpIHtcbiAgICBzd2l0Y2ggKGIpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGFcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgJHthfSArICR7Yn1gXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHthfSArICR7Yn1gXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9zaGFkZXJfaGVscGVycy9hZGQuanMiLCJpbXBvcnQgV2ViR2xSZXNvdXJjZUxpYnJhcnkgZnJvbSAnLi93ZWJfZ2xfcmVzb3VyY2VfbGlicmFyeSdcbmltcG9ydCBXZWJHbFRleHR1cmVNYW5hZ2VyIGZyb20gJy4vd2ViX2dsX3RleHR1cmVfbWFuYWdlcidcbmltcG9ydCBkZXN0cm95IGZyb20gJy4uL3V0aWxzL2Rlc3Ryb3knXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdsQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yIChnbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ2wnLCB7IHZhbHVlOiBnbCB9KVxuXG4gICAgaW5pdGlhbGl6ZSh0aGlzKVxuXG4gICAgdGhpcy5yZXNvdXJjZUxpYnJhcnkgPSBuZXcgV2ViR2xSZXNvdXJjZUxpYnJhcnkodGhpcylcbiAgICB0aGlzLmJvdW5kQnVmZmVycyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuY3VycmVudFByb2dyYW0gPSAwXG4gICAgdGhpcy5lbmFibGVkVmVydGV4QXR0cmliTG9jYXRpb25zID0gW11cblxuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgV2ViR2xUZXh0dXJlTWFuYWdlcih0aGlzKVxuXG4gICAgdGhpcy5ib3VuZFRleHR1cmVzID0gbmV3IEFycmF5KHRoaXMuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IHsgVEVYVFVSRV8yRDogbnVsbCB9XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkQ3VycmVudFN0YXRlKClcbiAgICB0aGlzLmFjdGl2ZVRleHR1cmUoMCkgLy8gZW5hYmxlIGZpcnN0IHRleHR1cmUgdW5pdCBieSBkZWZhdWx0XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRlc3Ryb3koKVxuICAgIHRoaXMuYm91bmRCdWZmZXJzLmNsZWFyKClcbiAgICB0aGlzLnJlc291cmNlTGlicmFyeS5kZXN0cm95KClcbiAgICBkZXN0cm95KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCbGVuZE1vZGV9IGJsZW5kTW9kZVxuICAgKi9cbiAgYmxlbmQgKGJsZW5kTW9kZSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXNcbiAgICBpZiAoYmxlbmRNb2RlLmVuYWJsZSkge1xuICAgICAgaWYgKCF0aGlzLmJsZW5kRW5hYmxlZCkge1xuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpXG4gICAgICAgIHRoaXMuYmxlbmRFbmFibGVkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgZ2wuYmxlbmRGdW5jKGdsW2JsZW5kTW9kZS5zZmFjdG9yXSwgZ2xbYmxlbmRNb2RlLmRmYWN0b3JdKVxuICAgIH0gZWxzZSBpZiAodGhpcy5ibGVuZEVuYWJsZWQpIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpXG4gICAgICB0aGlzLmJsZW5kRW5hYmxlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXhVbml0XG4gICAqL1xuICBhY3RpdmVUZXh0dXJlICh0ZXhVbml0KSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpc1xuICAgIGNvbnN0IHRleCA9IGdsLlRFWFRVUkUwICsgdGV4VW5pdFxuXG4gICAgaWYgKHRoaXMuYWN0aXZlVGV4VW5pdCAhPT0gdGV4KSB7XG4gICAgICB0aGlzLmFjdGl2ZVRleFVuaXQgPSB0ZXhcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5hY3RpdmVUZXhVbml0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZ2xUZXh0dXJlSWRcbiAgICovXG4gIGJpbmRUZXh0dXJlMmQgKGdsVGV4dHVyZUlkKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpc1xuICAgIGNvbnN0IGJvdW5kID0gdGhpcy5ib3VuZFRleHR1cmVzW3RoaXMuYWN0aXZlVGV4VW5pdCAtIGdsLlRFWFRVUkUwXVxuXG4gICAgaWYgKGJvdW5kLlRFWFRVUkVfMkQgIT09IGdsVGV4dHVyZUlkKSB7XG4gICAgICBib3VuZC5URVhUVVJFXzJEID0gZ2xUZXh0dXJlSWRcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZUlkKVxuICAgIH1cbiAgfVxuXG4gIHJlYWRDdXJyZW50U3RhdGUgKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXNcblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9XZWJHTFJlbmRlcmluZ0NvbnRleHQvZ2V0UGFyYW1ldGVyXG5cbiAgICB0aGlzLmJvdW5kQnVmZmVycy5zZXQoXG4gICAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuQVJSQVlfQlVGRkVSX0JJTkRJTkcpKVxuICAgIHRoaXMuYm91bmRCdWZmZXJzLnNldChcbiAgICAgIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkcpKVxuXG4gICAgdGhpcy5jdXJyZW50UHJvZ3JhbSA9IGdsLmdldFBhcmFtZXRlcihnbC5DVVJSRU5UX1BST0dSQU0pXG4gICAgdGhpcy5ibGVuZEVuYWJsZWQgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkQpXG4gIH1cblxuICBiaW5kQnVmZmVyICh0YXJnZXQsIGJ1ZmZlcikge1xuICAgIGlmICh0aGlzLmJvdW5kQnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gYnVmZmVyKSB7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpXG4gICAgICB0aGlzLmJvdW5kQnVmZmVycy5zZXQodGFyZ2V0LCBidWZmZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICB1c2VQcm9ncmFtIChnbFByb2dyYW0pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UHJvZ3JhbSAhPT0gZ2xQcm9ncmFtKSB7XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0oZ2xQcm9ncmFtKVxuICAgICAgdGhpcy5jdXJyZW50UHJvZ3JhbSA9IGdsUHJvZ3JhbVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheXMgKGVuYWJsZUxvY2F0aW9ucykge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXNcblxuICAgIHRoaXMuZW5hYmxlZFZlcnRleEF0dHJpYkxvY2F0aW9uc1xuICAgICAgLmZpbHRlcihsb2NhdGlvbiA9PiBlbmFibGVMb2NhdGlvbnMuaW5kZXhPZihsb2NhdGlvbikgPT09IC0xKVxuICAgICAgLmZvckVhY2gobG9jYXRpb24gPT4ge1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pXG4gICAgICAgIHRoaXMuZW5hYmxlZFZlcnRleEF0dHJpYkxvY2F0aW9ucy5zcGxpY2UoZW5hYmxlTG9jYXRpb25zLmluZGV4T2YobG9jYXRpb24pLCAxKVxuICAgICAgfSlcblxuICAgIGVuYWJsZUxvY2F0aW9ucy5mb3JFYWNoKGxvYyA9PiB7XG4gICAgICBjb25zdCBpZHggPSB0aGlzLmVuYWJsZWRWZXJ0ZXhBdHRyaWJMb2NhdGlvbnMuaW5kZXhPZihsb2MpXG4gICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpXG4gICAgICAgIHRoaXMuZW5hYmxlZFZlcnRleEF0dHJpYkxvY2F0aW9ucy5wdXNoKGxvYylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZSAoZ2x4KSB7XG4gIGNvbnN0IHsgZ2wgfSA9IGdseFxuXG4gIGdseC5ERVBUSF9CSVRTID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLkRFUFRIX0JJVFMpXG4gIGdseC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXIvd2ViX2dsX2NvbnRleHQuanMiLCJpbXBvcnQgUmVzb3VyY2VSZWYgZnJvbSAnLi4vdXRpbHMvcmVzb3VyY2VfcmVmJ1xuaW1wb3J0IFdlYkdsU2hhZGVyIGZyb20gJy4vd2ViX2dsX3NoYWRlcidcbmltcG9ydCBXZWJHbFByb2dyYW0gZnJvbSAnLi93ZWJfZ2xfcHJvZ3JhbSdcbmltcG9ydCBXZWJHbEJ1ZmZlciBmcm9tICcuL3dlYl9nbF9idWZmZXInXG5pbXBvcnQgV2ViR2xUZXh0dXJlIGZyb20gJy4vd2ViX2dsX3RleHR1cmUnXG5cbmltcG9ydCBkZXN0cm95IGZyb20gJy4uL3V0aWxzL2Rlc3Ryb3knXG5cbmNvbnN0IFdFQl9HTF9CVUZGRVJfVVNBR0UgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdGljOiBXZWJHbEJ1ZmZlci5TVEFUSUNfRFJBVyxcbiAgZHluYW1pYzogV2ViR2xCdWZmZXIuRFlOQU1JQ19EUkFXXG59KVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHbFJlc291cmNlTGlicmFyeSB7XG4gIGNvbnN0cnVjdG9yIChnbHgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dseCcsIHsgdmFsdWU6IGdseCB9KVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBuZXcgTWFwKClcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gbmV3IE1hcCgpXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5zaGFkZXJQcm9ncmFtID0gbmV3IE1hcCgpXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgTWFwKClcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgTWFwKClcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMudGV4dHVyZS5jbGVhcigpXG4gICAgdGhpcy5idWZmZXIuY2xlYXIoKVxuICAgIHRoaXMuc2hhZGVyUHJvZ3JhbS5jbGVhcigpXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlci5jbGVhcigpXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIuY2xlYXIoKVxuICAgIGRlc3Ryb3kodGhpcylcbiAgfVxuXG4gIGxvYWRWZXJ0ZXhTaGFkZXIgKHNoYWRlclNvdXJjZSkge1xuICAgIGxldCBnbFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyLmdldChzaGFkZXJTb3VyY2UuaWQpXG4gICAgaWYgKCFnbFNoYWRlcikge1xuICAgICAgZ2xTaGFkZXIgPSBuZXcgV2ViR2xTaGFkZXIodGhpcy5nbHgsIHNoYWRlclNvdXJjZSlcbiAgICAgIHRoaXMudmVydGV4U2hhZGVyLnNldChzaGFkZXJTb3VyY2UuaWQsIGdsU2hhZGVyKVxuICAgIH1cbiAgICByZXR1cm4gZ2xTaGFkZXJcbiAgfVxuXG4gIGxvYWRGcmFnZW1lbnRTaGFkZXIgKHNoYWRlclNvdXJjZSkge1xuICAgIGxldCBnbFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXIuZ2V0KHNoYWRlclNvdXJjZS5pZClcbiAgICBpZiAoIWdsU2hhZGVyKSB7XG4gICAgICBnbFNoYWRlciA9IG5ldyBXZWJHbFNoYWRlcih0aGlzLmdseCwgc2hhZGVyU291cmNlKVxuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIuc2V0KHNoYWRlclNvdXJjZS5pZCwgZ2xTaGFkZXIpXG4gICAgfVxuICAgIHJldHVybiBnbFNoYWRlclxuICB9XG5cbiAgbG9hZFByb2dyYW0gKHNoYWRlclByb2dyYW0pIHtcbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbS5nZXQoc2hhZGVyUHJvZ3JhbS5pZClcbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgIHByb2dyYW0gPSBuZXcgV2ViR2xQcm9ncmFtKHRoaXMuZ2x4LCBzaGFkZXJQcm9ncmFtKVxuICAgICAgdGhpcy5zaGFkZXJQcm9ncmFtLnNldChzaGFkZXJQcm9ncmFtLmlkLCBwcm9ncmFtKVxuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzb3VyY2VSZWZ9IHJlZiAtIHJlc291cmNlIHJlZmVyZW5jZSB0byBWT0FycmF5IG9yIGBFbGVtZW50SW5kZXhBcnJheWBcbiAgICogQHJldHVybnMge1Jlc291cmNlUmVmfSByZXNvdXJjZSByZWZlcmVuY2UgdG8gYFdlYkdsQnVmZmVyYFxuICAgKi9cbiAgbG9hZEJ1ZmZlciAocmVmKSB7XG4gICAgbGV0IGJ1ZmZlclJlZiA9IHRoaXMuYnVmZmVyLmdldChyZWYuaWQpXG4gICAgaWYgKCFidWZmZXJSZWYpIHtcbiAgICAgIC8vIGNyZWF0ZSBXZWJHbEJ1ZmZlclxuICAgICAgY29uc3QgdGFyZ2V0ID0gcmVmLmhpbnRzLnRhcmdldCB8fCBXZWJHbEJ1ZmZlci5BUlJBWV9CVUZGRVJcbiAgICAgIGNvbnN0IGdsQnVmZmVyID0gbmV3IFdlYkdsQnVmZmVyKHRoaXMuZ2x4LCB0YXJnZXQsIFdFQl9HTF9CVUZGRVJfVVNBR0VbcmVmLmhpbnRzLnVzYWdlXSlcbiAgICAgIC8vIGNyZWF0ZSBSZXNvdXJjZVJlZlxuICAgICAgYnVmZmVyUmVmID0gbmV3IFJlc291cmNlUmVmKGdsQnVmZmVyLCB7IGlkOiByZWYuaWQsIHNlcmlhbDogMCB9KVxuICAgICAgdGhpcy5idWZmZXIuc2V0KHJlZi5pZCwgYnVmZmVyUmVmKVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyUmVmXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXNvdXJjZVJlZn0gcmVzb3VyY2VSZWZcbiAgICogQHJldHVybnMge1Jlc291cmNlUmVmfSByZXNvdXJjZSByZWZlcmVuY2UgdG8gV2ViR2xCdWZmZXJcbiAgICovXG4gIGZpbmRCdWZmZXIgKHJlc291cmNlUmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmdldChyZXNvdXJjZVJlZi5pZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Jlc291cmNlUmVmfSB0ZXhSZWYgLSByZXNvdXJjZSByZWZlcmVuY2UgdG8gdGV4dHVyZVxuICAgKiBAcmV0dXJucyB7UmVzb3VyY2VSZWZ9IHJlc291cmNlIHJlZmVyZW5jZSB0byBXZWJHbFRleHR1cmVcbiAgICovXG4gIGxvYWRUZXh0dXJlICh0ZXhSZWYpIHtcbiAgICBsZXQgZ2xUZXh0dXJlUmVmID0gdGhpcy50ZXh0dXJlLmdldCh0ZXhSZWYuaWQpXG4gICAgaWYgKCFnbFRleHR1cmVSZWYpIHtcbiAgICAgIC8vIGNyZWF0ZSBXZWJHbFRleHR1cmVcbiAgICAgIGNvbnN0IGdsVGV4ID0gbmV3IFdlYkdsVGV4dHVyZShcbiAgICAgICAgdGhpcy5nbHgsXG4gICAgICAgIHRleFJlZi5yZXNvdXJjZS5pbWdFbCxcbiAgICAgICAgdGV4UmVmLmhpbnRzLmZsaXBZLFxuICAgICAgICB0ZXhSZWYuaGludHMucmVwZWF0YWJsZSxcbiAgICAgICAgdGV4UmVmLmhpbnRzLnByZW11bHRpcGx5QWxwaGEsXG4gICAgICAgIHRleFJlZi5oaW50cy5uZWFyZXN0XG4gICAgICApXG4gICAgICAvLyBjcmVhdGUgUmVzb3VyY2VSZWZcbiAgICAgIGdsVGV4dHVyZVJlZiA9IG5ldyBSZXNvdXJjZVJlZihnbFRleCwgeyBpZDogdGV4UmVmLmlkLCBzZXJpYWw6IDAgfSlcbiAgICAgIHRoaXMudGV4dHVyZS5zZXQodGV4UmVmLmlkLCBnbFRleHR1cmVSZWYpXG4gICAgfVxuICAgIHJldHVybiBnbFRleHR1cmVSZWZcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlci93ZWJfZ2xfcmVzb3VyY2VfbGlicmFyeS5qcyIsImltcG9ydCBTaGFkZXJTb3VyY2UgZnJvbSAnLi4vY29yZS9zaGFkZXJfc291cmNlJ1xuaW1wb3J0IHNvdXJjZVRvU3RyIGZyb20gJy4uL3V0aWxzL3NoYWRlcl9oZWxwZXJzL3NvdXJjZV90b19zdHInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdsU2hhZGVyIHtcbiAgY29uc3RydWN0b3IgKGdseCwgc291cmNlKSB7XG4gICAgdGhpcy5nbHggPSBnbHhcblxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFNoYWRlclNvdXJjZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR2xTaGFkZXIgcGFuaWMhIHNvdXJjZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFNoYWRlclNvdXJjZSEnKVxuICAgIH1cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZVxuXG4gICAgY29uc3QgeyBnbCB9ID0gZ2x4XG4gICAgdGhpcy5zaGFkZXJUeXBlID0gZ2xbc291cmNlLnR5cGVdXG5cbiAgICB0aGlzLmdsU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHRoaXMuc2hhZGVyVHlwZSlcbiAgICBjb21waWxlU2hhZGVyKHRoaXMpXG5cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVNoYWRlciAoc2hhZGVyKSB7XG4gIGNvbnN0IHsgZ2wgfSA9IHNoYWRlci5nbHhcbiAgY29uc3QgeyBnbFNoYWRlciwgc291cmNlIH0gPSBzaGFkZXJcblxuICBjb25zdCBzcmMgPSBzb3VyY2VUb1N0cih7IGdseDogc2hhZGVyLmdseCB9LCBzb3VyY2Uuc291cmNlKVxuXG4gIGdsLnNoYWRlclNvdXJjZShnbFNoYWRlciwgc3JjKVxuICBnbC5jb21waWxlU2hhZGVyKGdsU2hhZGVyKVxuXG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGdsU2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zdCBzaGFkZXJJbmZvTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhnbFNoYWRlcilcblxuICAgIGNvbnNvbGUuZXJyb3Ioc2hhZGVySW5mb0xvZylcbiAgICBjb25zb2xlLmdyb3VwKCdzaGFkZXItaW5mbycpXG4gICAgY29uc29sZS5kZWJ1Zygnc2hhZGVyU291cmNlJywgc2hhZGVyKVxuICAgIGNvbnNvbGUubG9nKHNvdXJjZSlcbiAgICBjb25zb2xlLmdyb3VwRW5kKClcblxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignV2ViR2xTaGFkZXIgY29tcGlsZSBwYW5pYyEnKVxuICAgIGVyci53ZWJHbFNoYWRlciA9IHNoYWRlclxuICAgIGVyci5zaGFkZXJJbmZvTG9nID0gc2hhZGVySW5mb0xvZ1xuICAgIHRocm93IGVyclxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL3dlYl9nbF9zaGFkZXIuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvdXJjZVRvU3RyIChjdHgsIHNvdXJjZSkge1xuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc291cmNlXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzb3VyY2VUb1N0cihjdHgsIHNvdXJjZShjdHgpKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKHNvdXJjZVRvU3RyLmJpbmQobnVsbCwgY3R4KSkuam9pbignXFxuJylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc291cmNlICsgJydcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL3NoYWRlcl9oZWxwZXJzL3NvdXJjZV90b19zdHIuanMiLCJpbXBvcnQgV2ViR2xVbmlmb3JtIGZyb20gJy4vd2ViX2dsX3VuaWZvcm0nXG5pbXBvcnQgV2ViR2xBdHRyaWJ1dGUgZnJvbSAnLi93ZWJfZ2xfYXR0cmlidXRlJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHbFByb2dyYW0ge1xuICBjb25zdHJ1Y3RvciAoZ2x4LCBzaGFkZXJQcm9ncmFtKSB7XG4gICAgdGhpcy5nbHggPSBnbHhcblxuICAgIHRoaXMudmVydGV4U2hhZGVyID0gZ2x4LnJlc291cmNlTGlicmFyeS5sb2FkVmVydGV4U2hhZGVyKHNoYWRlclByb2dyYW0udmVydGV4U2hhZGVyKVxuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbHgucmVzb3VyY2VMaWJyYXJ5LmxvYWRGcmFnZW1lbnRTaGFkZXIoc2hhZGVyUHJvZ3JhbS5mcmFnbWVudFNoYWRlcilcblxuICAgIGNvbnN0IHsgZ2wgfSA9IGdseFxuICAgIHRoaXMuZ2xQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXG5cbiAgICBsaW5rUHJvZ3JhbSh0aGlzLCB0aGlzLnZlcnRleFNoYWRlci5nbFNoYWRlciwgdGhpcy5mcmFnbWVudFNoYWRlci5nbFNoYWRlcilcbiAgICAvLyBUT0RPIGdsLmRlbGV0ZVNoYWRlcj9cblxuICAgIGNyZWF0ZVVuaWZvcm1zKHRoaXMpXG4gICAgY3JlYXRlQXR0cmlidXRlcyh0aGlzKVxuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICB1c2UgKCkge1xuICAgIGNvbnN0IHsgZ2x4IH0gPSB0aGlzXG4gICAgaWYgKGdseC51c2VQcm9ncmFtKHRoaXMuZ2xQcm9ncmFtKSkge1xuICAgICAgZ2x4LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5cyh0aGlzLmF0dHJpYnV0ZUxvY2F0aW9ucylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2hhZGVyQ29udGV4dH0gc2hhZGVyQ29udGV4dFxuICAgKiBAcGFyYW0ge1dlYkdsUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBsb2FkVW5pZm9ybXMgKHNoYWRlckNvbnRleHQsIHJlbmRlcmVyKSB7XG4gICAgdGhpcy51bmlmb3JtTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGxldCBzaGFkZXJWYXIgPSBzaGFkZXJDb250ZXh0LmN1clVuaWZvcm0obmFtZSlcbiAgICAgIGlmIChzaGFkZXJWYXIgPT0gbnVsbCkge1xuICAgICAgICBzaGFkZXJWYXIgPSBzaGFkZXJDb250ZXh0LmN1clRleDJkKG5hbWUpXG4gICAgICAgIGlmIChzaGFkZXJWYXIgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tXZWJHbFByb2dyYW1dIGNvdWxkIG5vdCBsb2FkIHVuaWZvcm06JywgbmFtZSlcbiAgICAgICAgfVxuICAgICAgICBzaGFkZXJWYXIuc3luY1RleHR1cmVBbmRWYWx1ZShyZW5kZXJlcilcbiAgICAgIH1cbiAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0uc2V0VmFsdWUoc2hhZGVyVmFyLnZhbHVlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogc3luYyBidWZmZXIgYmVmb3JlIGxvYWRcbiAgICpcbiAgICogQHBhcmFtIHtTaGFkZXJDb250ZXh0fSBzaGFkZXJDb250ZXh0XG4gICAqIEBwYXJhbSB7V2ViR2xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIGxvYWRBdHRyaWJ1dGVzIChzaGFkZXJDb250ZXh0LCByZW5kZXJlcikge1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYlZhbHVlID0gc2hhZGVyQ29udGV4dC5jdXJBdHRyaWIobmFtZSkudmFsdWVcbiAgICAgIHJlbmRlcmVyLnN5bmNCdWZmZXIoYXR0cmliVmFsdWUpLmJpbmRCdWZmZXIoKVxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmliVmFsdWUuZGVzY3JpcHRvcilcbiAgICB9KVxuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlcyAocHJvZ3JhbSkge1xuICBjb25zdCB7IGdsIH0gPSBwcm9ncmFtLmdseFxuICBjb25zdCBsZW4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0uZ2xQcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUylcblxuICBwcm9ncmFtLmF0dHJpYnV0ZXMgPSB7fVxuICBwcm9ncmFtLmF0dHJpYnV0ZU5hbWVzID0gW11cbiAgcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBhdHRyaWIgPSBuZXcgV2ViR2xBdHRyaWJ1dGUocHJvZ3JhbSwgaSlcbiAgICBwcm9ncmFtLmF0dHJpYnV0ZXNbYXR0cmliLm5hbWVdID0gYXR0cmliXG4gICAgcHJvZ3JhbS5hdHRyaWJ1dGVOYW1lcy5wdXNoKGF0dHJpYi5uYW1lKVxuICAgIHByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zLnB1c2goYXR0cmliLmxvY2F0aW9uKVxuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShwcm9ncmFtLmF0dHJpYnV0ZXMpXG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybXMgKHByb2dyYW0pIHtcbiAgY29uc3QgeyBnbCB9ID0gcHJvZ3JhbS5nbHhcbiAgY29uc3QgbGVuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLmdsUHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKVxuXG4gIHByb2dyYW0udW5pZm9ybXMgPSB7fVxuICBwcm9ncmFtLnVuaWZvcm1OYW1lcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IHVuaWZvcm0gPSBuZXcgV2ViR2xVbmlmb3JtKHByb2dyYW0sIGkpXG4gICAgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybVxuICAgIHByb2dyYW0udW5pZm9ybU5hbWVzLnB1c2godW5pZm9ybS5uYW1lKVxuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShwcm9ncmFtLnVuaWZvcm1zKVxufVxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGxpbmtQcm9ncmFtIChwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gIGNvbnN0IHsgZ2wgfSA9IHByb2dyYW0uZ2x4XG4gIGNvbnN0IHsgZ2xQcm9ncmFtIH0gPSBwcm9ncmFtXG5cbiAgZ2wuYXR0YWNoU2hhZGVyKGdsUHJvZ3JhbSwgdmVydGV4U2hhZGVyKVxuICBnbC5hdHRhY2hTaGFkZXIoZ2xQcm9ncmFtLCBmcmFnbWVudFNoYWRlcilcblxuICBnbC5saW5rUHJvZ3JhbShnbFByb2dyYW0pXG5cbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKGdsUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdXZWJHbFByb2dyYW0gbGluayBwYW5pYyEnKVxuICAgIGVyci53ZWJHbFByb2dyYW0gPSBwcm9ncmFtXG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXIvd2ViX2dsX3Byb2dyYW0uanMiLCJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdsVW5pZm9ybSB7XG4gIGNvbnN0cnVjdG9yIChwcm9ncmFtLCBpbmRleCkge1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1cbiAgICB0aGlzLmdseCA9IHByb2dyYW0uZ2x4XG5cbiAgICBjb25zdCB7IGdsIH0gPSBwcm9ncmFtLmdseFxuICAgIGNvbnN0IHsgZ2xQcm9ncmFtIH0gPSBwcm9ncmFtXG5cbiAgICBjb25zdCB7IG5hbWUsIHNpemUsIHR5cGUgfSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oZ2xQcm9ncmFtLCBpbmRleClcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5zaXplID0gc2l6ZVxuICAgIHRoaXMudHlwZSA9IHR5cGVcblxuICAgIHRoaXMubG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2xQcm9ncmFtLCBuYW1lKVxuXG4gICAgdGhpcy5zZXRWYWx1ZSA9IHVuaWZvcm1TZXR0ZXIodGhpcylcblxuICAgIE9iamVjdC5mcmVlemUodGhpcylcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmlmb3JtU2V0dGVyICh1bmlmb3JtKSB7XG4gIGNvbnN0IHsgdHlwZSwgbG9jYXRpb24gfSA9IHVuaWZvcm1cbiAgY29uc3QgeyBnbCB9ID0gdW5pZm9ybS5nbHhcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGdsLkZMT0FUOlxuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSlcblxuICAgIGNhc2UgZ2wuRkxPQVRfVkVDMjpcbiAgICAgIHJldHVybiAodmFsdWUpID0+IGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdKVxuXG4gICAgY2FzZSBnbC5GTE9BVF9WRUMzOlxuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdKVxuXG4gICAgY2FzZSBnbC5GTE9BVF9WRUM0OlxuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZ2wudW5pZm9ybTRmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSlcblxuICAgIGNhc2UgZ2wuRkxPQVRfTUFUNDpcbiAgICAgIHJldHVybiAodmFsdWUpID0+IGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGdsLkZBTFNFLCB2YWx1ZS5tYXQ0KVxuXG4gICAgY2FzZSBnbC5TQU1QTEVSXzJEOlxuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSlcbiAgfVxuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgV2ViR2xVbmlmb3JtIHVua25vd24gdW5pZm9ybSB0eXBlOiR7dHlwZX1gKVxuICBlcnIud2ViR2xVbmlmb3JtID0gdW5pZm9ybVxuICB0aHJvdyBlcnJcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXIvd2ViX2dsX3VuaWZvcm0uanMiLCJpbXBvcnQgeyBHTF9JVEVNX1RZUEVTIH0gZnJvbSAnLi4vdXRpbHMvdHlwZWRfYXJyYXlfaGVscGVycydcblxuY29uc3QgZ2xUeXBlID0gKGdsLCB0eXBlKSA9PiBnbFtHTF9JVEVNX1RZUEVTW3R5cGVdXVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHbEF0dHJpYnV0ZSB7XG4gIGNvbnN0cnVjdG9yIChwcm9ncmFtLCBpbmRleCkge1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1cbiAgICB0aGlzLmdseCA9IHByb2dyYW0uZ2x4XG5cbiAgICBjb25zdCB7IGdsIH0gPSBwcm9ncmFtLmdseFxuICAgIGNvbnN0IHsgZ2xQcm9ncmFtIH0gPSBwcm9ncmFtXG5cbiAgICBjb25zdCB7IG5hbWUsIHNpemUsIHR5cGUgfSA9IGdsLmdldEFjdGl2ZUF0dHJpYihnbFByb2dyYW0sIGluZGV4KVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnNpemUgPSBzaXplXG4gICAgdGhpcy50eXBlID0gdHlwZVxuXG4gICAgdGhpcy5sb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKGdsUHJvZ3JhbSwgbmFtZSlcblxuICAgIE9iamVjdC5mcmVlemUodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZPRGVzY3JpcHRvcn0gZGVzY3JpcHRvclxuICAgKi9cbiAgdmVydGV4QXR0cmliUG9pbnRlciAoZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuZ2x4XG4gICAgY29uc3QgYXR0ciA9IGRlc2NyaXB0b3IuYXR0clt0aGlzLm5hbWVdXG4gICAgY29uc3QgdHlwZSA9IGdsVHlwZShnbCwgYXR0ci50eXBlKVxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5sb2NhdGlvbiwgYXR0ci5zaXplLCB0eXBlLCBmYWxzZSwgZGVzY3JpcHRvci5ieXRlc1BlclZlcnRleCwgYXR0ci5ieXRlT2Zmc2V0KVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL3dlYl9nbF9hdHRyaWJ1dGUuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdsVGV4dHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdsQ29udGV4dH0gZ2x4XG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nRWxcbiAgICogQHBhcmFtIHtib29sZWFufSBbZmxpcFk9ZmFsc2VdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGVhdGFibGU9ZmFsc2VdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZW11bHRpcGx5QWxwaGE9ZmFsc2VdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25lYXJlc3Q9ZmFsc2VdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZ2x4LCBpbWdFbCwgZmxpcFkgPSBmYWxzZSwgcmVwZWF0YWJsZSA9IGZhbHNlLCBwcmVtdWx0aXBseUFscGhhID0gZmFsc2UsIG5lYXJlc3QgPSBmYWxzZSkge1xuICAgIHRoaXMuZ2x4ID0gZ2x4XG4gICAgdGhpcy5pbWdFbCA9IGltZ0VsXG5cbiAgICB0aGlzLmZsaXBZID0gZmxpcFlcbiAgICB0aGlzLnJlcGVhdGFibGUgPSByZXBlYXRhYmxlXG4gICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYVxuICAgIHRoaXMubmVhcmVzdCA9IG5lYXJlc3RcblxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlXG4gICAgdGhpcy5nbFRleE9iaiA9IGdseC5nbC5jcmVhdGVUZXh0dXJlKClcbiAgICB0aGlzLnRleFVuaXQgPSAtMVxuICB9XG5cbiAgYmluZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x4LnRleHR1cmVNYW5hZ2VyLmJpbmRXZWJHbFRleHR1cmUodGhpcylcbiAgfVxuXG4gIHVwbG9hZEltYWdlRGF0YSAoKSB7XG4gICAgaWYgKHRoaXMuaW1nRWwgPT0gbnVsbCkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGluaXRpYWxpemUodGhpcylcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLmJpbmQoKVxuXG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5nbHhcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1nRWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZSAodGV4KSB7XG4gIHRleC5iaW5kKClcblxuICBjb25zdCB7IGdsIH0gPSB0ZXguZ2x4XG5cbiAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4LmZsaXBZKVxuICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleC5wcmVtdWx0aXBseUFscGhhKVxuXG4gIGNvbnN0IHdyYXAgPSB0ZXgucmVwZWF0YWJsZSA/IGdsLlJFUEVBVCA6IGdsLkNMQU1QX1RPX0VER0VcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgd3JhcClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgd3JhcClcblxuICBjb25zdCBmaWx0ZXIgPSB0ZXgubmVhcmVzdCA/IGdsLk5FQVJFU1QgOiBnbC5MSU5FQVJcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcilcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcilcblxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleC5pbWdFbC53aWR0aCwgdGV4LmltZ0VsLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbClcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXIvd2ViX2dsX3RleHR1cmUuanMiLCJpbXBvcnQgZGVzdHJveSBmcm9tICcuLi91dGlscy9kZXN0cm95J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHbFRleHR1cmVNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViR2xDb250ZXh0fSBnbHhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChnbHgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dseCcsIHsgdmFsdWU6IGdseCB9KVxuXG4gICAgLyoqXG4gICAgICogdGV4VW5pdCAtPiBXZWJHbFRleHR1cmVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kVGV4dHVyZXMgPSBuZXcgQXJyYXkoZ2x4Lk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RCb3VuZFRleFVuaXQgPSAwXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoID0gMFxuICAgIGRlc3Ryb3kodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIGEgKnRleHR1cmUqIHRvIGEgKnRleHR1cmUgdW5pdCouXG4gICAqIEBwYXJhbSB7V2ViR2xUZXh0dXJlfSBnbFRleHR1cmVcbiAgICogQHJldHVybiB7bnVtYmVyfSB0ZXh0dXJlIHVuaXRcbiAgICovXG4gIGJpbmRXZWJHbFRleHR1cmUgKGdsVGV4dHVyZSkge1xuICAgIGxldCB0ZXhVbml0ID0gdGhpcy5ib3VuZFRleHR1cmVzLmluZGV4T2YoZ2xUZXh0dXJlKVxuXG4gICAgaWYgKHRleFVuaXQgPCAwKSB7XG4gICAgICAvLyB0ZXh0dXJlIGlzIHVuYm91bmRcbiAgICAgIC8vIGZpbmQgYSBmcmVlIHRleHR1cmUgdW5pdCAuLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kVGV4dHVyZXNbaV0pIHtcbiAgICAgICAgICB0ZXhVbml0ID0gaVxuICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IGdsVGV4dHVyZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRleFVuaXQgPCAwKSB7XG4gICAgICAgIC8vIG5vIGZyZWUgdGV4dHVyZSBmb3VuZFxuICAgICAgICAvLyBzbyB3ZSBjaG9vc2UgdGhlIGxydSB0ZXh0dXJlIHVuaXRcblxuICAgICAgICB0ZXhVbml0ID0gdGhpcy5sYXN0Qm91bmRUZXhVbml0XG5cbiAgICAgICAgbGV0IHByZXZHbFRleCA9IHRoaXMuYm91bmRUZXh0dXJlc1t0ZXhVbml0XVxuICAgICAgICBpZiAocHJldkdsVGV4KSBwcmV2R2xUZXgudGV4VW5pdCA9IC0xXG5cbiAgICAgICAgdGhpcy5sYXN0Qm91bmRUZXhVbml0ID0gKHRoaXMubGFzdEJvdW5kVGV4VW5pdCArIDEpICUgdGhpcy5nbHguTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFNcbiAgICAgIH1cblxuICAgICAgdGhpcy5nbHguYWN0aXZlVGV4dHVyZSh0ZXhVbml0KVxuICAgICAgdGhpcy5nbHguYmluZFRleHR1cmUyZChnbFRleHR1cmUuZ2xUZXhPYmopXG5cbiAgICAgIGdsVGV4dHVyZS50ZXhVbml0ID0gdGV4VW5pdFxuICAgIH1cblxuICAgIHJldHVybiB0ZXhVbml0XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXIvd2ViX2dsX3RleHR1cmVfbWFuYWdlci5qcyIsImltcG9ydCBTaGFkZXJDb250ZXh0IGZyb20gJy4uL2NvcmUvc2hhZGVyX2NvbnRleHQnXG5pbXBvcnQgZGVzdHJveSBmcm9tICcuLi91dGlscy9kZXN0cm95J1xuXG5jb25zdCBldmVudGl6ZSA9IHJlcXVpcmUoJ0BzcGVhcndvbGYvZXZlbnRpemUnKVxuY29uc3QgdGlueWNvbG9yID0gcmVxdWlyZSgndGlueWNvbG9yMicpXG5cbmNvbnN0IGF1dG90b3VjaEJ1ZmZlciA9IChyZW5kZXJlciwgcmVzb3VyY2VSZWYpID0+IHtcbiAgY29uc3QgeyByZXNvdXJjZSB9ID0gcmVzb3VyY2VSZWZcbiAgaWYgKHJlc291cmNlLmVuYWJsZUF1dG90b3VjaCkge1xuICAgIGlmICghcmVuZGVyZXIuYXV0b3RvdWNoUmVzb3VyY2VzLmhhcyhyZXNvdXJjZVJlZi5pZCkpIHtcbiAgICAgIHJlbmRlcmVyLmF1dG90b3VjaFJlc291cmNlcy5zZXQocmVzb3VyY2VSZWYuaWQsIHRydWUpXG4gICAgICByZXNvdXJjZS50b3VjaCgpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGFwcGx5QmxlbmRNb2RlID0gKHJlbmRlcmVyKSA9PiB7XG4gIGNvbnN0IGJsZW5kTW9kZSA9IHJlbmRlcmVyLmJsZW5kU3RhY2tbcmVuZGVyZXIuYmxlbmRTdGFjay5sZW5ndGggLSAxXSB8fCByZW5kZXJlci5pbml0aWFsQmxlbmRNb2RlXG4gIGlmIChibGVuZE1vZGUgJiYgIWJsZW5kTW9kZS5pc0VxdWFsKHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUpKSB7XG4gICAgcmVuZGVyZXIuZ2x4LmJsZW5kKGJsZW5kTW9kZSlcbiAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gYmxlbmRNb2RlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR2xSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yIChnbHgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dseCcsIHsgdmFsdWU6IGdseCB9KVxuXG4gICAgdGhpcy5zaGFkZXJDb250ZXh0ID0gbmV3IFNoYWRlckNvbnRleHQoKVxuICAgIHRoaXMuYXV0b3RvdWNoUmVzb3VyY2VzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5jbGVhckNvbG9yID0gbnVsbFxuICAgIHRoaXMuYmxlbmRTdGFjayA9IFtdXG4gICAgdGhpcy5pbml0aWFsQmxlbmRNb2RlID0gbnVsbFxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IG51bGxcblxuICAgIGV2ZW50aXplKHRoaXMpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnNoYWRlckNvbnRleHQuZGVzdHJveSgpXG4gICAgdGhpcy5hdXRvdG91Y2hSZXNvdXJjZXMuY2xlYXIoKVxuICAgIHRoaXMuYmxlbmRTdGFjay5sZW5ndGggPSAwXG4gICAgZGVzdHJveSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZnJhbWVidWZmZXIgY2xlYXIgY29sb3IuXG4gICAqIFVzZSB0aGUgKnRpbnljb2xvciogbGlicmFyeSBmb3IgY3NzIGNvbG9yIGNvbnZlcnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2wgLSBjc3MgY29sb3IgZGVmaW5pdGlvblxuICAgKi9cbiAgc2V0Q2xlYXJDb2xvciAoY29sKSB7XG4gICAgdGhpcy5jbGVhckNvbG9yID0gdGlueWNvbG9yKGNvbClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGluaXRpYWwgYmxlbmQgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtCbGVuZE1vZGV9IGJsZW5kTW9kZVxuICAgKi9cbiAgc2V0SW5pdGlhbEJsZW5kTW9kZSAoYmxlbmRNb2RlKSB7XG4gICAgdGhpcy5pbml0aWFsQmxlbmRNb2RlID0gYmxlbmRNb2RlXG4gIH1cblxuICByZW5kZXJGcmFtZSAoc2NlbmUsIGFwcCkge1xuICAgIHRoaXMuc2hhZGVyQ29udGV4dC5jbGVhcigpXG4gICAgc2NlbmUuZW1pdCgnYW5pbWF0ZUZyYW1lJywgYXBwKVxuICAgIHRoaXMuYmVnaW5SZW5kZXJGcmFtZSgpXG4gICAgc2NlbmUuZW1pdCgncmVuZGVyRnJhbWUnLCB0aGlzLCBhcHApXG4gICAgdGhpcy5lbmRSZW5kZXJGcmFtZSgpXG4gIH1cblxuICBiZWdpblJlbmRlckZyYW1lICgpIHtcbiAgICB0aGlzLmNsZWFyRnJhbWVCdWZmZXIoKVxuICB9XG5cbiAgZW5kUmVuZGVyRnJhbWUgKCkge1xuICAgIHRoaXMuYXV0b3RvdWNoUmVzb3VyY2VzLmNsZWFyKClcbiAgfVxuXG4gIGNsZWFyRnJhbWVCdWZmZXIgKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuZ2x4XG5cbiAgICBsZXQgY2xlYXIgPSBnbC5DT0xPUl9CVUZGRVJfQklUXG4gICAgaWYgKHRoaXMuZ2x4LkRFUFRIX0JJVFMgPiAwKSBjbGVhciA9IGNsZWFyIHwgZ2wuREVQVEhfQlVGRkVSX0JJVFxuXG4gICAgaWYgKHRoaXMuY2xlYXJDb2xvciAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY29sID0gdGhpcy5jbGVhckNvbG9yLnRvUmdiKClcbiAgICAgIGdsLmNsZWFyQ29sb3IoY29sLnIgLyAyNTUsIGNvbC5nIC8gMjU1LCBjb2wuYiAvIDI1NSwgY29sLmEpXG4gICAgfVxuICAgIGdsLmNsZWFyKGNsZWFyKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBuZXcgYmxlbmQgbW9kZSB0byB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7QmxlbmRNb2RlfSBibGVuZE1vZGVcbiAgICovXG4gIHB1c2hCbGVuZE1vZGUgKGJsZW5kTW9kZSkge1xuICAgIHRoaXMuYmxlbmRTdGFjay5wdXNoKGJsZW5kTW9kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGN1cnJlbnQgYmxlbmQgbW9kZSBmcm9tIGludGVybmFsIHN0YWNrLlxuICAgKiBUaGUgaW5pdGlhbCBibGVuZCBtb2RlIGNhbid0IGJlIHJlbW92ZWQuXG4gICAqL1xuICBwb3BCbGVuZE1vZGUgKCkge1xuICAgIHRoaXMuYmxlbmRTdGFjay5wb3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2hhZGVyUHJvZ3JhbX0gc2hhZGVyUHJvZ3JhbVxuICAgKi9cbiAgdXNlU2hhZGVyUHJvZ3JhbSAoc2hhZGVyUHJvZ3JhbSkge1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdseC5yZXNvdXJjZUxpYnJhcnkubG9hZFByb2dyYW0oc2hhZGVyUHJvZ3JhbSlcbiAgICBjb25zdCB7IHNoYWRlckNvbnRleHQgfSA9IHRoaXNcbiAgICBwcm9ncmFtLnVzZShzaGFkZXJDb250ZXh0KVxuICAgIHByb2dyYW0ubG9hZFVuaWZvcm1zKHNoYWRlckNvbnRleHQsIHRoaXMpXG4gICAgcHJvZ3JhbS5sb2FkQXR0cmlidXRlcyhzaGFkZXJDb250ZXh0LCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltaXRpdmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRJbmRleD0wXVxuICAgKi9cbiAgZHJhd0FycmF5cyAocHJpbWl0aXZlLCBjb3VudCwgc3RhcnRJbmRleCA9IDApIHtcbiAgICBhcHBseUJsZW5kTW9kZSh0aGlzKVxuXG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5nbHhcbiAgICBnbC5kcmF3QXJyYXlzKGdsW3ByaW1pdGl2ZV0sIHN0YXJ0SW5kZXgsIGNvdW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltaXRpdmVcbiAgICogQHBhcmFtIHtFbGVtZW50SW5kZXhBcnJheX0gZWxlbWVudEluZGV4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIGRyYXdJbmRleGVkIChwcmltaXRpdmUsIGVsZW1lbnRJbmRleEFycmF5LCBjb3VudCwgb2Zmc2V0ID0gMCkge1xuICAgIGFwcGx5QmxlbmRNb2RlKHRoaXMpXG4gICAgdGhpcy5zeW5jQnVmZmVyKGVsZW1lbnRJbmRleEFycmF5KS5iaW5kQnVmZmVyKClcblxuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuZ2x4XG4gICAgZ2wuZHJhd0VsZW1lbnRzKFxuICAgICAgZ2xbcHJpbWl0aXZlXSxcbiAgICAgIGNvdW50IHx8IGVsZW1lbnRJbmRleEFycmF5Lmxlbmd0aCxcbiAgICAgIGdsLlVOU0lHTkVEX1NIT1JULFxuICAgICAgb2Zmc2V0ICogZWxlbWVudEluZGV4QXJyYXkuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtWT0FycmF5fEVsZW1lbnRJbmRleEFycmF5fSByZXNvdXJjZVxuICAgKiBAcmV0dXJuIHtXZWJHbEJ1ZmZlcn1cbiAgICovXG4gIHN5bmNCdWZmZXIgKHJlc291cmNlKSB7XG4gICAgY29uc3QgeyByZXNvdXJjZVJlZiB9ID0gcmVzb3VyY2VcbiAgICBhdXRvdG91Y2hCdWZmZXIodGhpcywgcmVzb3VyY2VSZWYpXG5cbiAgICBjb25zdCBidWZmZXJSZWYgPSB0aGlzLmdseC5yZXNvdXJjZUxpYnJhcnkubG9hZEJ1ZmZlcihyZXNvdXJjZVJlZilcbiAgICBidWZmZXJSZWYuc3luYyhyZXNvdXJjZVJlZiwgYnVmZmVyID0+IGJ1ZmZlci5idWZmZXJEYXRhKHJlc291cmNlUmVmLmhpbnRzLnR5cGVkQXJyYXkpKVxuICAgIHJldHVybiBidWZmZXJSZWYucmVzb3VyY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmVcbiAgICogQHJldHVybiB7V2ViR2xUZXh0dXJlfVxuICAgKi9cbiAgc3luY1RleHR1cmUgKHRleHR1cmUpIHtcbiAgICBjb25zdCB0ZXhSZWYgPSB0ZXh0dXJlLnJlc291cmNlUmVmXG4gICAgY29uc3QgZ2xUZXhSZWYgPSB0aGlzLmdseC5yZXNvdXJjZUxpYnJhcnkubG9hZFRleHR1cmUodGV4UmVmKVxuICAgIGdsVGV4UmVmLnN5bmModGV4UmVmLCB0ZXggPT4gdGV4LnVwbG9hZEltYWdlRGF0YSgpKVxuICAgIHJldHVybiBnbFRleFJlZi5yZXNvdXJjZVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL3dlYl9nbF9yZW5kZXJlci5qcyIsImltcG9ydCBwYXJzZUNzc1N0eWxlZFByb3BlcnRpZXMgZnJvbSAnLi4vdXRpbHMvcGFyc2VDc3NTdHlsZWRQcm9wZXJ0aWVzLmpzJ1xuXG5pbXBvcnQgUHJvamVjdGlvbkNvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudHMvUHJvamVjdGlvbkNvbXBvbmVudCdcbmltcG9ydCBDaGlsZHJlbkNvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudHMvQ2hpbGRyZW5Db21wb25lbnQnXG5pbXBvcnQgQmxlbmRNb2RlQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9CbGVuZE1vZGVDb21wb25lbnQnXG5cbmNvbnN0IGNyZWF0ZUZhY3RvcnkgPSAoQ29tcG9uZW50Q29uc3RydWN0b3IpID0+ICh7XG4gIGNyZWF0ZSAoZW50aXR5LCBkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnRDb25zdHJ1Y3RvcihlbnRpdHksIHBhcnNlQ3NzU3R5bGVkUHJvcGVydGllcyhkYXRhKSlcbiAgfSxcbiAgdXBkYXRlIChjb21wb25lbnQsIGRhdGEpIHtcbiAgICBjb21wb25lbnQudXBkYXRlKHBhcnNlQ3NzU3R5bGVkUHJvcGVydGllcyhkYXRhKSlcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XG4gIHJlZ2lzdHJ5LnJlZ2lzdGVyQ29tcG9uZW50KCdwcm9qZWN0aW9uJywgY3JlYXRlRmFjdG9yeShQcm9qZWN0aW9uQ29tcG9uZW50KSlcbiAgcmVnaXN0cnkucmVnaXN0ZXJDb21wb25lbnQoJ2NoaWxkcmVuJywgY3JlYXRlRmFjdG9yeShDaGlsZHJlbkNvbXBvbmVudCkpXG4gIHJlZ2lzdHJ5LnJlZ2lzdGVyQ29tcG9uZW50KCdibGVuZC1tb2RlJywgY3JlYXRlRmFjdG9yeShCbGVuZE1vZGVDb21wb25lbnQpKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RvbS9yZWdpc3RlckRlZmF1bHRDb21wb25lbnRzLmpzIiwiaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi4vLi4vY29yZS9wcm9qZWN0aW9uJ1xuXG5pbXBvcnQgeyBDT01QX1BSSU9fUFJPSkVDVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdGlvbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChlbnRpdHksIGRhdGEpIHtcbiAgICB0aGlzLnByb2plY3Rpb24gPSBuZXcgUHJvamVjdGlvbihkYXRhKVxuICAgIGVudGl0eS5vbignKicsIENPTVBfUFJJT19QUk9KRUNUSU9OLCB0aGlzKVxuICB9XG5cbiAgYW5pbWF0ZUZyYW1lIChhcHApIHtcbiAgICB0aGlzLnByb2plY3Rpb24udXBkYXRlKGFwcC53aWR0aCwgYXBwLmhlaWdodClcbiAgfVxuXG4gIHJlbmRlckZyYW1lIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnNoYWRlckNvbnRleHQucHVzaFZhcih0aGlzLnByb2plY3Rpb24udW5pZm9ybSlcbiAgfVxuXG4gIGRlYnVnICgpIHtcbiAgICBjb25zb2xlLmRpcih0aGlzLnByb2plY3Rpb24pXG4gIH1cblxuICB1cGRhdGUgKGRhdGEpIHtcbiAgICBjb25zb2xlLmxvZygnVE9ETyBQcm9qZWN0aW9uQ29tcG9uZW50LnVwZGF0ZSgnLCBkYXRhLCAnKScpXG4gIH1cblxuICBkaXNjb25uZWN0ZWRFbnRpdHkgKGVudGl0eSkge1xuICAgIGNvbnNvbGUubG9nKCdQcm9qZWN0aW9uQ29tcG9uZW50LmRpc2Nvbm5lY3RlZEVudGl0eSgnLCBlbnRpdHksICcpJylcbiAgICBlbnRpdHkub2ZmKHRoaXMpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vY29tcG9uZW50cy9Qcm9qZWN0aW9uQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuLy8gRU5EIEhFQURFUlxuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9nbC1tYXRyaXgvY29tbW9uXCI7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gXCIuL2dsLW1hdHJpeC9tYXQyXCI7XG5pbXBvcnQgKiBhcyBtYXQyZCBmcm9tIFwiLi9nbC1tYXRyaXgvbWF0MmRcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDNcIjtcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDRcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vZ2wtbWF0cml4L3F1YXRcIjtcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSBcIi4vZ2wtbWF0cml4L3ZlYzJcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vZ2wtbWF0cml4L3ZlYzNcIjtcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSBcIi4vZ2wtbWF0cml4L3ZlYzRcIjtcblxuZXhwb3J0IHtcbiAgZ2xNYXRyaXgsXG4gIG1hdDIsIG1hdDJkLCBtYXQzLCBtYXQ0LFxuICBxdWF0LFxuICB2ZWMyLCB2ZWMzLCB2ZWM0LFxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiXG5cbi8qKlxuICogMngyIE1hdHJpeFxuICogQG1vZHVsZSBtYXQyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZVxuICAvLyBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgbGV0IGExID0gYVsxXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGExO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhWzFdO1xuICAgIG91dFszXSA9IGFbM107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgbGV0IGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9ICBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9ICBhMCAqIGRldDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgbGV0IGEwID0gYVswXTtcbiAgb3V0WzBdID0gIGFbM107XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gIGEwO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF07XG4gIFVbMF0gPSBhWzBdO1xuICBVWzFdID0gYVsxXTtcbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTtcbiAgcmV0dXJuIFtMLCBELCBVXTtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpKTtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0Mi5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDJ4MyBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0MmRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXG4gKlxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhYSA9IGFbMF0sIGFiID0gYVsxXSwgYWMgPSBhWzJdLCBhZCA9IGFbM107XG4gIGxldCBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gIGxldCBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgaWYoIWRldCl7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTA7XG4gIG91dFsxXSA9IGExO1xuICBvdXRbMl0gPSBhMjtcbiAgb3V0WzNdID0gYTM7XG4gIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdlswXTtcbiAgb3V0WzVdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgK1xuICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyZC5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDR4NCBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0NFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgICBsZXQgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgICBsZXQgYTIzID0gYVsxMV07XG5cbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGxldCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGxldCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGxldCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGxldCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gIGxldCBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG4gIGxldCBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIGxldCBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIGxldCBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdO1xuICBsZXQgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIGxldCBzLCBjLCB0O1xuICBsZXQgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICBsZXQgYTEwLCBhMTEsIGExMiwgYTEzO1xuICBsZXQgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICBsZXQgYjAwLCBiMDEsIGIwMjtcbiAgbGV0IGIxMCwgYjExLCBiMTI7XG4gIGxldCBiMjAsIGIyMSwgYjIyO1xuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG5cbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG5cbiAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgbGV0IGExMCA9IGFbNF07XG4gIGxldCBhMTEgPSBhWzVdO1xuICBsZXQgYTEyID0gYVs2XTtcbiAgbGV0IGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdO1xuICBsZXQgYTIxID0gYVs5XTtcbiAgbGV0IGEyMiA9IGFbMTBdO1xuICBsZXQgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdICA9IGFbMF07XG4gICAgb3V0WzFdICA9IGFbMV07XG4gICAgb3V0WzJdICA9IGFbMl07XG4gICAgb3V0WzNdICA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBsZXQgYTAwID0gYVswXTtcbiAgbGV0IGEwMSA9IGFbMV07XG4gIGxldCBhMDIgPSBhWzJdO1xuICBsZXQgYTAzID0gYVszXTtcbiAgbGV0IGEyMCA9IGFbOF07XG4gIGxldCBhMjEgPSBhWzldO1xuICBsZXQgYTIyID0gYVsxMF07XG4gIGxldCBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gID0gYVs0XTtcbiAgICBvdXRbNV0gID0gYVs1XTtcbiAgICBvdXRbNl0gID0gYVs2XTtcbiAgICBvdXRbN10gID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIGxldCBhMDAgPSBhWzBdO1xuICBsZXQgYTAxID0gYVsxXTtcbiAgbGV0IGEwMiA9IGFbMl07XG4gIGxldCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XTtcbiAgbGV0IGExMSA9IGFbNV07XG4gIGxldCBhMTIgPSBhWzZdO1xuICBsZXQgYTEzID0gYVs3XTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdICA9IGFbOF07XG4gICAgb3V0WzldICA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdO1xuICBsZXQgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIGxldCBzLCBjLCB0O1xuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG5cbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG5cbiAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSAxO1xuICBvdXRbMV0gID0gMDtcbiAgb3V0WzJdICA9IDA7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAtcztcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSBjO1xuICBvdXRbMV0gID0gMDtcbiAgb3V0WzJdICA9IC1zO1xuICBvdXRbM10gID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gcztcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSBjO1xuICBvdXRbMV0gID0gcztcbiAgb3V0WzJdICA9IDA7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXG4gKiAgd2l0aCBhIG5vcm1hbGl6ZWQgUXVhdGVybmlvbiBwYXJhbXRlciwgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgbGV0IG0xMSA9IG1hdFswXTtcbiAgbGV0IG0xMiA9IG1hdFsxXTtcbiAgbGV0IG0xMyA9IG1hdFsyXTtcbiAgbGV0IG0yMSA9IG1hdFs0XTtcbiAgbGV0IG0yMiA9IG1hdFs1XTtcbiAgbGV0IG0yMyA9IG1hdFs2XTtcbiAgbGV0IG0zMSA9IG1hdFs4XTtcbiAgbGV0IG0zMiA9IG1hdFs5XTtcbiAgbGV0IG0zMyA9IG1hdFsxMF07XG5cbiAgb3V0WzBdID0gTWF0aC5zcXJ0KG0xMSAqIG0xMSArIG0xMiAqIG0xMiArIG0xMyAqIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguc3FydChtMjEgKiBtMjEgKyBtMjIgKiBtMjIgKyBtMjMgKiBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLnNxcnQobTMxICogbTMxICsgbTMyICogbTMyICsgbTMzICogbTMzKTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIC8vIEFsZ29yaXRobSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gIGxldCB0cmFjZSA9IG1hdFswXSArIG1hdFs1XSArIG1hdFsxMF07XG4gIGxldCBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICB9IGVsc2UgaWYgKChtYXRbMF0gPiBtYXRbNV0pJihtYXRbMF0gPiBtYXRbMTBdKSkge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzBdIC0gbWF0WzVdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICB9IGVsc2UgaWYgKG1hdFs1XSA+IG1hdFsxMF0pIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFs1XSAtIG1hdFswXSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTO1xuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFsxMF0gLSBtYXRbMF0gLSBtYXRbNV0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcbiAgbGV0IHN4ID0gc1swXTtcbiAgbGV0IHN5ID0gc1sxXTtcbiAgbGV0IHN6ID0gc1syXTtcblxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBsZXQgc3ggPSBzWzBdO1xuICBsZXQgc3kgPSBzWzFdO1xuICBsZXQgc3ogPSBzWzJdO1xuXG4gIGxldCBveCA9IG9bMF07XG4gIGxldCBveSA9IG9bMV07XG4gIGxldCBveiA9IG9bMl07XG5cbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB5eCA9IHkgKiB4MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgenggPSB6ICogeDI7XG4gIGxldCB6eSA9IHogKiB5MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuXG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuXG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG5cbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICBsZXQgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIGxldCB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcbiAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIGxldCBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpO1xuICBsZXQgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgbGV0IHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCk7XG4gIGxldCB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgbGV0IHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgbGV0IGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICBsZXQgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIGxldCBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIGxldCB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIGxldCBleWV4ID0gZXllWzBdO1xuICBsZXQgZXlleSA9IGV5ZVsxXTtcbiAgbGV0IGV5ZXogPSBleWVbMl07XG4gIGxldCB1cHggPSB1cFswXTtcbiAgbGV0IHVweSA9IHVwWzFdO1xuICBsZXQgdXB6ID0gdXBbMl07XG4gIGxldCBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICBsZXQgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgbGV0IGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG5cbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgbGV0IGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcblxuICBsZXQgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgICAgejIgPSBleWV6IC0gdGFyZ2V0WzJdO1xuXG4gIGxldCBsZW4gPSB6MCp6MCArIHoxKnoxICsgejIqejI7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG5cbiAgbGV0IHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MixcbiAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgK1xuICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICBvdXRbOF0gPSBhWzhdICsgKGJbOF0gKiBzY2FsZSk7XG4gIG91dFs5XSA9IGFbOV0gKyAoYls5XSAqIHNjYWxlKTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgKGJbMTBdICogc2NhbGUpO1xuICBvdXRbMTFdID0gYVsxMV0gKyAoYlsxMV0gKiBzY2FsZSk7XG4gIG91dFsxMl0gPSBhWzEyXSArIChiWzEyXSAqIHNjYWxlKTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgKGJbMTNdICogc2NhbGUpO1xuICBvdXRbMTRdID0gYVsxNF0gKyAoYlsxNF0gKiBzY2FsZSk7XG4gIG91dFsxNV0gPSBhWzE1XSArIChiWzE1XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmXG4gICAgICAgICBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmXG4gICAgICAgICBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJlxuICAgICAgICAgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCAgPSBhWzBdLCAgYTEgID0gYVsxXSwgIGEyICA9IGFbMl0sICBhMyAgPSBhWzNdO1xuICBsZXQgYTQgID0gYVs0XSwgIGE1ICA9IGFbNV0sICBhNiAgPSBhWzZdLCAgYTcgID0gYVs3XTtcbiAgbGV0IGE4ICA9IGFbOF0sICBhOSAgPSBhWzldLCAgYTEwID0gYVsxMF0sIGExMSA9IGFbMTFdO1xuICBsZXQgYTEyID0gYVsxMl0sIGExMyA9IGFbMTNdLCBhMTQgPSBhWzE0XSwgYTE1ID0gYVsxNV07XG5cbiAgbGV0IGIwICA9IGJbMF0sICBiMSAgPSBiWzFdLCAgYjIgID0gYlsyXSwgIGIzICA9IGJbM107XG4gIGxldCBiNCAgPSBiWzRdLCAgYjUgID0gYls1XSwgIGI2ICA9IGJbNl0sICBiNyAgPSBiWzddO1xuICBsZXQgYjggID0gYls4XSwgIGI5ICA9IGJbOV0sICBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV07XG4gIGxldCBiMTIgPSBiWzEyXSwgYjEzID0gYlsxM10sIGIxNCA9IGJbMTRdLCBiMTUgPSBiWzE1XTtcblxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIlxuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzXCJcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjM1wiXG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzRcIlxuXG4vKipcbiAqIFF1YXRlcm5pb25cbiAqIEBtb2R1bGUgcXVhdFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LCBheGlzLCByYWQpIHtcbiAgcmFkID0gcmFkICogMC41O1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxuICogQHBhcmFtICB7cXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMsIHEpIHtcbiAgbGV0IHJhZCA9IE1hdGguYWNvcyhxWzNdKSAqIDIuMDtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuICBpZiAocyAhPSAwLjApIHtcbiAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgIG91dF9heGlzWzFdID0gcVsxXSAvIHM7XG4gICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgb3V0X2F4aXNbMV0gPSAwO1xuICAgIG91dF9heGlzWzJdID0gMDtcbiAgfVxuICByZXR1cm4gcmFkO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcblxuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuXG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG5cbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVcob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICAvLyBiZW5jaG1hcmtzOlxuICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gIGxldCBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAvLyBjYWxjIGNvc2luZVxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLSBieDtcbiAgICBieSA9IC0gYnk7XG4gICAgYnogPSAtIGJ6O1xuICAgIGJ3ID0gLSBidztcbiAgfVxuICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXG4gICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgc2NhbGUxID0gdDtcbiAgfVxuICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzO1xuICBsZXQgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG5cbiAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQzKG91dCwgbSkge1xuICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgbGV0IGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgbGV0IGZSb290O1xuXG4gIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgIG91dFsxXSA9IChtWzZdLW1bMl0pKmZSb290O1xuICAgIG91dFsyXSA9IChtWzFdLW1bM10pKmZSb290O1xuICB9IGVsc2Uge1xuICAgIC8vIHx3fCA8PSAxLzJcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICBpID0gMTtcbiAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICBpID0gMjtcbiAgICBsZXQgaiA9IChpKzEpJTM7XG4gICAgbGV0IGsgPSAoaSsyKSUzO1xuXG4gICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge3l9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWSBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge3p9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdWxlcihvdXQsIHgsIHksIHopIHtcbiAgICBsZXQgaGFsZlRvUmFkID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICAgIHggKj0gaGFsZlRvUmFkO1xuICAgIHkgKj0gaGFsZlRvUmFkO1xuICAgIHogKj0gaGFsZlRvUmFkO1xuXG4gICAgbGV0IHN4ID0gTWF0aC5zaW4oeCk7XG4gICAgbGV0IGN4ID0gTWF0aC5jb3MoeCk7XG4gICAgbGV0IHN5ID0gTWF0aC5zaW4oeSk7XG4gICAgbGV0IGN5ID0gTWF0aC5jb3MoeSk7XG4gICAgbGV0IHN6ID0gTWF0aC5zaW4oeik7XG4gICAgbGV0IGN6ID0gTWF0aC5jb3Moeik7XG5cbiAgICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgIG91dFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFscyA9IHZlYzQuZXF1YWxzO1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgY29uc3Qgcm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICBsZXQgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgbGV0IHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIGxldCBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICBpZiAodmVjMy5sZW4odG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICBzZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgICAgb3V0WzNdID0gMTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBjb25zdCBzcWxlcnAgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgdGVtcDEgPSBjcmVhdGUoKTtcbiAgbGV0IHRlbXAyID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBzbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvcXVhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQgKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoIChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpdiA9IGRpdmlkZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgdmVjID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIGxldCBpLCBsO1xuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZihjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzIuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDT01QX1BSSU9fQ0hJTERSRU4gfSBmcm9tICcuLi9jb25zdGFudHMnXG5cbmNvbnN0IGV2ZW50aXplID0gcmVxdWlyZSgnQHNwZWFyd29sZi9ldmVudGl6ZScpXG5cbmNvbnN0IFBSSU9fQkVGT1JFX0NISUxEUkVOID0gQ09NUF9QUklPX0NISUxEUkVOICsgMVxuY29uc3QgUFJJT19BRlRFUl9DSElMRFJFTiA9IENPTVBfUFJJT19DSElMRFJFTiAtIDFcblxuY2xhc3MgQmVmb3JlQ2hpbGRyZW4ge1xuICBjb25zdHJ1Y3RvciAoZW50aXR5KSB7XG4gICAgdGhpcy5lbnRpdHkgPSBlbnRpdHlcbiAgfVxuXG4gIHJlbmRlckZyYW1lIChyZW5kZXJlcikge1xuICAgIHRoaXMuZW50aXR5LmVtaXQoJ3JlbmRlckZyYW1lQmVmb3JlQ2hpbGRyZW4nLCByZW5kZXJlcilcbiAgfVxufVxuXG5jbGFzcyBBZnRlckNoaWxkcmVuIHtcbiAgY29uc3RydWN0b3IgKGVudGl0eSkge1xuICAgIHRoaXMuZW50aXR5ID0gZW50aXR5XG4gIH1cblxuICByZW5kZXJGcmFtZSAocmVuZGVyZXIpIHtcbiAgICB0aGlzLmVudGl0eS5lbWl0KCdyZW5kZXJGcmFtZUFmdGVyQ2hpbGRyZW4nLCByZW5kZXJlcilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGlsZHJlbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChlbnRpdHkpIHtcbiAgICBldmVudGl6ZSh0aGlzKVxuXG4gICAgdGhpcy5iZWZvcmVDaGlsZHJlbiA9IG5ldyBCZWZvcmVDaGlsZHJlbihlbnRpdHkpXG4gICAgdGhpcy5hZnRlckNoaWxkcmVuID0gbmV3IEFmdGVyQ2hpbGRyZW4oZW50aXR5KVxuXG4gICAgZW50aXR5Lm9uKCcqJywgQ09NUF9QUklPX0NISUxEUkVOLCB0aGlzKVxuICAgIGVudGl0eS5vbignKicsIFBSSU9fQkVGT1JFX0NISUxEUkVOLCB0aGlzLmJlZm9yZUNoaWxkcmVuKVxuICAgIGVudGl0eS5vbignKicsIFBSSU9fQUZURVJfQ0hJTERSRU4sIHRoaXMuYWZ0ZXJDaGlsZHJlbilcbiAgfVxuXG4gIHJlbmRlckZyYW1lQmVmb3JlQ2hpbGRyZW4gKCkge1xuICAgIC8vIGRvIG5vdCBpbmZvcm0gY2hpbGRyZW4gYWJvdXQgdGhpcyBldmVudCFcbiAgfVxuXG4gIHJlbmRlckZyYW1lQWZ0ZXJDaGlsZHJlbiAoKSB7XG4gICAgLy8gZG8gbm90IGluZm9ybSBjaGlsZHJlbiBhYm91dCB0aGlzIGV2ZW50IVxuICB9XG5cbiAgYXBwZW5kQ2hpbGQgKGVudGl0eSkge1xuICAgIGlmIChlbnRpdHkuaGFzQ29tcG9uZW50KCdwYXJlbnRFbnRpdHknKSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3lDb21wb25lbnQoJ3BhcmVudEVudGl0eScpXG4gICAgfVxuICAgIGVudGl0eS5zZXRDb21wb25lbnQoJ3BhcmVudEVudGl0eScsIHRoaXMpXG4gICAgdGhpcy5vbihlbnRpdHkpXG4gIH1cblxuICByZW1vdmVDaGlsZCAoZW50aXR5KSB7XG4gICAgdGhpcy5vZmYoZW50aXR5KVxuICAgIGVudGl0eS5kZXN0cm95Q29tcG9uZW50KCdwYXJlbnRFbnRpdHknKVxuICB9XG5cbiAgZGlzY29ubmVjdGVkRW50aXR5IChlbnRpdHkpIHtcbiAgICBjb25zb2xlLmxvZygnQ2hpbGRyZW5Db21wb25lbnQuZGlzY29ubmVjdGVkRW50aXR5KCcsIGVudGl0eSwgJyknKVxuICAgIGVudGl0eS5vZmYodGhpcy5hZnRlckNoaWxkcmVuKVxuICAgIGVudGl0eS5vZmYodGhpcy5iZWZvcmVDaGlsZHJlbilcbiAgICBlbnRpdHkub2ZmKHRoaXMpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vY29tcG9uZW50cy9DaGlsZHJlbkNvbXBvbmVudC5qcyIsImltcG9ydCBCbGVuZE1vZGUgZnJvbSAnLi4vLi4vY29yZS9ibGVuZF9tb2RlJ1xuXG5pbXBvcnQge1xuICBDT01QX1BSSU9fQkxFTkRfQkVGT1JFLFxuICBDT01QX1BSSU9fQkxFTkRfQUZURVJcbn0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuXG5jb25zdCBwYXJzZUJsZW5kTW9kZURhdGEgPSAoZGF0YSkgPT4gKHtcbiAgZW5hYmxlOiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gKFxuICAgIGRhdGEuZW5hYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFkYXRhLmVuYWJsZVxuICApIDogZmFsc2UpLFxuICBzZmFjdG9yOiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gKFxuICAgIHR5cGVvZiBkYXRhLnNmYWN0b3IgPT09ICdzdHJpbmcnID8gZGF0YS5zZmFjdG9yIDogJydcbiAgKSA6ICcnKSxcbiAgZGZhY3RvcjogKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IChcbiAgICB0eXBlb2YgZGF0YS5kZmFjdG9yID09PSAnc3RyaW5nJyA/IGRhdGEuZGZhY3RvciA6ICcnXG4gICkgOiAnJylcbn0pXG5cbmNsYXNzIEJlZm9yZUNoaWxkcmVuIHtcbiAgY29uc3RydWN0b3IgKGJsZW5kTW9kZSkge1xuICAgIHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlXG4gIH1cblxuICByZW5kZXJGcmFtZSAocmVuZGVyZXIpIHtcbiAgICByZW5kZXJlci5wdXNoQmxlbmRNb2RlKHRoaXMuYmxlbmRNb2RlKVxuICB9XG59XG5cbmNsYXNzIEFmdGVyQ2hpbGRyZW4ge1xuICByZW5kZXJGcmFtZSAocmVuZGVyZXIpIHtcbiAgICByZW5kZXJlci5wb3BCbGVuZE1vZGUoKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsZW5kTW9kZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChlbnRpdHksIGRhdGEpIHtcbiAgICBjb25zdCB7IGVuYWJsZSwgc2ZhY3RvciwgZGZhY3RvciB9ID0gcGFyc2VCbGVuZE1vZGVEYXRhKGRhdGEpXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBuZXcgQmxlbmRNb2RlKGVuYWJsZSwgc2ZhY3RvciwgZGZhY3RvcilcbiAgICB0aGlzLmJlZm9yZUNoaWxkcmVuID0gbmV3IEJlZm9yZUNoaWxkcmVuKHRoaXMuYmxlbmRNb2RlKVxuICAgIHRoaXMuYWZ0ZXJDaGlsZHJlbiA9IG5ldyBBZnRlckNoaWxkcmVuKClcbiAgICBlbnRpdHkub24oJyonLCBDT01QX1BSSU9fQkxFTkRfQkVGT1JFLCB0aGlzLmJlZm9yZUNoaWxkcmVuKVxuICAgIGVudGl0eS5vbignKicsIENPTVBfUFJJT19CTEVORF9BRlRFUiwgdGhpcy5hZnRlckNoaWxkcmVuKVxuICAgIGVudGl0eS5vbignZGVidWcnLCB0aGlzKVxuICB9XG5cbiAgZGVidWcgKCkge1xuICAgIGNvbnNvbGUuZGlyKHRoaXMuYmxlbmRNb2RlKVxuICB9XG5cbiAgdXBkYXRlIChkYXRhKSB7XG4gICAgY29uc3QgeyBlbmFibGUsIHNmYWN0b3IsIGRmYWN0b3IgfSA9IHBhcnNlQmxlbmRNb2RlRGF0YShkYXRhKVxuICAgIHRoaXMuYmxlbmRNb2RlLmVuYWJsZSA9IGVuYWJsZVxuICAgIHRoaXMuYmxlbmRNb2RlLnNmYWN0b3IgPSBzZmFjdG9yXG4gICAgdGhpcy5ibGVuZE1vZGUuZGZhY3RvciA9IGRmYWN0b3JcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZEVudGl0eSAoZW50aXR5KSB7XG4gICAgY29uc29sZS5sb2coJ0JsZW5kTW9kZUNvbXBvbmVudC5kaXNjb25uZWN0ZWRFbnRpdHkoJywgZW50aXR5LCAnKScpXG4gICAgZW50aXR5Lm9mZih0aGlzLmFmdGVyQ2hpbGRyZW4pXG4gICAgZW50aXR5Lm9mZih0aGlzLmJlZm9yZUNoaWxkcmVuKVxuICAgIGVudGl0eS5vZmYodGhpcylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RvbS9jb21wb25lbnRzL0JsZW5kTW9kZUNvbXBvbmVudC5qcyIsInZhciBjcmVhdGVDb21wb3VuZGVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQ29tcG91bmRlcicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb29fYmFyJ1xuICpcbiAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAqIC8vID0+ICdmb29fYmFyJ1xuICpcbiAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICogLy8gPT4gJ2Zvb19iYXInXG4gKi9cbnZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNuYWtlQ2FzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zbmFrZUNhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIGRlYnVyciA9IHJlcXVpcmUoJy4vZGVidXJyJyksXG4gICAgd29yZHMgPSByZXF1aXJlKCcuL3dvcmRzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIjtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG52YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29tcG91bmRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ29tcG91bmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVidXJyTGV0dGVyID0gcmVxdWlyZSgnLi9fZGVidXJyTGV0dGVyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVycjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJ1cnIuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVByb3BlcnR5T2YgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlPZicpO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVyckxldHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVidXJyTGV0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlPZi5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc2NpaVdvcmRzID0gcmVxdWlyZSgnLi9fYXNjaWlXb3JkcycpLFxuICAgIGhhc1VuaWNvZGVXb3JkID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZVdvcmQnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKSxcbiAgICB1bmljb2RlV29yZHMgPSByZXF1aXJlKCcuL191bmljb2RlV29yZHMnKTtcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd29yZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvd29yZHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqXG4gKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVdvcmRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVdvcmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xudmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGVXb3JkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNVbmljb2RlV29yZC5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKVxcXFxiKScsXG4gICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKVxcXFxiKScsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxO1xuXG4vKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xudmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgcnNPcmRVcHBlcixcbiAgcnNPcmRMb3dlcixcbiAgcnNEaWdpdHMsXG4gIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVdvcmRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlV29yZHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbmltcG9ydCBmaW5kUGFyZW50RWxlbWVudEJ5TmFtZSBmcm9tICcuLi9saWIvZmluZF9wYXJlbnRfZWxlbWVudF9ieV9uYW1lJ1xuXG5pbXBvcnQge1xuICBOT0RFX05BTUVfQ0FOVkFTLFxuICBOT0RFX05BTUVfU0NFTkVcbn0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuXG5jb25zdCBldmVudGl6ZSA9IHJlcXVpcmUoJ0BzcGVhcndvbGYvZXZlbnRpemUnKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yIChfKSB7XG4gICAgY29uc3Qgc2VsZiA9IHN1cGVyKF8pXG4gICAgcmV0dXJuIGV2ZW50aXplKHNlbGYpXG4gIH1cblxuICBnZXQgYmxpdHB1bmtOb2RlTmFtZSAoKSB7IHJldHVybiBOT0RFX05BTUVfU0NFTkUgfVxuXG4gIGdldCBibGl0cHVuayAoKSB7IHJldHVybiB0aGlzLmJsaXRwdW5rQ2FudmFzLmJsaXRwdW5rIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgIHRoaXMuYmxpdHB1bmtDYW52YXMgPSBmaW5kUGFyZW50RWxlbWVudEJ5TmFtZSh0aGlzLCBOT0RFX05BTUVfQ0FOVkFTKVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgICB0aGlzLmJsaXRwdW5rQ2FudmFzID0gbnVsbFxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZG9tL2VsZW1lbnRzL1NjZW5lRWxlbWVudC5qcyIsIi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuaW1wb3J0IGNvbm5lY3RFbGVtZW50RW50aXRpZXMgZnJvbSAnLi4vbGliL2Nvbm5lY3RFbGVtZW50RW50aXRpZXMuanMnXG5pbXBvcnQgZGlzY29ubmVjdEVsZW1lbnRFbnRpdGllcyBmcm9tICcuLi9saWIvZGlzY29ubmVjdEVsZW1lbnRFbnRpdGllcy5qcydcbmltcG9ydCByZWFkVGV4dHVyZUhpbnRzIGZyb20gJy4uL2xpYi9yZWFkVGV4dHVyZUhpbnRzLmpzJ1xuXG5pbXBvcnQge1xuICBOT0RFX05BTUVfVEVYVFVSRV9BVExBUyxcbiAgQVRUUl9TUkNcbn0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuXG5jb25zdCBldmVudGl6ZSA9IHJlcXVpcmUoJ0BzcGVhcndvbGYvZXZlbnRpemUnKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlQXRsYXNFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAvKiogQHByaXZhdGUgKi9cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiBbXG4gICAgICBBVFRSX1NSQ1xuICAgIF1cbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yIChfKSB7XG4gICAgY29uc3Qgc2VsZiA9IHN1cGVyKF8pXG4gICAgcmV0dXJuIGV2ZW50aXplKHNlbGYpXG4gIH1cblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgZ2V0IGJsaXRwdW5rTm9kZU5hbWUgKCkgeyByZXR1cm4gTk9ERV9OQU1FX1RFWFRVUkVfQVRMQVMgfVxuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBnZXQgdGV4dHVyZUlkICgpIHsgcmV0dXJuIHRoaXMuZW50aXR5ICYmIHRoaXMuZW50aXR5LmlkIH1cblxuICBsb2FkVGV4dHVyZUF0bGFzIChzcmMpIHtcbiAgICBpZiAoc3JjICYmIHRoaXMuZW50aXR5KSB7XG4gICAgICBpZiAodGhpcy5wcmV2VXJsICE9PSBzcmMpIHtcbiAgICAgICAgdGhpcy5wcmV2VXJsID0gc3JjXG4gICAgICAgIHRoaXMudGV4dHVyZUhpbnRzID0gcmVhZFRleHR1cmVIaW50cyh0aGlzKVxuICAgICAgICB0aGlzLnRleHR1cmVBdGxhc1Byb21pc2UgPSB0aGlzLnRleHR1cmVMaWJyYXJ5XG4gICAgICAgICAgLmxvYWRUZXh0dXJlQXRsYXModGhpcy50ZXh0dXJlSWQsIHNyYywgdGhpcy50ZXh0dXJlSGludHMpXG4gICAgICAgICAgLnRoZW4oKGF0bGFzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVBdGxhcyA9IGF0bGFzXG4gICAgICAgICAgICByZXR1cm4gYXRsYXNcbiAgICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQXRsYXNQcm9taXNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlYnVnICgpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnRleHR1cmVBdGxhcylcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBjb25uZWN0ZWRDYWxsYmFjayAoKSB7XG4gICAgY29ubmVjdEVsZW1lbnRFbnRpdGllcyh0aGlzKVxuICAgIHRoaXMudGV4dHVyZUxpYnJhcnkgPSB0aGlzLnBhcmVudFNjZW5lRWxlbWVudC50ZXh0dXJlTGlicmFyeSAgLy8gVE9ETyBmb3IgZXZlcnkgZWxlbWVudD9cbiAgICB0aGlzLmxvYWRUZXh0dXJlQXRsYXModGhpcy5nZXRBdHRyaWJ1dGUoQVRUUl9TUkMpKVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgICAvLyBUT0RPIGRpc2Nvbm5lY3RlZENhbGxiYWNrIDxibGl0cHVuay10ZXh0dXJlLWF0bGFzLz5cbiAgICB0aGlzLnRleHR1cmVBdGxhcyA9IG51bGxcbiAgICB0aGlzLnRleHR1cmVMaWJyYXJ5ID0gbnVsbFxuICAgIGRpc2Nvbm5lY3RFbGVtZW50RW50aXRpZXModGhpcylcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgKGF0dHIsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChhdHRyID09PSBBVFRSX1NSQykge1xuICAgICAgdGhpcy5sb2FkVGV4dHVyZUF0bGFzKG5ld1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RvbS9lbGVtZW50cy9UZXh0dXJlQXRsYXNFbGVtZW50LmpzIiwiaW1wb3J0IGZpbmRQYXJlbnRFbGVtZW50QnlOYW1lIGZyb20gJy4vZmluZF9wYXJlbnRfZWxlbWVudF9ieV9uYW1lJ1xuXG5pbXBvcnQge1xuICBOT0RFX05BTUVfQ0FOVkFTXG59IGZyb20gJy4uL2NvbnN0YW50cydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBmaW5kUGFyZW50RWxlbWVudEJ5TmFtZShlbCwgTk9ERV9OQU1FX0NBTlZBUylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vbGliL2ZpbmRCbGl0cHVua0NhbnZhc0VsZW1lbnQuanMiLCJjb25zdCBFWElUX05PREVTID0gWydCT0RZJywgJ0hUTUwnXVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kUGFyZW50RWxlbWVudEJ5UHJvcGVydHkgKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudFxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT09IDEpIHJldHVyblxuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBwYXJlbnRcbiAgaWYgKEVYSVRfTk9ERVMuaW5jbHVkZXMobm9kZU5hbWUpKSByZXR1cm5cbiAgaWYgKCh2YWx1ZSA9PSBudWxsICYmIHBhcmVudFtwcm9wXSkgfHwgKHZhbHVlICE9IG51bGwgJiYgcGFyZW50W3Byb3BdID09PSB2YWx1ZSkpIHJldHVybiBwYXJlbnRcbiAgcmV0dXJuIHBhcmVudFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RvbS9saWIvZmluZFBhcmVudEVsZW1lbnRCeVByb3BlcnR5LmpzIiwiaW1wb3J0IHJlYWRCb29sZWFuQXR0cmlidXRlIGZyb20gJy4vcmVhZEJvb2xlYW5BdHRyaWJ1dGUuanMnXG5cbmltcG9ydCB7XG4gIEFUVFJfRkxJUF9ZLFxuICBBVFRSX1JFUEVBVEFCTEUsXG4gIEFUVFJfUFJFTVVMVElQTFlfQUxQSEEsXG4gIEFUVFJfTkVBUkVTVFxufSBmcm9tICcuLi9jb25zdGFudHMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWRUZXh0dXJlSGludHMgKGVsKSB7XG4gIHJldHVybiB7XG4gICAgZmxpcFk6IHJlYWRCb29sZWFuQXR0cmlidXRlKGVsLCBBVFRSX0ZMSVBfWSwgZmFsc2UpLFxuICAgIHJlcGVhdGFibGU6IHJlYWRCb29sZWFuQXR0cmlidXRlKGVsLCBBVFRSX1JFUEVBVEFCTEUsIGZhbHNlKSxcbiAgICBwcmVtdWx0aXBseUFscGhhOiByZWFkQm9vbGVhbkF0dHJpYnV0ZShlbCwgQVRUUl9QUkVNVUxUSVBMWV9BTFBIQSwgdHJ1ZSksXG4gICAgbmVhcmVzdDogcmVhZEJvb2xlYW5BdHRyaWJ1dGUoZWwsIEFUVFJfTkVBUkVTVCwgZmFsc2UpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vbGliL3JlYWRUZXh0dXJlSGludHMuanMiLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbmltcG9ydCBTcHJpdGVHcm91cCBmcm9tICdzcmMvY29yZS9zcHJpdGVfZ3JvdXAnXG5cbmltcG9ydCBwYXJzZUNzc1N0eWxlZFByb3BlcnRpZXMgZnJvbSAnc3JjL3V0aWxzL3BhcnNlQ3NzU3R5bGVkUHJvcGVydGllcy5qcydcbmltcG9ydCBjcmVhdGVWb1Byb3BzU2V0dGVyIGZyb20gJ3NyYy91dGlscy9jcmVhdGVWb1Byb3BzU2V0dGVyLmpzJ1xuaW1wb3J0IGlzTm9uRW1wdHlTdHJpbmcgZnJvbSAnc3JjL3V0aWxzL2lzTm9uRW1wdHlTdHJpbmcuanMnXG5pbXBvcnQgaXNOdW1iZXJHcmVhdGVyVGhhblplcm8gZnJvbSAnc3JjL3V0aWxzL2lzTnVtYmVyR3JlYXRlclRoYW5aZXJvLmpzJ1xuXG5pbXBvcnQgY29ubmVjdEVsZW1lbnRFbnRpdGllcyBmcm9tICcuLi9saWIvY29ubmVjdEVsZW1lbnRFbnRpdGllcy5qcydcbmltcG9ydCBkaXNjb25uZWN0RWxlbWVudEVudGl0aWVzIGZyb20gJy4uL2xpYi9kaXNjb25uZWN0RWxlbWVudEVudGl0aWVzLmpzJ1xuaW1wb3J0IHN5bmNDb21wb25lbnQgZnJvbSAnLi4vbGliL3N5bmNDb21wb25lbnQuanMnXG5cbmltcG9ydCB7XG4gIE5PREVfTkFNRV9TUFJJVEVfR1JPVVAsXG4gIEFUVFJfREVTQ1JJUFRPUixcbiAgQVRUUl9WRVJURVhfU0hBREVSLFxuICBBVFRSX0ZSQUdNRU5UX1NIQURFUixcbiAgQVRUUl9QUklNSVRJVkUsXG4gIEFUVFJfQ0FQQUNJVFksXG4gIEFUVFJfQkxFTkRfTU9ERSxcbiAgQVRUUl9URVhUVVJFX01BUCxcbiAgQVRUUl9WT19ORVcsXG4gIEFUVFJfVk9fWkVST1xufSBmcm9tICcuLi9jb25zdGFudHMnXG5cbmNvbnN0IGV2ZW50aXplID0gcmVxdWlyZSgnQHNwZWFyd29sZi9ldmVudGl6ZScpXG5cbmNvbnN0IGNyZWF0ZUNvbmZpZyA9ICh7IGRlc2NyaXB0b3IsIGNhcGFjaXR5LCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwcmltaXRpdmUsIHZvTmV3LCB2b1plcm8gfSkgPT4gKHtcbiAgZGVzY3JpcHRvcixcbiAgdmVydGV4U2hhZGVyLFxuICBmcmFnbWVudFNoYWRlcixcbiAgcHJpbWl0aXZlLFxuICBjYXBhY2l0eTogcGFyc2VJbnQoY2FwYWNpdHksIDEwKSxcbiAgdm9OZXc6IGNyZWF0ZVZvUHJvcHNTZXR0ZXIodm9OZXcpLFxuICB2b1plcm86IGNyZWF0ZVZvUHJvcHNTZXR0ZXIodm9aZXJvKVxufSlcblxuLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgYWxsIG9wdGlvbnMgZnJvbSBzcmMvY29yZS9TcHJpdGVHcm91cFxuY29uc3QgcmVhZENvbmZpZ0Zyb21BdHRyaWJ1dGVzID0gKGVsKSA9PiBjcmVhdGVDb25maWcoe1xuICBkZXNjcmlwdG9yOiBlbC5nZXRBdHRyaWJ1dGUoQVRUUl9ERVNDUklQVE9SKSxcbiAgdmVydGV4U2hhZGVyOiBlbC5nZXRBdHRyaWJ1dGUoQVRUUl9WRVJURVhfU0hBREVSKSxcbiAgZnJhZ21lbnRTaGFkZXI6IGVsLmdldEF0dHJpYnV0ZShBVFRSX0ZSQUdNRU5UX1NIQURFUiksXG4gIHByaW1pdGl2ZTogZWwuZ2V0QXR0cmlidXRlKEFUVFJfUFJJTUlUSVZFKSxcbiAgY2FwYWNpdHk6IGVsLmdldEF0dHJpYnV0ZShBVFRSX0NBUEFDSVRZKSxcbiAgdm9OZXc6IGVsLmdldEF0dHJpYnV0ZShBVFRSX1ZPX05FVyksXG4gIHZvWmVybzogZWwuZ2V0QXR0cmlidXRlKEFUVFJfVk9fWkVSTylcbn0pXG5cbmNvbnN0IGlzVmFsaWRDb25maWcgPSAoY29uZmlnKSA9PiAoXG4gIGlzTm9uRW1wdHlTdHJpbmcoY29uZmlnLmRlc2NyaXB0b3IpICYmXG4gIGlzTm9uRW1wdHlTdHJpbmcoY29uZmlnLnZlcnRleFNoYWRlcikgJiZcbiAgaXNOb25FbXB0eVN0cmluZyhjb25maWcuZnJhZ21lbnRTaGFkZXIpICYmXG4gIGlzTm9uRW1wdHlTdHJpbmcoY29uZmlnLnByaW1pdGl2ZSkgJiZcbiAgaXNOdW1iZXJHcmVhdGVyVGhhblplcm8oY29uZmlnLmNhcGFjaXR5KVxuKVxuXG5jb25zdCBjcmVhdGVTcHJpdGVHcm91cCA9IChlbCkgPT4ge1xuICBpZiAoIWVsLnBhcmVudFNjZW5lKSByZXR1cm4gIC8vIFRPRE8gZmluZCBhIGJldHRlciB3YXlcbiAgY29uc3QgY29uZmlnID0gcmVhZENvbmZpZ0Zyb21BdHRyaWJ1dGVzKGVsKVxuICBpZiAoaXNWYWxpZENvbmZpZyhjb25maWcpKSB7XG4gICAgZWwuc3ByaXRlR3JvdXAgPSBuZXcgU3ByaXRlR3JvdXAoZWwucmVzb3VyY2VMaWJyYXJ5LCBlbC50ZXh0dXJlTGlicmFyeSwgY29uZmlnKVxuICAgIGVsLl9yZXNvbHZlUHJvbWlzZShlbC5zcHJpdGVHcm91cClcbiAgICBkZWxldGUgZWwuX3Jlc29sdmVQcm9taXNlXG4gIH1cbn1cblxuY29uc3Qgc3luY1RleHR1cmVNYXAgPSAoZWwsIGRhdGEpID0+IHtcbiAgY29uc3QgeyBzcHJpdGVHcm91cCB9ID0gZWxcbiAgaWYgKCFzcHJpdGVHcm91cCkgcmV0dXJuXG4gIGNvbnN0IHRleE1hcCA9IHBhcnNlQ3NzU3R5bGVkUHJvcGVydGllcyhkYXRhKVxuICBpZiAoIXRleE1hcCB8fCB0eXBlb2YgdGV4TWFwICE9PSAnb2JqZWN0JykgcmV0dXJuXG4gIGVsLnRleHR1cmVNYXAgPSB7fVxuICBPYmplY3Qua2V5cyh0ZXhNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gdGV4TWFwW2tleV1cbiAgICBjb25zdCB0ZXhFbCA9IGVsLmJsaXRwdW5rQ2FudmFzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgZWwudGV4dHVyZU1hcFtrZXldID0gdGV4RWwudGV4dHVyZUlkXG4gICAgc3ByaXRlR3JvdXAuc2V0VGV4dHVyZShrZXksIHRleEVsLnRleHR1cmVJZClcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlR3JvdXBFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAvKiogQHByaXZhdGUgKi9cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiBbXG4gICAgICBBVFRSX0JMRU5EX01PREUsXG4gICAgICBBVFRSX0NBUEFDSVRZLFxuICAgICAgQVRUUl9ERVNDUklQVE9SLFxuICAgICAgQVRUUl9GUkFHTUVOVF9TSEFERVIsXG4gICAgICBBVFRSX1BSSU1JVElWRSxcbiAgICAgIEFUVFJfVEVYVFVSRV9NQVAsXG4gICAgICBBVFRSX1ZFUlRFWF9TSEFERVJcbiAgICBdXG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3RvciAoXykge1xuICAgIGNvbnN0IHNlbGYgPSBzdXBlcihfKVxuICAgIHNlbGYuc3ByaXRlR3JvdXBQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHNlbGYuX3Jlc29sdmVQcm9taXNlID0gcmVzb2x2ZVxuICAgIH0pXG4gICAgcmV0dXJuIGV2ZW50aXplKHNlbGYpXG4gIH1cblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgZ2V0IGJsaXRwdW5rTm9kZU5hbWUgKCkgeyByZXR1cm4gTk9ERV9OQU1FX1NQUklURV9HUk9VUCB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlckZyYW1lIChyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLnNwcml0ZUdyb3VwKSB7XG4gICAgICB0aGlzLnNwcml0ZUdyb3VwLnJlbmRlckZyYW1lKHJlbmRlcmVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZWJ1ZyAoKSB7XG4gICAgY29uc29sZS5sb2codGhpcy5zcHJpdGVHcm91cClcbiAgICBpZiAodGhpcy50ZXh0dXJlTWFwKSBjb25zb2xlLmxvZyhBVFRSX1RFWFRVUkVfTUFQLCB0aGlzLnRleHR1cmVNYXApXG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgIGNvbm5lY3RFbGVtZW50RW50aXRpZXModGhpcylcblxuICAgIHRoaXMudGV4dHVyZUxpYnJhcnkgPSB0aGlzLnBhcmVudFNjZW5lRWxlbWVudC50ZXh0dXJlTGlicmFyeVxuICAgIHRoaXMucmVzb3VyY2VMaWJyYXJ5ID0gdGhpcy5wYXJlbnRTY2VuZUVsZW1lbnQucmVzb3VyY2VMaWJyYXJ5XG5cbiAgICBjcmVhdGVTcHJpdGVHcm91cCh0aGlzKVxuICAgIHN5bmNUZXh0dXJlTWFwKHRoaXMsIHRoaXMuZ2V0QXR0cmlidXRlKEFUVFJfVEVYVFVSRV9NQVApKVxuICAgIHN5bmNDb21wb25lbnQodGhpcywgQVRUUl9CTEVORF9NT0RFKVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgICAvLyBUT0RPIGRpc2Nvbm5lY3RlZENhbGxiYWNrIDxibGl0cHVuay1zcHJpdGUtZ3JvdXAvPlxuICAgIHRoaXMudGV4dHVyZU1hcCA9IG51bGxcbiAgICB0aGlzLnNwcml0ZUdyb3VwID0gbnVsbFxuICAgIHRoaXMudGV4dHVyZUxpYnJhcnkgPSBudWxsXG4gICAgdGhpcy5yZXNvdXJjZUxpYnJhcnkgPSBudWxsXG4gICAgZGlzY29ubmVjdEVsZW1lbnRFbnRpdGllcyh0aGlzKVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAoYXR0ciwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICBjYXNlIEFUVFJfVEVYVFVSRV9NQVA6XG4gICAgICAgIHN5bmNUZXh0dXJlTWFwKHRoaXMsIG5ld1ZhbHVlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBVFRSX0JMRU5EX01PREU6XG4gICAgICAgIHN5bmNDb21wb25lbnQodGhpcywgYXR0cilcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICghdGhpcy5zcHJpdGVHcm91cCkge1xuICAgICAgICAgIGNyZWF0ZVNwcml0ZUdyb3VwKHRoaXMpXG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vZWxlbWVudHMvU3ByaXRlR3JvdXBFbGVtZW50LmpzIiwiXG4vKipcbiAqIFByZS1hbGxvY2F0ZSBhIGJ1bmNoIG9mIHZlcnRleCBvYmplY3RzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZvUG9vbCwgbWF4QWxsb2NTaXplID0gMCkge1xuICBjb25zdCBtYXggPSB2b1Bvb2wuY2FwYWNpdHkgLSB2b1Bvb2wudXNlZENvdW50IC0gdm9Qb29sLmFsbG9jYXRlZENvdW50XG4gIGNvbnN0IGxlbiA9IHZvUG9vbC5hbGxvY2F0ZWRDb3VudCArIChtYXhBbGxvY1NpemUgPiAwICYmIG1heEFsbG9jU2l6ZSA8IG1heCA/IG1heEFsbG9jU2l6ZSA6IG1heClcblxuICBmb3IgKGxldCBpID0gdm9Qb29sLmFsbG9jYXRlZENvdW50OyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgdm9BcnJheSA9IHZvUG9vbC52b0FycmF5LnN1YmFycmF5KGkpXG5cbiAgICBsZXQgdmVydGV4T2JqZWN0ID0gdm9Qb29sLmRlc2NyaXB0b3IuY3JlYXRlVk8odm9BcnJheSlcbiAgICB2ZXJ0ZXhPYmplY3QuZnJlZSA9IHZvUG9vbC5mcmVlLmJpbmQodm9Qb29sLCB2ZXJ0ZXhPYmplY3QpXG5cbiAgICB2b1Bvb2wuYXZhaWxhYmxlVk9zLnB1c2godmVydGV4T2JqZWN0KVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29yZS92X29fcG9vbC9jcmVhdGVfdmVydGV4X29iamVjdHMuanMiLCJ2YXIgYmFzZVBpY2sgPSByZXF1aXJlKCcuL19iYXNlUGljaycpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvcGljay5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHBhcnNlQ3NzU3R5bGVkUHJvcGVydGllcyBmcm9tICcuL3BhcnNlQ3NzU3R5bGVkUHJvcGVydGllcy5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVm9Qcm9wc1NldHRlciAodm9EYXRhKSB7XG4gIGlmICghdm9EYXRhKSByZXR1cm5cbiAgY29uc3Qgdm9Qcm9wcyA9IHBhcnNlQ3NzU3R5bGVkUHJvcGVydGllcyh2b0RhdGEpXG4gIGlmICghdm9Qcm9wcyB8fCB0eXBlb2Ygdm9Qcm9wcyAhPT0gJ29iamVjdCcpIHJldHVyblxuICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKHZvUHJvcHMpXG4gIHJldHVybiAodm8pID0+IHtcbiAgICBhdHRyS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJEZXNjID0gdm8uZGVzY3JpcHRvci5hdHRyW2tleV1cbiAgICAgIGlmIChhdHRyRGVzYykge1xuICAgICAgICBhdHRyRGVzYy5zZXRWYWx1ZSh2bywgdm9Qcm9wc1trZXldKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygdm9ba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2b1trZXldKHZvUHJvcHNba2V5XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZvW2tleV0gPSB2b1Byb3BzW2tleV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvY3JlYXRlVm9Qcm9wc1NldHRlci5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNOb25FbXB0eVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiBzdHIubGVuZ3RoID4gMFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2lzTm9uRW1wdHlTdHJpbmcuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTnVtYmVyR3JlYXRlclRoYW5aZXJvIChudW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIG51bSA+IDBcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9pc051bWJlckdyZWF0ZXJUaGFuWmVyby5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3luY0NvbXBvbmVudCAoZWwsIG5hbWUpIHtcbiAgaWYgKGVsLmJsaXRwdW5rID09IG51bGwpIHJldHVyblxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIG5hbWUuZm9yRWFjaChzeW5jQ29tcG9uZW50LmJpbmQobnVsbCwgZWwpKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGRhdGEgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgaWYgKGRhdGEgPT0gbnVsbCkgcmV0dXJuXG4gIGVsLmJsaXRwdW5rLmNvbXBvbmVudFJlZ2lzdHJ5LmNyZWF0ZU9yVXBkYXRlQ29tcG9uZW50KGVsLmVudGl0eSwgbmFtZSwgZGF0YSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kb20vbGliL3N5bmNDb21wb25lbnQuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL2JsaXRwdW5rLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi9ibGl0cHVuay5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vYmxpdHB1bmsuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZG9tL2JsaXRwdW5rLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJibGl0cHVuay1jYW52YXMge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZm9udC1zaXplOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDsgfVxcbiAgYmxpdHB1bmstY2FudmFzID4gY2FudmFzIHtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxuICAgIHRvdWNoLWFjdGlvbjogbm9uZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbmJsaXRwdW5rLXNjZW5lLFxcbmJsaXRwdW5rLXRleHR1cmUtYXRsYXMsXFxuYmxpdHB1bmstc3ByaXRlLWdyb3VwIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliIS4vc3JjL2RvbS9ibGl0cHVuay5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAoc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBBcHAgZnJvbSAnLi9hcHAnXG5cbmltcG9ydCBWT0Rlc2NyaXB0b3IgZnJvbSAnLi9jb3JlL3Zfb19kZXNjcmlwdG9yJ1xuaW1wb3J0IFZPUG9vbCBmcm9tICcuL2NvcmUvdl9vX3Bvb2wnXG5pbXBvcnQgQUFCQjIgZnJvbSAnLi9jb3JlL2FhYmIyJ1xuaW1wb3J0IEJsZW5kTW9kZSBmcm9tICcuL2NvcmUvYmxlbmRfbW9kZSdcbmltcG9ydCBFbGVtZW50SW5kZXhBcnJheSBmcm9tICcuL2NvcmUvZWxlbWVudF9pbmRleF9hcnJheSdcbmltcG9ydCBQb3dlck9mMkltYWdlIGZyb20gJy4vY29yZS9wb3dlcl9vZl8yX2ltYWdlJ1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9jb3JlL3Byb2plY3Rpb24nXG5pbXBvcnQgUmVzb3VyY2VMaWJyYXJ5IGZyb20gJy4vY29yZS9yZXNvdXJjZV9saWJyYXJ5J1xuaW1wb3J0IFNoYWRlckF0dHJpYlZhbHVlIGZyb20gJy4vY29yZS9zaGFkZXJfYXR0cmliX3ZhbHVlJ1xuaW1wb3J0IFNoYWRlckF0dHJpYlZhcmlhYmxlIGZyb20gJy4vY29yZS9zaGFkZXJfYXR0cmliX3ZhcmlhYmxlJ1xuaW1wb3J0IFNoYWRlckNvbnRleHQgZnJvbSAnLi9jb3JlL3NoYWRlcl9jb250ZXh0J1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9jb3JlL3NoYWRlcl9wcm9ncmFtJ1xuaW1wb3J0IFNoYWRlclNvdXJjZSBmcm9tICcuL2NvcmUvc2hhZGVyX3NvdXJjZSdcbmltcG9ydCBTaGFkZXJUZXh0dXJlMmRWYXJpYWJsZSBmcm9tICcuL2NvcmUvc2hhZGVyX3RleHR1cmVfMmRfdmFyaWFibGUnXG5pbXBvcnQgU2hhZGVyVGV4dHVyZUdyb3VwIGZyb20gJy4vY29yZS9zaGFkZXJfdGV4dHVyZV9ncm91cCdcbmltcG9ydCBTaGFkZXJVbmlmb3JtVmFyaWFibGUgZnJvbSAnLi9jb3JlL3NoYWRlcl91bmlmb3JtX3ZhcmlhYmxlJ1xuaW1wb3J0IFNoYWRlclZhcmlhYmxlIGZyb20gJy4vY29yZS9zaGFkZXJfdmFyaWFibGUnXG5pbXBvcnQgU2hhZGVyVmFyaWFibGVBbGlhcyBmcm9tICcuL2NvcmUvc2hhZGVyX3ZhcmlhYmxlX2FsaWFzJ1xuaW1wb3J0IFNoYWRlclZhcmlhYmxlQnVmZmVyR3JvdXAgZnJvbSAnLi9jb3JlL3NoYWRlcl92YXJpYWJsZV9idWZmZXJfZ3JvdXAnXG5pbXBvcnQgU2hhZGVyVmFyaWFibGVHcm91cCBmcm9tICcuL2NvcmUvc2hhZGVyX3ZhcmlhYmxlX2dyb3VwJ1xuaW1wb3J0IFNwcml0ZUdyb3VwIGZyb20gJy4vY29yZS9zcHJpdGVfZ3JvdXAnXG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2NvcmUvdGV4dHVyZSdcbmltcG9ydCBUZXh0dXJlQXRsYXMgZnJvbSAnLi9jb3JlL3RleHR1cmVfYXRsYXMnXG5pbXBvcnQgVGV4dHVyZUF0bGFzU3BlYyBmcm9tICcuL2NvcmUvdGV4dHVyZV9hdGxhc19zcGVjJ1xuaW1wb3J0IFRleHR1cmVMaWJyYXJ5IGZyb20gJy4vY29yZS90ZXh0dXJlX2xpYnJhcnknXG5pbXBvcnQgVGV4dHVyZVN0YXRlIGZyb20gJy4vY29yZS90ZXh0dXJlX3N0YXRlJ1xuaW1wb3J0IFZPQXJyYXkgZnJvbSAnLi9jb3JlL3Zfb19hcnJheSdcbmltcG9ydCBWT0F0dHJEZXNjcmlwdG9yIGZyb20gJy4vY29yZS92X29fYXR0cl9kZXNjcmlwdG9yJ1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vY29yZS9WaWV3cG9ydCdcblxuaW1wb3J0IENvbXBvbmVudFJlZ2lzdHJ5IGZyb20gJy4vZWNzL2NvbXBvbmVudF9yZWdpc3RyeSdcbmltcG9ydCBFbnRpdHkgZnJvbSAnLi9lY3MvZW50aXR5J1xuaW1wb3J0IEVudGl0eU1hbmFnZXIgZnJvbSAnLi9lY3MvZW50aXR5X21hbmFnZXInXG5cbmltcG9ydCBnZW5lcmF0ZVV1aWQgZnJvbSAnLi91dGlscy9nZW5lcmF0ZV91dWlkJ1xuaW1wb3J0IE1hdDQgZnJvbSAnLi91dGlscy9tYXQ0J1xuaW1wb3J0IHsgbWF4T2YsIGZpbmROZXh0UG93ZXJPZjIsIGlzUG93ZXJPZjIgfSBmcm9tICcuL3V0aWxzL21hdGhfaGVscGVycydcbmltcG9ydCBwYXJzZUNzc1N0eWxlZFByb3BlcnRpZXMgZnJvbSAnLi91dGlscy9wYXJzZUNzc1N0eWxlZFByb3BlcnRpZXMnXG5pbXBvcnQgc2FtcGxlIGZyb20gJy4vdXRpbHMvc2FtcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFwcCxcblxuICAvLyBjb3JlXG4gIEFBQkIyLFxuICBCbGVuZE1vZGUsXG4gIEVsZW1lbnRJbmRleEFycmF5LFxuICBQb3dlck9mMkltYWdlLFxuICBQcm9qZWN0aW9uLFxuICBSZXNvdXJjZUxpYnJhcnksXG4gIFNoYWRlckF0dHJpYlZhbHVlLFxuICBTaGFkZXJBdHRyaWJWYXJpYWJsZSxcbiAgU2hhZGVyQ29udGV4dCxcbiAgU2hhZGVyUHJvZ3JhbSxcbiAgU2hhZGVyU291cmNlLFxuICBTaGFkZXJUZXh0dXJlMmRWYXJpYWJsZSxcbiAgU2hhZGVyVGV4dHVyZUdyb3VwLFxuICBTaGFkZXJVbmlmb3JtVmFyaWFibGUsXG4gIFNoYWRlclZhcmlhYmxlLFxuICBTaGFkZXJWYXJpYWJsZUFsaWFzLFxuICBTaGFkZXJWYXJpYWJsZUJ1ZmZlckdyb3VwLFxuICBTaGFkZXJWYXJpYWJsZUdyb3VwLFxuICBTcHJpdGVHcm91cCxcbiAgVGV4dHVyZSxcbiAgVGV4dHVyZUF0bGFzLFxuICBUZXh0dXJlQXRsYXNTcGVjLFxuICBUZXh0dXJlTGlicmFyeSxcbiAgVGV4dHVyZVN0YXRlLFxuICBWT0FycmF5LFxuICBWT0F0dHJEZXNjcmlwdG9yLFxuICBWT0Rlc2NyaXB0b3IsXG4gIFZPUG9vbCxcbiAgVmlld3BvcnQsXG5cbiAgLy8gZWNzXG4gIENvbXBvbmVudFJlZ2lzdHJ5LFxuICBFbnRpdHksXG4gIEVudGl0eU1hbmFnZXIsXG5cbiAgLy8gdXRpbHNcbiAgTWF0NCxcbiAgZmluZE5leHRQb3dlck9mMixcbiAgZ2VuZXJhdGVVdWlkLFxuICBpc1Bvd2VyT2YyLFxuICBtYXhPZixcbiAgcGFyc2VDc3NTdHlsZWRQcm9wZXJ0aWVzLFxuICBzYW1wbGVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkuanMiLCJpbXBvcnQgQUFCQjIgZnJvbSAnLi9hYWJiMidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBBQUJCMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgbWluWCA9IHBhcnNlSW50KHgsIDEwKVxuICAgIGNvbnN0IG1pblkgPSBwYXJzZUludCh5LCAxMClcblxuICAgIHN1cGVyKFxuICAgICAgbWluWCwgKG1pblggKyBwYXJzZUludCh3aWR0aCwgMTApIC0gMSksXG4gICAgICBtaW5ZLCAobWluWSArIHBhcnNlSW50KGhlaWdodCwgMTApIC0gMSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB4ICgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCB4ICh4KSB7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGhcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5YID0geFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhYID0geCArIHcgLSAxXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5ZXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCB5ICh5KSB7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWSA9IHlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WSA9IHkgKyBoIC0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGggKCkge1xuICAgIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblggKyAxXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCB3aWR0aCAodykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhYID0gdGhpcy5taW5YICsgdyAtIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WSAtIHRoaXMubWluWSArIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IGhlaWdodCAoaCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhZID0gdGhpcy5taW5ZICsgaCAtIDFcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvcmUvVmlld3BvcnQuanMiXSwic291cmNlUm9vdCI6IiJ9

/***/ })

});