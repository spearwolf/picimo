## API Report File for "picimo"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BufferGeometry } from 'three';
import { Camera } from 'three';
import { Group } from 'three';
import { InstancedBufferGeometry } from 'three';
import { Material } from 'three';
import { Mesh } from 'three';
import { OrthographicCamera } from 'three';
import { PerspectiveCamera } from 'three';
import { Scene } from 'three';
import { ShaderMaterial } from 'three';
import { Texture as Texture_2 } from 'three';
import { TextureFilter } from 'three';
import * as THREE_2 from 'three';
import { Vector2 } from 'three';
import { Vector3 } from 'three';
import { Vector4 } from 'three';
import { WebGLRenderer } from 'three';
import { WebGLRendererParameters } from 'three';

// @public
export class AABB2 {
    constructor(left: number, top: number, width: number, height: number);
    // (undocumented)
    get bottom(): number;
    // (undocumented)
    get centerX(): number;
    // (undocumented)
    get centerY(): number;
    // (undocumented)
    clone(): AABB2;
    // (undocumented)
    height: number;
    // (undocumented)
    isInside(x: number, y: number): boolean;
    // (undocumented)
    isIntersecting(aabb: AABB2): boolean;
    // (undocumented)
    isNorthEast(x: number, y: number): boolean;
    // (undocumented)
    isNorthWest(x: number, y: number): boolean;
    // (undocumented)
    isSouthEast(x: number, y: number): boolean;
    // (undocumented)
    isSouthWest(x: number, y: number): boolean;
    // (undocumented)
    left: number;
    // (undocumented)
    get right(): number;
    // (undocumented)
    top: number;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export function base64toUint32Arr(base64: string, isLittleEndian?: boolean): Uint32Array;

// @public (undocumented)
export interface BitmapChar {
    // (undocumented)
    baselineOffset: number;
    // (undocumented)
    height: number;
    // (undocumented)
    maxS: number;
    // (undocumented)
    maxT: number;
    // (undocumented)
    originS: number;
    // (undocumented)
    originT: number;
    // (undocumented)
    originX: number;
    // (undocumented)
    originY: number;
    // (undocumented)
    setPos: (oiginX: number, originY: number, width: number, height: number) => void;
    // (undocumented)
    setTex: (oiginS: number, originT: number, maxS: number, maxT: number) => void;
    // (undocumented)
    width: number;
    // (undocumented)
    zPos: number;
}

// @public (undocumented)
export interface BitmapCharBase {
    // (undocumented)
    s0: number;
    // (undocumented)
    s1: number;
    // (undocumented)
    s2: number;
    // (undocumented)
    s3: number;
    // (undocumented)
    setPosition: (x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number) => void;
    // (undocumented)
    setUv: (u0: number, v0: number, u1: number, v1: number, u2: number, v2: number, u3: number, v3: number) => void;
    // (undocumented)
    t0: number;
    // (undocumented)
    t1: number;
    // (undocumented)
    t2: number;
    // (undocumented)
    t3: number;
    // (undocumented)
    x0: number;
    // (undocumented)
    x1: number;
    // (undocumented)
    x2: number;
    // (undocumented)
    x3: number;
    // (undocumented)
    y0: number;
    // (undocumented)
    y1: number;
    // (undocumented)
    y2: number;
    // (undocumented)
    y3: number;
}

// @public (undocumented)
export type BitmapCharBaseDescriptorType = VODescriptor<BitmapCharBaseMethodsType, BitmapCharBase>;

// @public (undocumented)
export class BitmapCharBaseGroup extends SpriteGroup<BitmapCharBaseMethodsType, BitmapCharBase> {
    constructor(options?: BitmapCharBaseGroupOptions);
}

// @public (undocumented)
export interface BitmapCharBaseGroupOptions {
    // (undocumented)
    capacity?: number;
    // (undocumented)
    dynamic?: boolean;
}

// @public (undocumented)
export const BitmapCharBaseMethods: {
    setSize(this: BitmapCharBase, w: number, h: number): void;
};

// @public (undocumented)
export type BitmapCharBaseMethodsType = typeof BitmapCharBaseMethods;

// @public (undocumented)
export type BitmapCharBaseVertexObject = VertexObject<BitmapCharBaseMethodsType, BitmapCharBase>;

// @public (undocumented)
export type BitmapCharDescriptorType = VODescriptor<BitmapCharMethodsType, BitmapChar>;

// @public (undocumented)
export class BitmapCharGroup extends SpriteGroupTextured<BitmapCharMethodsType, BitmapChar> {
    constructor(options?: BitmapCharGroupOptions);
}

// @public (undocumented)
export interface BitmapCharGroupOptions {
    // (undocumented)
    capacity?: number;
    // (undocumented)
    dynamic?: boolean;
}

// @public (undocumented)
export const BitmapCharMethods: {
    setTexCoordsByTexture(this: BitmapChar, { minS, minT, maxS, maxT, }: {
        minS: number;
        minT: number;
        maxS: number;
        maxT: number;
    }): void;
    setSize(this: BitmapChar, w: number, h: number): void;
    translate(this: BitmapChar, x: number, y: number, z: number): void;
};

// @public (undocumented)
export type BitmapCharMethodsType = typeof BitmapCharMethods;

// @public (undocumented)
export type BitmapCharVertexObject = VertexObject<BitmapCharMethodsType, BitmapChar>;

// @public (undocumented)
export class BitmapFontMaterial extends THREE_2.ShaderMaterial {
    constructor(fontTexture: THREE_2.Texture, shaderHooks?: BitmapFontShaderHooks);
}

// @public (undocumented)
export interface BitmapFontShaderHooks {
    // (undocumented)
    vertexShaderPreHook?: string;
    // (undocumented)
    vertexShaderTransformHook?: string;
}

// Warning: (ae-forgotten-export) The symbol "Eventize" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface BitmapText2D extends Eventize {
}

// @public (undocumented)
export class BitmapText2D extends SpriteGroupMesh<BitmapCharMethodsType, BitmapChar, BitmapCharBaseMethodsType, BitmapCharBase> {
    constructor(options?: BitmapText2DOptions);
    // (undocumented)
    bitmapChars: BitmapCharGroup;
    // (undocumented)
    createText(measure: BitmapText2DMeasurement, x: number, y: number, z: number, fontSize: number, hAlign: TextAlignH, vAlign: TextAlignV, spriteCache?: BitmapCharVertexObject[]): BitmapCharVertexObject[];
    // (undocumented)
    dispose(): void;
    // (undocumented)
    disposeMaterial(): void;
    // (undocumented)
    drawText(text: string, x: number, y: number, z: number, maxWidth?: number, fontSize?: number, lineGap?: number, hAlign?: TextAlignH, vAlign?: TextAlignV, spriteCache?: BitmapCharVertexObject[]): import("../sprites").VertexObject<{
        setTexCoordsByTexture(this: BitmapChar, { minS, minT, maxS, maxT, }: {
            minS: number;
            minT: number;
            maxS: number;
            maxT: number;
        }): void;
        setSize(this: BitmapChar, w: number, h: number): void;
        translate(this: BitmapChar, x: number, y: number, z: number): void;
    }, BitmapChar>[];
    // (undocumented)
    get fontAtlas(): TextureAtlas;
    set fontAtlas(fontAtlas: TextureAtlas);
    // (undocumented)
    fontSize: number;
    // (undocumented)
    hSpacing: number;
    // (undocumented)
    lineGap: number;
    // (undocumented)
    lineHeight: number;
    // (undocumented)
    material: BitmapFontMaterial;
    // (undocumented)
    measureText(text: string, maxWidth?: number, fontSize?: number, lineGap?: number): BitmapText2DMeasurement;
    // (undocumented)
    texture: THREE_2.Texture;
    // (undocumented)
    whiteSpaceWidth: number;
}

// @public (undocumented)
export class BitmapText2DBlock {
    constructor(bitmapText2D: BitmapText2D, position: [number, number, number], maxWidth?: number, fontSize?: number, lineGap?: number, hAlign?: TextAlignH, vAlign?: TextAlignV);
    // (undocumented)
    readonly bitmapText2D: BitmapText2D;
    // (undocumented)
    clear(): void;
    // (undocumented)
    get fontSize(): number;
    set fontSize(fontSize: number);
    // (undocumented)
    get hAlign(): TextAlignH;
    set hAlign(align: TextAlignH);
    // (undocumented)
    get lineGap(): number;
    set lineGap(lineGap: number);
    // (undocumented)
    get maxWidth(): number;
    set maxWidth(maxWidth: number);
    // (undocumented)
    needsUpdate: boolean;
    // (undocumented)
    get position(): [number, number, number];
    set position([x, y, z]: [number, number, number]);
    // (undocumented)
    sprites: BitmapCharVertexObject[];
    // (undocumented)
    text: string;
    // (undocumented)
    update(text?: string): void;
    // (undocumented)
    get vAlign(): TextAlignV;
    set vAlign(align: TextAlignV);
    // (undocumented)
    get x(): number;
    set x(x: number);
    // (undocumented)
    get y(): number;
    set y(y: number);
    // (undocumented)
    get z(): number;
    set z(z: number);
    }

// @public (undocumented)
export interface BitmapText2DChar {
    bo: number;
    // (undocumented)
    tex: Texture;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export interface BitmapText2DLine {
    // (undocumented)
    chars: BitmapText2DChar[];
    // (undocumented)
    lineWidth: number;
}

// @public (undocumented)
export interface BitmapText2DMeasurement {
    // (undocumented)
    charCount: number;
    // (undocumented)
    height: number;
    // (undocumented)
    lines: BitmapText2DLine[];
    // (undocumented)
    maxLineWidth: number;
}

// @public (undocumented)
export interface BitmapText2DOptions extends BitmapCharGroupOptions, BitmapFontShaderHooks {
}

// @public (undocumented)
export class Display extends Eventize {
    constructor(el: HTMLElement, options?: DisplayOptions & WebGLRendererParameters);
    // (undocumented)
    readonly canvas: HTMLCanvasElement;
    deltaTime: number;
    frameNo: number;
    height: number;
    lastNow: number;
    now: number;
    // (undocumented)
    pause: boolean;
    // (undocumented)
    get pixelRatio(): number;
    // (undocumented)
    readonly renderer: WebGLRenderer;
    // (undocumented)
    renderFrame(now?: number): void;
    // (undocumented)
    resize(): void;
    // (undocumented)
    resizeStrategy: DisplayResizeStrategy;
    // (undocumented)
    get stage(): Stage2D;
    set stage(stage: Stage2D);
    // (undocumented)
    start(): void;
    // (undocumented)
    stop(): void;
    // (undocumented)
    readonly textureFactory: TextureFactory;
    width: number;
}

// @public (undocumented)
export interface DisplayEventOptions {
    // (undocumented)
    display: Display;
    // (undocumented)
    height: number;
    // (undocumented)
    stage: Stage2D;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export type DisplayGetSizeFn = (display: Display) => {
    width: number;
    height: number;
};

// @public (undocumented)
export enum DisplayMode {
    // (undocumented)
    AAPerformance = "antialias-performance",
    // (undocumented)
    AAQuality = "antialias-quality",
    // (undocumented)
    Pixelated = "pixelated"
}

// @public (undocumented)
export interface DisplayOnFrameOptions extends DisplayEventOptions {
    // (undocumented)
    deltaTime: number;
    // (undocumented)
    frameNo: number;
    // (undocumented)
    now: number;
}

// @public (undocumented)
export interface DisplayOnInitOptions extends DisplayEventOptions {
}

// @public (undocumented)
export interface DisplayOnResizeOptions extends DisplayEventOptions {
}

// @public (undocumented)
export interface DisplayOptions {
    // (undocumented)
    clearColor?: number | string | THREE.Color;
    // Warning: (ae-forgotten-export) The symbol "IConfigurator" needs to be exported by the entry point index.d.ts
    configurator?: IConfigurator;
    // (undocumented)
    mode?: DisplayMode;
    pixelRatio?: number;
    // (undocumented)
    resizeStrategy?: DisplayResizeStrategy;
    // (undocumented)
    stage?: Stage2D;
}

// @public (undocumented)
export type DisplayResizeStrategy = HTMLElement | DisplayGetSizeFn | 'fullscreen';

// @public (undocumented)
export const findNextPowerOf2: (x: number) => number;

// @public (undocumented)
export const generateUuid: () => any;

// @public
export const get: (obj: Object, path: string) => unknown;

// @public (undocumented)
export const getBitmapCharBaseDescriptor: () => BitmapCharBaseDescriptorType;

// @public (undocumented)
export const getBitmapCharBaseGroup: () => BitmapCharBaseGroup;

// @public (undocumented)
export const getBitmapCharDescriptor: () => BitmapCharDescriptorType;

// Warning: (ae-forgotten-export) The symbol "ILoggerConfig" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const getGlobalLogConfig: () => ILoggerConfig;

// @public (undocumented)
export const getSimpleSpriteBaseGroup: () => SimpleSpriteBaseGroup;

// @public (undocumented)
export const globalStylesID: string;

// @public
export const hexCol2rgb: (hexColor: string) => number[];

// @public
export const hexCol2rgba: (hexColor: string, alpha?: number) => number[];

// @public (undocumented)
export type ImageSource = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;

// @public (undocumented)
export interface IMap2DEvent extends THREE_2.Event {
    // (undocumented)
    map2d: Map2D;
    // (undocumented)
    view: Map2DView;
}

// @public
export interface IMap2DLayer extends IMap2DLayerRenderer {
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getObject3D(): THREE_2.Object3D;
}

// @public (undocumented)
export interface IMap2DLayerData {
    getTileIdsWithin(left: number, top: number, width: number, height: number, uint32arr?: Uint32Array): Uint32Array;
    name: string;
    tileHeight: number;
    tileWidth: number;
    viewCullingThreshold: IViewCullingThreshold;
}

// @public (undocumented)
export interface IMap2DLayerRenderer {
    // (undocumented)
    addViewTile(tile: Map2DViewTile): void;
    // (undocumented)
    removeViewTile(tileId: string): void;
    // (undocumented)
    renderViewTile(tile: Map2DViewTile): void;
    // (undocumented)
    setViewOffset(x: number, y: number, depth: number): void;
}

// @public (undocumented)
export interface IMap2DRenderer {
    // (undocumented)
    beginRender(view: Map2DView): void;
    // (undocumented)
    endRender(view: Map2DView): void;
}

// Warning: (ae-forgotten-export) The symbol "IProjectionSpecs" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type IOrthographicProjectionSpecs = IProjectionSpecs & {
    near?: number;
    far?: number;
    distance?: number;
};

// @public (undocumented)
export type IParallaxProjectionSpecs = IProjectionSpecs & {
    near?: number;
    far?: number;
    distance?: number;
};

// @public (undocumented)
export interface IProjection {
    // (undocumented)
    camera: Camera;
    getZoom(distanceToProjectionPlane: number): number;
    // (undocumented)
    height: number;
    // (undocumented)
    origin: Vector2;
    // (undocumented)
    pixelRatioH: number;
    // (undocumented)
    pixelRatioV: number;
    // (undocumented)
    update(currentWidth: number, currentHeight: number): void;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export interface IRepeatingPatternLayerOptions {
    // (undocumented)
    limitToOneAxis?: LIMITATION_TO_ONE_AXIS;
}

// @public (undocumented)
export interface ISimpleSprite {
    // (undocumented)
    height: number;
    // (undocumented)
    left: number;
    // (undocumented)
    maxS: number;
    // (undocumented)
    maxT: number;
    // (undocumented)
    originS: number;
    // (undocumented)
    originT: number;
    // (undocumented)
    setPos: (left: number, top: number, width: number, height: number) => void;
    // (undocumented)
    setTex: (oiginS: number, originT: number, maxS: number, maxT: number) => void;
    // (undocumented)
    top: number;
    // (undocumented)
    width: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export interface ISimpleSpriteBase {
    // (undocumented)
    s0: number;
    // (undocumented)
    s1: number;
    // (undocumented)
    s2: number;
    // (undocumented)
    s3: number;
    // (undocumented)
    setPosition: (x0: number, z0: number, x1: number, z1: number, x2: number, z2: number, x3: number, z3: number) => void;
    // (undocumented)
    setUv: (u0: number, v0: number, u1: number, v1: number, u2: number, v2: number, u3: number, v3: number) => void;
    // (undocumented)
    t0: number;
    // (undocumented)
    t1: number;
    // (undocumented)
    t2: number;
    // (undocumented)
    t3: number;
    // (undocumented)
    x0: number;
    // (undocumented)
    x1: number;
    // (undocumented)
    x2: number;
    // (undocumented)
    x3: number;
    // (undocumented)
    z0: number;
    // (undocumented)
    z1: number;
    // (undocumented)
    z2: number;
    // (undocumented)
    z3: number;
}

// Warning: (ae-forgotten-export) The symbol "SimpleSpriteBaseMethodsType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface ISimpleSpriteBaseGroupOptions extends SpriteGroupOptions<SimpleSpriteBaseMethodsType, ISimpleSpriteBase> {
}

// Warning: (ae-forgotten-export) The symbol "SimpleSpriteMethodsType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface ISimpleSpriteGroupOptions extends SpriteGroupTexturedOptions<SimpleSpriteMethodsType, ISimpleSprite> {
}

// @public (undocumented)
export interface ISimpleSpritesOptions extends ISimpleSpriteGroupOptions {
}

// @public (undocumented)
export const isPowerOf2: (n: number) => boolean;

// @public (undocumented)
export interface ITexturable {
    // (undocumented)
    getTextureSource(): Texture;
}

// @public (undocumented)
export interface ITextureMaterial<T, M> {
    // (undocumented)
    id: string;
    // (undocumented)
    material: M;
    // (undocumented)
    refCount: number;
    // (undocumented)
    texture: T;
}

// @public (undocumented)
export interface ITileSet extends ITexturable {
    // (undocumented)
    getTextureById(id: number): Texture;
    // (undocumented)
    hasTextureId(id: number): boolean;
}

// @public (undocumented)
export interface IViewCullingThreshold {
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public (undocumented)
export type LIMITATION_TO_ONE_AXIS = 'horizontal' | 'vertical' | 'none';

// @public (undocumented)
export class Logger {
    constructor(name: string, throttleTimeoutMs?: number, stopAfterNLogs?: number);
    // (undocumented)
    get DEBUG(): boolean;
    // (undocumented)
    debug: (...args: any[]) => void;
    // (undocumented)
    get ERROR(): boolean;
    // (undocumented)
    error: (...args: any[]) => void;
    // (undocumented)
    get INFO(): boolean;
    // (undocumented)
    info: (...args: any[]) => void;
    // (undocumented)
    get LOG(): boolean;
    // (undocumented)
    log: (...args: any[]) => void;
    // (undocumented)
    logLevel: number;
    // (undocumented)
    paused: boolean;
    // (undocumented)
    stopAfterNLogs: number;
    // (undocumented)
    throttleTimeoutMs: number;
    // (undocumented)
    get VERBOSE(): boolean;
    // (undocumented)
    get WARN(): boolean;
    // (undocumented)
    warn: (...args: any[]) => void;
}

// Warning: (ae-forgotten-export) The symbol "CircleCoordsFn" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "CircleCoords" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const makeCircleCoords: (steps: number, radius?: number, circleCoordsFn?: CircleCoordsFn) => CircleCoords[];

// @public
export class Map2D extends Scene implements IMap2DRenderer {
    constructor();
    // (undocumented)
    appendLayer(layer: IMap2DLayer): void;
    // (undocumented)
    beginRender(view: Map2DView): void;
    // (undocumented)
    static get BeginRenderEvent(): string;
    // Warning: (ae-forgotten-export) The symbol "Map2DContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly context: Map2DContext;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    endRender(view: Map2DView): void;
    // (undocumented)
    static get EndRenderEvent(): string;
    // (undocumented)
    readonly layersGroup: Group;
    // (undocumented)
    readonly map2dLayers: Set<IMap2DLayer>;
    // (undocumented)
    readonly materialCache: MaterialCache<Texture_2, Material>;
    // (undocumented)
    removeLayer(layer: IMap2DLayer): void;
}

// @public @deprecated (undocumented)
export class Map2DFlat2DTilesLayer implements IMap2DLayer {
    constructor(indexedAtlas: TextureIndexedAtlas);
    // (undocumented)
    addViewTile(tile: Map2DViewTile): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getObject3D(): THREE_2.Object3D;
    // (undocumented)
    readonly indexedAtlas: TextureIndexedAtlas;
    // (undocumented)
    removeViewTile(tileId: string): void;
    // (undocumented)
    renderViewTile(_tile: Map2DViewTile): void;
    // (undocumented)
    setViewOffset(x: number, y: number, depth: number): void;
}

// Warning: (ae-forgotten-export) The symbol "InputControl" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Map2DPanControl extends InputControl {
    constructor(map2dView: Map2DView, projection: IProjection, options?: Map2DPanControlOptions);
    // (undocumented)
    cursorDefaultStyle: string;
    // (undocumented)
    cursorPanStyle: string;
    // (undocumented)
    keyCodes: [number, number, number, number];
    // (undocumented)
    map2dView: Map2DView;
    // (undocumented)
    mouseButton: number;
    // (undocumented)
    onKeyDown: ({ keyCode }: KeyboardEvent) => void;
    // (undocumented)
    onKeyUp: ({ keyCode }: KeyboardEvent) => void;
    // (undocumented)
    onPointerDown: (event: PointerEvent) => void;
    // (undocumented)
    onPointerMove: (event: PointerEvent) => void;
    // (undocumented)
    onPointerUp: (event: PointerEvent) => void;
    // (undocumented)
    pixelsPerSecond: number;
    // (undocumented)
    projection: IProjection;
    // (undocumented)
    speedEast: number;
    // (undocumented)
    speedNorth: number;
    // (undocumented)
    speedSouth: number;
    // (undocumented)
    speedWest: number;
    // (undocumented)
    start(): void;
    // (undocumented)
    update(t: number): void;
    }

// @public (undocumented)
export interface Map2DPanControlOptions {
    cursorDefaultStyle: string;
    cursorPanStyle: string;
    keyCodes: [number, number, number, number];
    mouseButton: number;
    speed: number;
}

// @public (undocumented)
export class Map2DTileBufferGeometry extends THREE_2.BufferGeometry {
    constructor(viewTile: Map2DViewTile, indexedAtlas: TextureIndexedAtlas);
    // (undocumented)
    readonly type: string;
}

// @public
export class Map2DTileQuadsLayer implements IMap2DLayer {
    constructor(tilesets: ITileSet[], meshCache: TileQuadMeshCache, materialCache: MaterialCache<THREE_2.Texture, THREE_2.Material>);
    // (undocumented)
    addViewTile(tile: Map2DViewTile): void;
    // (undocumented)
    static appendNewLayer(map2d: Map2D, tilesets: ITileSet[]): Map2DTileQuadsLayer;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getObject3D(): THREE_2.Group;
    // Warning: (ae-forgotten-export) The symbol "TileQuadMeshCache" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static getTileQuadMeshCache(map2d: Map2D): TileQuadMeshCache;
    // (undocumented)
    removeViewTile(tileId: string): void;
    // (undocumented)
    renderViewTile(_tile: Map2DViewTile): void;
    // (undocumented)
    setViewOffset(x: number, y: number, depth: number): void;
    // (undocumented)
    readonly tilesets: ITileSet[];
}

// @public
export class Map2DView {
    constructor(renderer: IMap2DRenderer, projection: IProjection, centerX?: number, centerY?: number, layerTileWidth?: number, layerTileHeight?: number);
    // (undocumented)
    addLayer(layer: Map2DViewLayer): void;
    // (undocumented)
    centerX: number;
    // (undocumented)
    centerY: number;
    // (undocumented)
    height: number;
    // (undocumented)
    readonly layers: Map2DViewLayer[];
    // (undocumented)
    readonly layerTileHeight: number;
    // (undocumented)
    readonly layerTileWidth: number;
    // (undocumented)
    get left(): number;
    // (undocumented)
    readonly projection: IProjection;
    // (undocumented)
    setDimension(width: number, height: number): void;
    // (undocumented)
    setOrigin(centerX: number, centerY: number): void;
    // (undocumented)
    get top(): number;
    // (undocumented)
    update(width?: number, height?: number): void;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export class Map2DViewFrame extends THREE_2.Object3D {
    constructor(map2d: Map2D, color?: number, yOffset?: number);
    // (undocumented)
    color: number;
    // (undocumented)
    readonly map2d: Map2D;
    // (undocumented)
    updateView(x: number, z: number, width: number, height: number): void;
    // (undocumented)
    yOffset: number;
}

// @public
export class Map2DViewLayer {
    constructor(view: Map2DView, layerRenderer: IMap2DLayerRenderer, layerData: IMap2DLayerData, [viewOffsetX, viewOffsetY, viewOffsetDepth]?: [number, number, number]);
    // (undocumented)
    readonly layerData: IMap2DLayerData;
    // (undocumented)
    readonly layerRenderer: IMap2DLayerRenderer;
    // (undocumented)
    readonly tileColumns: number;
    // (undocumented)
    readonly tileHeight: number;
    // (undocumented)
    readonly tileRows: number;
    // (undocumented)
    tiles: Map2DViewTile[];
    // (undocumented)
    readonly tileWidth: number;
    update(): void;
    // (undocumented)
    readonly view: Map2DView;
    // (undocumented)
    viewOffsetDepth: number;
    // (undocumented)
    viewOffsetX: number;
    // (undocumented)
    viewOffsetY: number;
}

// @public
export class Map2DViewTile {
    constructor(layerData: IMap2DLayerData, width: number, height: number);
    // (undocumented)
    fetchTileIds(): this;
    // (undocumented)
    getTileIdAt(x: number, y: number): number;
    // (undocumented)
    readonly height: number;
    // (undocumented)
    get id(): string;
    // (undocumented)
    isLayerTilePosition(left: number, top: number): boolean;
    // (undocumented)
    readonly layerData: IMap2DLayerData;
    // (undocumented)
    layerTileLeft: number;
    // (undocumented)
    layerTileTop: number;
    set left(left: number);
    // (undocumented)
    get left(): number;
    // (undocumented)
    setLayerTilePosition(left: number, top: number): void;
    // (undocumented)
    setPosition(left: number, top: number): this;
    // (undocumented)
    setViewOffset(x: number, y: number): void;
    // (undocumented)
    readonly tileIds: Uint32Array;
    // (undocumented)
    tileIdsNeedsUpdate: boolean;
    set top(top: number);
    // (undocumented)
    get top(): number;
    get viewHeight(): number;
    viewOffsetX: number;
    viewOffsetY: number;
    get viewWidth(): number;
    // (undocumented)
    readonly width: number;
}

// @public (undocumented)
export class MaterialCache<T, M> {
    // (undocumented)
    all(): ITextureMaterial<T, M>[];
    // (undocumented)
    clear(): void;
    // (undocumented)
    decRefCount(id: string): void;
    // (undocumented)
    get(id: string): ITextureMaterial<T, M>;
    // (undocumented)
    getMaterial(id: string): M;
    // (undocumented)
    getTexture(id: string): T;
    // (undocumented)
    has(id: string): boolean;
    // (undocumented)
    incRefCount(id: string): void;
    // (undocumented)
    listRefCounts(): {
        id: string;
        refCount: number;
    }[];
    // (undocumented)
    set(id: string, texture: T, material: M, refCount?: number): void;
}

// @public (undocumented)
export const maxOf: (a: number, b: number) => number;

// Warning: (ae-forgotten-export) The symbol "Projection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class OrthographicProjection extends Projection<IOrthographicProjectionSpecs, OrthographicCamera> {
    // (undocumented)
    updateOrtho(width: number, height: number, specs: IOrthographicProjectionSpecs): void;
}

// @public (undocumented)
export class ParallaxProjection extends Projection<IParallaxProjectionSpecs, PerspectiveCamera> {
    // (undocumented)
    distance: number;
    // (undocumented)
    fovy: number;
    // (undocumented)
    getZoom(distanceToProjectionPlane: number): number;
    // (undocumented)
    updateOrtho(width: number, height: number, specs: IParallaxProjectionSpecs): void;
}

// @public (undocumented)
export const pick: <T extends Object = Object>(names: (keyof T)[]) => (obj?: Object) => T;

// @public (undocumented)
export class Plane {
    constructor(type: 'xy' | 'xz');
    // (undocumented)
    type: 'xy' | 'xz';
    // (undocumented)
    static XY: Plane;
    // (undocumented)
    static XZ: Plane;
}

// @public (undocumented)
export const postFixID: string;

// @public
export class PowerOf2Image {
    constructor(from: string | ImageSource);
    get height(): number;
    // (undocumented)
    imgEl: ImageSource;
    get isLoaded(): boolean;
    // (undocumented)
    readonly loaded: Promise<PowerOf2Image>;
    // (undocumented)
    origHeight: number;
    // (undocumented)
    origWidth: number;
    // (undocumented)
    setImgEl(imgEl: ImageSource): void;
    get width(): number;
}

// @public (undocumented)
export const readOption: <T>(options: T, propName: keyof T, defValue?: any, funcArgs?: any) => unknown;

// @public (undocumented)
export class RepeatingPatternLayer implements IMap2DLayerData {
    constructor(tileWidth: number, tileHeight: number, pattern: number, options?: IRepeatingPatternLayerOptions);
    // (undocumented)
    static fromTile(tileset: ITileSet, tileId: number, options?: IRepeatingPatternLayerOptions): RepeatingPatternLayer;
    // (undocumented)
    getTileIdsWithin(_left: number, top: number, width: number, height: number, arr?: Uint32Array): Uint32Array;
    // (undocumented)
    limitToOneAxis: LIMITATION_TO_ONE_AXIS;
    // (undocumented)
    readonly name = "repeating-patterns";
    // (undocumented)
    readonly pattern: number;
    // (undocumented)
    readonly tileHeight: number;
    // (undocumented)
    readonly tileWidth: number;
    // (undocumented)
    readonly viewCullingThreshold: IViewCullingThreshold;
}

// @public (undocumented)
export const sample: <T>(arr: T[]) => T;

// @public (undocumented)
export const ShaderTool: {
    add: typeof add;
    asFloat: typeof asFloat;
    mat4: typeof mat4;
    mul: typeof mul;
    ret: (res: string) => string;
    rotate: (funcName?: string, x?: number, y?: number, z?: number) => string;
    rotateZ: (funcName?: string) => string;
    sub: typeof sub;
};

// @public (undocumented)
export class SimpleSpriteBaseGroup extends SpriteGroup<SimpleSpriteBaseMethodsType, ISimpleSpriteBase> {
    constructor(options?: ISimpleSpriteBaseGroupOptions);
}

// @public (undocumented)
export class SimpleSpriteGroup extends SpriteGroupTextured<SimpleSpriteMethodsType, ISimpleSprite> {
    constructor(options?: ISimpleSpriteGroupOptions);
}

// @public
export class SimpleSprites extends SpriteGroupMesh<SimpleSpriteMethodsType, ISimpleSprite, SimpleSpriteBaseMethodsType, ISimpleSpriteBase> {
    constructor(material: Material, options?: ISimpleSpritesOptions);
    // (undocumented)
    sprites: SimpleSpriteGroup;
}

// @public (undocumented)
export class SimpleSpritesMaterial extends ShaderMaterial {
    constructor(texture: Texture_2);
}

// @public (undocumented)
export class SpriteGridLayout {
    constructor(tileWidth: number, tileHeight: number, columns: number, spacing: number, z?: number, translateFn?: SpriteTranslateFn);
    // (undocumented)
    build(sprites: Array<unknown>): void;
    // (undocumented)
    columns: number;
    // (undocumented)
    get maxWidth(): number;
    // (undocumented)
    spacing: number;
    // (undocumented)
    tileHeight: number;
    // (undocumented)
    tileWidth: number;
    // (undocumented)
    translateFn: SpriteTranslateFn;
    // (undocumented)
    z: number;
}

// @public (undocumented)
export class SpriteGroup<T, U> {
    constructor(descriptor: VODescriptor<T, U>, options?: SpriteGroupOptions<T, U>);
    // (undocumented)
    get availableCount(): number;
    // (undocumented)
    get capacity(): number;
    // (undocumented)
    createSprite(width?: number, height?: number): VertexObject<T, U>;
    createSprites(count: number, width?: number, height?: number): VertexObject<T, U>[];
    // (undocumented)
    readonly descriptor: VODescriptor<T, U>;
    // (undocumented)
    readonly indices: VOIndices;
    // (undocumented)
    readonly isSpriteGroup = true;
    // (undocumented)
    setSpriteSize: SpriteSizeSetter<T, U>;
    touchVertexBuffers(): void;
    // (undocumented)
    get usedCount(): number;
    // (undocumented)
    readonly voPool: VOPool<T, U>;
}

// @public (undocumented)
export class SpriteGroupBufferGeometry<T, U> extends BufferGeometry {
    constructor(spriteGroup: SpriteGroup<T, U>);
    // (undocumented)
    get bufferVersion(): number;
    readonly parameters: {
        spriteGroup: SpriteGroup<T, U>;
    };
    // (undocumented)
    readonly picimoType: string;
    // (undocumented)
    updateBuffers(): void;
}

// @public (undocumented)
export class SpriteGroupInstancedBufferGeometry<T, U, K, I> extends InstancedBufferGeometry {
    constructor(base: SpriteGroup<K, I> | BufferGeometry, spriteGroup: SpriteGroup<T, U>);
    // (undocumented)
    get bufferVersion(): number;
    // (undocumented)
    get instancedBufferVersion(): number;
    // (undocumented)
    get maxInstancedCount(): number;
    set maxInstancedCount(_x: number);
    readonly parameters: {
        spriteGroup: SpriteGroup<T, U>;
        baseSpriteGroup?: SpriteGroup<K, I>;
    };
    // (undocumented)
    readonly picimoType = "SpriteGroupInstancedBufferGeometry";
    // (undocumented)
    updateBuffers(): void;
    // (undocumented)
    updateInstancedBuffers(): void;
}

// @public (undocumented)
export class SpriteGroupMesh<T, U = {}, K = {}, I = {}> extends Mesh {
    constructor(spriteGroupGeometry: SpriteGroupBufferGeometry<T, U> | SpriteGroupInstancedBufferGeometry<T, U, K, I>, material: Material);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    geometry: SpriteGroupBufferGeometry<T, U> | SpriteGroupInstancedBufferGeometry<T, U, K, I>;
    // (undocumented)
    onBeforeRender: () => void;
    }

// @public (undocumented)
export interface SpriteGroupOptions<T, U> {
    autotouch?: boolean;
    capacity?: number;
    dynamic?: boolean;
    // Warning: (ae-forgotten-export) The symbol "VOIndicesFactoryFn" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    indices?: VOIndices | VOIndicesFactoryFn;
    maxAllocVOSize?: number;
    setSize?: string | SpriteSizeSetter<T, U>;
    voArray?: VOArray;
    voNew?: VertexObject<T, U>;
    voZero?: VertexObject<T, U>;
}

// @public (undocumented)
export class SpriteGroupTextured<T, U> extends SpriteGroup<T, U> {
    constructor(descriptor: VODescriptor<T, U>, options?: SpriteGroupTexturedOptions<T, U>);
    createSpriteFromTexture(texture?: Texture, width?: number, height?: number): VertexObject<T, U>;
    // (undocumented)
    createSpritesFromTextures(textures: Texture[]): VertexObject<T, U>[];
    // (undocumented)
    setTexCoordsByTexture: SpriteTexCoordsSetter<T, U>;
}

// @public (undocumented)
export interface SpriteGroupTexturedOptions<T, U> extends SpriteGroupOptions<T, U> {
    // (undocumented)
    setTexCoordsByTexture?: SpriteTexCoordsSetter<T, U>;
}

// @public (undocumented)
export type SpriteSizeSetter<T, U> = (sprite: VertexObject<T, U>, w: number, h: number, descriptor: VODescriptor<T, U>) => void;

// @public (undocumented)
export type SpriteTexCoordsSetter<T, U> = (sprite: VertexObject<T, U>, texture: Texture, descriptor: VODescriptor<T, U>) => void;

// @public (undocumented)
export type SpriteTranslateFn = (sprite: unknown, x: number, y: number, z: number) => void;

// @public (undocumented)
export class Stage2D extends Scene {
    constructor(projection?: IProjection);
    // (undocumented)
    get camera(): Camera;
    // (undocumented)
    frame({ display }: {
        display: Display;
    }): void;
    // (undocumented)
    projection: IProjection;
    // (undocumented)
    resize({ width, height }: {
        width: number;
        height: number;
    }): void;
}

// @public
export class Stylesheets {
    static addRule(element: HTMLElement, name: string, css: string): string;
    // (undocumented)
    static getGlobalSheet(): CSSStyleSheet;
    // (undocumented)
    static installRule(name: string, css: string): string;
}

// @public (undocumented)
export type TextAlignH = 'left' | 'center' | 'right';

// @public (undocumented)
export type TextAlignV = 'top' | 'baseline' | 'center' | 'bottom';

// @public (undocumented)
export class Texture {
    constructor(source: TextureSource, width?: number, height?: number, x?: number, y?: number);
    // (undocumented)
    clone(): Texture;
    // (undocumented)
    flipH: boolean;
    // (undocumented)
    flipHorizontal(): this;
    // (undocumented)
    flipV: boolean;
    // (undocumented)
    flipVertical(): this;
    // (undocumented)
    getFeature(name: string): unknown;
    // (undocumented)
    get height(): number;
    set height(h: number);
    // (undocumented)
    image: TextureImage;
    // (undocumented)
    get imgEl(): HTMLCanvasElement | HTMLImageElement | HTMLVideoElement;
    // (undocumented)
    static load(url: string): Promise<Texture>;
    // (undocumented)
    get maxS(): number;
    // (undocumented)
    get maxT(): number;
    // (undocumented)
    get minS(): number;
    // (undocumented)
    get minT(): number;
    // (undocumented)
    parent: Texture;
    // (undocumented)
    get root(): Texture;
    // (undocumented)
    setFeature(name: string, value: unknown): void;
    // (undocumented)
    get uuid(): string;
    // (undocumented)
    get width(): number;
    set width(w: number);
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export class TextureAtlas implements ITexturable {
    constructor(baseTexture: Texture, data: TextureAtlasDescription);
    // (undocumented)
    addFrame(name: string, width: number, height: number, x: number, y: number, features?: Features): void;
    // Warning: (ae-forgotten-export) The symbol "Features" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addTexture(name: string, texture: Texture, features?: Features): void;
    // (undocumented)
    baseTexture: Texture;
    // (undocumented)
    frame(name: string): Texture;
    // (undocumented)
    frameNames(match?: string | RegExp): string[];
    // (undocumented)
    getFeature(name: string, defaultValue?: unknown): unknown;
    // (undocumented)
    getTextureSource(): Texture;
    static load(path: string, basePath?: string): Promise<TextureAtlas>;
    // (undocumented)
    randomFrame(): Texture;
    // (undocumented)
    randomFrameName(): string;
    // (undocumented)
    randomFrames(count: number): Texture[];
    // (undocumented)
    setFeature(name: string, value: unknown): void;
}

// @public (undocumented)
export interface TextureAtlasDescription {
    // (undocumented)
    frames: {
        [frameName: string]: TextureAtlasFrameDescription;
    };
    // (undocumented)
    meta: TextureAtlasMetaDescription;
}

// @public (undocumented)
export interface TextureAtlasFrameDescription extends Features {
    // (undocumented)
    baselineOffset?: number;
    // (undocumented)
    frame: {
        x: number;
        y: number;
        w: number;
        h: number;
    };
}

// @public (undocumented)
export interface TextureAtlasMetaDescription extends Features {
    // (undocumented)
    image: string;
    // (undocumented)
    lineHeight?: number;
}

// @public (undocumented)
export class TextureFactory {
    constructor(renderer?: WebGLRenderer, options?: TextureFactoryOptions);
    // (undocumented)
    createThreeTextureOptions(options?: ThreeTextureOptions): {
        flipY: boolean;
        magFilter: TextureFilter;
        minFilter: TextureFilter;
        anisotropy: number;
    };
    // (undocumented)
    DefaultAnisotrophy: number;
    // (undocumented)
    DefaultFilter: TextureFilter;
    // (undocumented)
    makeThreeTexture(source: ITexturable | Texture, options?: ThreeTextureOptions): Texture_2;
}

// @public (undocumented)
export interface TextureFactoryOptions {
    // (undocumented)
    defaultAnisotrophy?: number;
    // (undocumented)
    defaultFilter?: TextureFilter;
}

// @public (undocumented)
export type TextureImage = PowerOf2Image | ImageSource;

// @public (undocumented)
export class TextureIndexedAtlas implements ITileSet {
    constructor(atlas: TextureAtlas);
    // (undocumented)
    readonly atlas: TextureAtlas;
    // (undocumented)
    getTextureById(id: number): Texture;
    // (undocumented)
    getTextureByName(frame: string): Texture;
    // (undocumented)
    getTextureSource(): Texture;
    // (undocumented)
    hasTextureId(id: number): boolean;
    // (undocumented)
    static load(path: string, basePath?: string): Promise<TextureIndexedAtlas>;
    // (undocumented)
    setDefaultTexture(name: string): void;
    // (undocumented)
    setIdNameMap(idNameMap: Array<[number, string]>): void;
    // (undocumented)
    get textureNames(): string[];
}

// @public (undocumented)
export type TextureSource = Texture | TextureImage;

// @public (undocumented)
export interface ThreeTextureOptions {
    // (undocumented)
    anisotrophy?: number;
    // (undocumented)
    filter?: TextureFilter;
    // (undocumented)
    flipy?: boolean;
}

// @public (undocumented)
export class TiledMap {
    // Warning: (ae-forgotten-export) The symbol "ITiledMapData" needs to be exported by the entry point index.d.ts
    constructor(data: ITiledMapData);
    // (undocumented)
    createLayers(map2d: Map2D, map2dView: Map2DView, options?: TiledMapCreateLayersOptions): void;
    // (undocumented)
    getAllLayers(): TiledMapLayer[];
    // Warning: (ae-forgotten-export) The symbol "TiledMapLayer" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getLayer(name: string): TiledMapLayer;
    // (undocumented)
    get infinite(): boolean;
    // (undocumented)
    static load(url: string): Promise<TiledMap>;
    // (undocumented)
    loadTileSets(basePath?: string): Promise<TileSet[]>;
    // (undocumented)
    get orientation(): string;
    // (undocumented)
    get tileheight(): number;
    // (undocumented)
    readonly tilesets: Array<TileSet>;
    // (undocumented)
    get tilewidth(): number;
}

// @public (undocumented)
export interface TiledMapCreateLayersOptions {
    // (undocumented)
    layers?: string[];
    // (undocumented)
    yOffset?: number;
    // (undocumented)
    yStart?: number;
}

// @public (undocumented)
export class TileSet implements ITileSet {
    constructor(baseTexture: Texture, options?: TileSetOptions);
    // (undocumented)
    readonly baseTexture: Texture;
    // (undocumented)
    readonly firstId: number;
    // (undocumented)
    getTextureById(id: number): Texture;
    // (undocumented)
    getTextureSource(): Texture;
    // (undocumented)
    hasTextureId(id: number): boolean;
    // (undocumented)
    readonly lastId: number;
    // (undocumented)
    static load(path: string, options?: TileSetLoadOptions): Promise<TileSet>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    randomFrames(count: number): Texture[];
    // (undocumented)
    readonly tileCount: number;
    // (undocumented)
    readonly tileHeight: number;
    // (undocumented)
    readonly tileWidth: number;
}

// @public (undocumented)
export interface TileSetLoadOptions extends TileSetOptions {
    // (undocumented)
    basePath?: string;
}

// @public (undocumented)
export interface TileSetOptions {
    // (undocumented)
    columns?: number;
    // (undocumented)
    firstId?: number;
    // (undocumented)
    margin?: number;
    // (undocumented)
    name?: string;
    // (undocumented)
    padding?: number;
    // (undocumented)
    spacing?: number;
    // (undocumented)
    tileCount?: number;
    // (undocumented)
    tileHeight?: number;
    // (undocumented)
    tileWidth?: number;
}

// @public
export const toFloatColors: (colors: number[]) => number[];

// @public (undocumented)
export const unpick: <T extends Object>(names: string[]) => (obj?: Object) => T;

// @public (undocumented)
export class Vector2Proxy extends Vector2 {
    // Warning: (ae-forgotten-export) The symbol "VectorProp" needs to be exported by the entry point index.d.ts
    constructor(proxy: Vector2 | Vector3 | Vector4, xProp: VectorProp, yProp: VectorProp);
}

// @public (undocumented)
export const VERSION: any;

// Warning: (ae-forgotten-export) The symbol "VertexObjectMethods" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type VertexObject<T, U> = T & U & VertexObjectMethods<T, U>;

// @public
export class VOArray {
    // Warning: (ae-forgotten-export) The symbol "TypedArray" needs to be exported by the entry point index.d.ts
    constructor(capacity: number, bytesPerVO: number, arrayDataTypes: ArrayDataType[], data?: ArrayBuffer | DataView | TypedArray, hints?: VOArrayUsageOptions);
    // Warning: (ae-forgotten-export) The symbol "ArrayDataType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    arrayDataTypes: ArrayDataType[];
    // (undocumented)
    buffer: ArrayBuffer;
    // (undocumented)
    bufferByteLength: number;
    // (undocumented)
    bufferByteOffset: number;
    // (undocumented)
    bytesPerVO: number;
    // (undocumented)
    capacity: number;
    copy(from: VOArray, toOffset?: number): void;
    // (undocumented)
    float32Array: Float32Array;
    // (undocumented)
    getTypedArray(type: ArrayDataType): Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;
    // (undocumented)
    hints: VOArrayUsageHints;
    // (undocumented)
    int16Array: Int16Array;
    // (undocumented)
    int32Array: Int32Array;
    // (undocumented)
    int8Array: Int8Array;
    // (undocumented)
    serial: number;
    subarray(begin: number, size?: number): VOArray;
    toUint32Array(): Uint32Array;
    // (undocumented)
    uint16Array: Uint16Array;
    // (undocumented)
    uint32Array: Uint32Array;
    // (undocumented)
    uint8Array: Uint8Array;
}

// @public (undocumented)
export interface VOArrayUsageHints {
    // (undocumented)
    autotouch: boolean;
    // (undocumented)
    dynamic: boolean;
}

// @public (undocumented)
export interface VOArrayUsageOptions {
    // (undocumented)
    autotouch?: boolean;
    // (undocumented)
    dynamic?: boolean;
}

// @public (undocumented)
export type VOArrayValueType = 'float32' | 'int16' | 'int32' | 'int8' | 'uint16' | 'uint32' | 'uint8';

// @public (undocumented)
export interface VOAttrDescription {
    // (undocumented)
    name?: string;
    // (undocumented)
    scalars?: string[];
    // (undocumented)
    size?: number;
    // Warning: (ae-forgotten-export) The symbol "VOAttrDataType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    type?: VOAttrDataType;
    // (undocumented)
    uniform?: boolean;
}

// @public
export class VOAttrDescriptor {
    constructor(name: string, type: VOArrayValueType, size: number, offset: number | undefined, byteOffset: number | undefined, uniform: boolean, scalars?: string[]);
    // (undocumented)
    byteOffset: number;
    // (undocumented)
    bytesPerElement: number;
    // (undocumented)
    bytesPerVertex: number;
    // (undocumented)
    static defineProperties(attrDesc: any, propertiesObject: any, descriptor: any): void;
    // (undocumented)
    name: string;
    // (undocumented)
    offset: number;
    // (undocumented)
    scalars: string[];
    // (undocumented)
    size: number;
    // (undocumented)
    type: VOArrayValueType;
    // (undocumented)
    uniform: boolean;
    vertexAttrCount(descriptor: {
        bytesPerVertex: number;
    }): number;
}

// Warning: (ae-forgotten-export) The symbol "VOAttrsMap" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type VOAttributesDescription = VOAttrsMap | Array<VOAttrDescription>;

// @public (undocumented)
export interface VODescription<T> {
    // (undocumented)
    aliases?: any;
    // (undocumented)
    attributes: VOAttributesDescription;
    // (undocumented)
    methods?: T;
    // (undocumented)
    vertexCount?: number;
}

// @public
export class VODescriptor<T = Object, U = Object> {
    constructor({ vertexCount, attributes, aliases, methods }: VODescription<T>);
    // (undocumented)
    attr: {
        [attrName: string]: VOAttrDescriptor;
    };
    // (undocumented)
    attrList: VOAttrDescription[];
    // (undocumented)
    bytesPerVertex: number;
    // (undocumented)
    bytesPerVO: number;
    createVO(voArray?: VOArray, voInit?: VOInitializer<T, U>): VertexObject<T, U>;
    // (undocumented)
    createVOArray(size?: number, hints?: VOArrayUsageHints): VOArray;
    hasAttribute(name: string, size?: number): boolean;
    get maxIndexedVOPoolSize(): number;
    // (undocumented)
    rightPadBytesPerVertex: number;
    // (undocumented)
    scalars: string[];
    // (undocumented)
    typedArrays: {
        float32: boolean;
        int16: boolean;
        int32: boolean;
        int8: boolean;
        uint16: boolean;
        uint32: boolean;
        uint8: boolean;
    };
    // (undocumented)
    typeList: VOAttrDataType[];
    vertexAttrCount: number;
    vertexCount: number;
}

// @public
export class VOIndices {
    constructor(objectCount: number, itemCount: number);
    // (undocumented)
    static build(objectCount: number, indices: number[], stride: number, objectOffset?: number): VOIndices;
    // (undocumented)
    static buildQuads(count: number): VOIndices;
    // (undocumented)
    static buildTriangles(count: number): VOIndices;
    // (undocumented)
    indices: number[];
    // (undocumented)
    itemCount: number;
    // (undocumented)
    length: number;
    // (undocumented)
    objectCount: number;
}

// @public (undocumented)
export type VOInitializer<T, U> = Object | VOInitializerFn<T, U>;

// @public (undocumented)
export type VOInitializerFn<T, U> = (vo: VertexObject<T, U>) => void;

// @public (undocumented)
export class VOPool<T, U> {
    constructor(descriptor: VODescriptor<T, U>, options: VOPoolOptions<T, U>);
    alloc(): VertexObject<T, U>;
    get allocatedCount(): number;
    get availableCount(): number;
    // (undocumented)
    readonly availableVOs: VertexObject<T, U>[];
    // (undocumented)
    readonly capacity: number;
    // (undocumented)
    readonly descriptor: VODescriptor<T, U>;
    // (undocumented)
    dynamic: boolean;
    free(vo: VertexObject<T, U> | VertexObject<T, U>[]): void;
    freeAll(): void;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    maxAllocVOSize: number;
    multiAlloc(size: number, targetArray?: VertexObject<T, U>[]): VertexObject<T, U>[];
    get usedCount(): number;
    // (undocumented)
    readonly usedVOs: VertexObject<T, U>[];
    // (undocumented)
    voArray: VOArray;
    // (undocumented)
    voNew: VertexObject<T, U>;
    // (undocumented)
    voZero: VertexObject<T, U>;
}

// @public (undocumented)
export interface VOPoolOptions<T, U> {
    autotouch?: boolean;
    capacity?: number;
    dynamic?: boolean;
    maxAllocVOSize?: number;
    voArray?: VOArray;
    voNew?: VertexObject<T, U>;
    voZero?: VertexObject<T, U>;
}


// Warnings were encountered during analysis:
//
// src/utils/ShaderTool.ts:136:24 - (ae-forgotten-export) The symbol "add" needs to be exported by the entry point index.d.ts
// src/utils/ShaderTool.ts:136:24 - (ae-forgotten-export) The symbol "asFloat" needs to be exported by the entry point index.d.ts
// src/utils/ShaderTool.ts:136:24 - (ae-forgotten-export) The symbol "mat4" needs to be exported by the entry point index.d.ts
// src/utils/ShaderTool.ts:136:24 - (ae-forgotten-export) The symbol "mul" needs to be exported by the entry point index.d.ts
// src/utils/ShaderTool.ts:136:24 - (ae-forgotten-export) The symbol "sub" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
